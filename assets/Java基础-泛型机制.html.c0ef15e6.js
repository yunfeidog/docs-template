const e=JSON.parse('{"key":"v-d0efec14","path":"/docs/javacore/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6.html","title":"Java泛型机制","lang":"zh-CN","frontmatter":{"title":"Java泛型机制","icon":"write","category":["Java"],"tag":["Java"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"前言 Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。 为什么会引入泛型 泛型的本质是为了...","head":[["meta",{"property":"og:url","content":"https://github.com/yunfeidog/docs-template/docs/javacore/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"网站的标题"}],["meta",{"property":"og:title","content":"Java泛型机制"}],["meta",{"property":"og:description","content":"前言 Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。 为什么会引入泛型 泛型的本质是为了..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2024-04-27T06:35:08.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2024-04-27T06:35:08.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"为什么会引入泛型","slug":"为什么会引入泛型","link":"#为什么会引入泛型","children":[]}],"git":{"createdTime":1714199708000,"updatedTime":1714199708000,"contributors":[{"name":"yunfeidog","email":"1844025705@qq.com","commits":1}]},"readingTime":{"minutes":3.83,"words":1149},"filePathRelative":"docs/javacore/Java基础-泛型机制.md","localizedDate":"2024年4月27日"}');export{e as data};
