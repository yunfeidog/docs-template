import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as l,d as n}from"./app-CKRV3Rln.js";const h={},t=n('<h2 id="手写lru缓存淘汰算法" tabindex="-1"><a class="header-anchor" href="#手写lru缓存淘汰算法"><span>手写LRU缓存淘汰算法</span></a></h2><h3 id="lru算法描述" tabindex="-1"><a class="header-anchor" href="#lru算法描述"><span>LRU算法描述</span></a></h3><h3 id="lru算法设计" tabindex="-1"><a class="header-anchor" href="#lru算法设计"><span>LRU算法设计</span></a></h3><h3 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h3><h2 id="手写lfu算法" tabindex="-1"><a class="header-anchor" href="#手写lfu算法"><span>手写LFU算法</span></a></h2><h3 id="算法描述" tabindex="-1"><a class="header-anchor" href="#算法描述"><span>算法描述</span></a></h3><h3 id="思路分析" tabindex="-1"><a class="header-anchor" href="#思路分析"><span>思路分析</span></a></h3><h3 id="代码框架" tabindex="-1"><a class="header-anchor" href="#代码框架"><span>代码框架</span></a></h3><h3 id="lfu核心逻辑" tabindex="-1"><a class="header-anchor" href="#lfu核心逻辑"><span>LFU核心逻辑</span></a></h3><h2 id="二叉树搜索树操作集锦" tabindex="-1"><a class="header-anchor" href="#二叉树搜索树操作集锦"><span>二叉树搜索树操作集锦</span></a></h2><h3 id="判断bst的合法性" tabindex="-1"><a class="header-anchor" href="#判断bst的合法性"><span>判断BST的合法性</span></a></h3><h3 id="在bst中查找一个数是否存在" tabindex="-1"><a class="header-anchor" href="#在bst中查找一个数是否存在"><span>在BST中查找一个数是否存在</span></a></h3><h3 id="在bst中插入一个数" tabindex="-1"><a class="header-anchor" href="#在bst中插入一个数"><span>在BST中插入一个数</span></a></h3><h3 id="在bst中删除一个数" tabindex="-1"><a class="header-anchor" href="#在bst中删除一个数"><span>在BST中删除一个数</span></a></h3><h2 id="完全二叉树的节点数为什么难算" tabindex="-1"><a class="header-anchor" href="#完全二叉树的节点数为什么难算"><span>完全二叉树的节点数为什么难算</span></a></h2><h3 id="思路分析-1" tabindex="-1"><a class="header-anchor" href="#思路分析-1"><span>思路分析</span></a></h3><h3 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析"><span>复杂度分析</span></a></h3><h2 id="用各种遍历框架序列化和反序列化二叉树" tabindex="-1"><a class="header-anchor" href="#用各种遍历框架序列化和反序列化二叉树"><span>用各种遍历框架序列化和反序列化二叉树</span></a></h2><h3 id="题目描述" tabindex="-1"><a class="header-anchor" href="#题目描述"><span>题目描述</span></a></h3><h3 id="前序遍历解法" tabindex="-1"><a class="header-anchor" href="#前序遍历解法"><span>前序遍历解法</span></a></h3><h3 id="后序遍历解法" tabindex="-1"><a class="header-anchor" href="#后序遍历解法"><span>后序遍历解法</span></a></h3><h3 id="中序遍历解法" tabindex="-1"><a class="header-anchor" href="#中序遍历解法"><span>中序遍历解法</span></a></h3><h3 id="层级遍历解法" tabindex="-1"><a class="header-anchor" href="#层级遍历解法"><span>层级遍历解法</span></a></h3><h2 id="git原理之二叉树最近公共祖先" tabindex="-1"><a class="header-anchor" href="#git原理之二叉树最近公共祖先"><span>Git原理之二叉树最近公共祖先</span></a></h2><h3 id="二叉树的最近公共祖先" tabindex="-1"><a class="header-anchor" href="#二叉树的最近公共祖先"><span>二叉树的最近公共祖先</span></a></h3><h3 id="思路分析-2" tabindex="-1"><a class="header-anchor" href="#思路分析-2"><span>思路分析</span></a></h3><h2 id="特殊数据结构-单调栈" tabindex="-1"><a class="header-anchor" href="#特殊数据结构-单调栈"><span>特殊数据结构-单调栈</span></a></h2><h3 id="单调栈解题模版" tabindex="-1"><a class="header-anchor" href="#单调栈解题模版"><span>单调栈解题模版</span></a></h3><h3 id="题目变形" tabindex="-1"><a class="header-anchor" href="#题目变形"><span>题目变形</span></a></h3><h3 id="如何处理循环数组" tabindex="-1"><a class="header-anchor" href="#如何处理循环数组"><span>如何处理循环数组</span></a></h3><h2 id="特殊数据结构-单调队列" tabindex="-1"><a class="header-anchor" href="#特殊数据结构-单调队列"><span>特殊数据结构-单调队列</span></a></h2><h3 id="搭建解题框架" tabindex="-1"><a class="header-anchor" href="#搭建解题框架"><span>搭建解题框架</span></a></h3><h3 id="实现单调队列数据结构" tabindex="-1"><a class="header-anchor" href="#实现单调队列数据结构"><span>实现单调队列数据结构</span></a></h3><h3 id="算法复杂度分析" tabindex="-1"><a class="header-anchor" href="#算法复杂度分析"><span>算法复杂度分析</span></a></h3><h2 id="如何判断回文链表" tabindex="-1"><a class="header-anchor" href="#如何判断回文链表"><span>如何判断回文链表</span></a></h2><h3 id="判断回文单链表" tabindex="-1"><a class="header-anchor" href="#判断回文单链表"><span>判断回文单链表</span></a></h3><h3 id="优化空间复杂度" tabindex="-1"><a class="header-anchor" href="#优化空间复杂度"><span>优化空间复杂度</span></a></h3><h3 id="最后总结" tabindex="-1"><a class="header-anchor" href="#最后总结"><span>最后总结</span></a></h3><h2 id="秀操作-纯递归反转链表" tabindex="-1"><a class="header-anchor" href="#秀操作-纯递归反转链表"><span>秀操作-纯递归反转链表</span></a></h2><h3 id="递归反转整个链表" tabindex="-1"><a class="header-anchor" href="#递归反转整个链表"><span>递归反转整个链表</span></a></h3><h3 id="反转链表前n个节点" tabindex="-1"><a class="header-anchor" href="#反转链表前n个节点"><span>反转链表前N个节点</span></a></h3><h3 id="反转链表的一部分" tabindex="-1"><a class="header-anchor" href="#反转链表的一部分"><span>反转链表的一部分</span></a></h3><h3 id="最后总结-1" tabindex="-1"><a class="header-anchor" href="#最后总结-1"><span>最后总结</span></a></h3><h2 id="秀操作-k个一组反转链表" tabindex="-1"><a class="header-anchor" href="#秀操作-k个一组反转链表"><span>秀操作-K个一组反转链表</span></a></h2><h3 id="分析问题" tabindex="-1"><a class="header-anchor" href="#分析问题"><span>分析问题</span></a></h3><h3 id="代码实现-1" tabindex="-1"><a class="header-anchor" href="#代码实现-1"><span>代码实现</span></a></h3><h3 id="最后总结-2" tabindex="-1"><a class="header-anchor" href="#最后总结-2"><span>最后总结</span></a></h3>',47),i=[t];function s(r,d){return a(),l("div",null,i)}const o=e(h,[["render",s],["__file","算法小抄数据结构.html.vue"]]),u=JSON.parse('{"path":"/docs/algdata/lbld/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"数据结构","lang":"en-US","frontmatter":{"title":"数据结构","icon":"write","category":["算法","数据结构"],"tag":["算法","数据结构"],"sticky":false,"star":false,"article":true,"timeline":true,"description":"手写LRU缓存淘汰算法 LRU算法描述 LRU算法设计 代码实现 手写LFU算法 算法描述 思路分析 代码框架 LFU核心逻辑 二叉树搜索树操作集锦 判断BST的合法性 在BST中查找一个数是否存在 在BST中插入一个数 在BST中删除一个数 完全二叉树的节点数为什么难算 思路分析 复杂度分析 用各种遍历框架序列化和反序列化二叉树 题目描述 前序遍历解...","head":[["meta",{"property":"og:url","content":"https://github.com/yunfeidog/docs-template/docs/algdata/lbld/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"网站的标1题"}],["meta",{"property":"og:title","content":"数据结构"}],["meta",{"property":"og:description","content":"手写LRU缓存淘汰算法 LRU算法描述 LRU算法设计 代码实现 手写LFU算法 算法描述 思路分析 代码框架 LFU核心逻辑 二叉树搜索树操作集锦 判断BST的合法性 在BST中查找一个数是否存在 在BST中插入一个数 在BST中删除一个数 完全二叉树的节点数为什么难算 思路分析 复杂度分析 用各种遍历框架序列化和反序列化二叉树 题目描述 前序遍历解..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-04-27T06:35:08.000Z"}],["meta",{"property":"article:author","content":"网站的作者"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:modified_time","content":"2024-04-27T06:35:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-27T06:35:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"网站的作者\\",\\"url\\":\\"http://yunfei.plus\\"}]}"]]},"headers":[{"level":2,"title":"手写LRU缓存淘汰算法","slug":"手写lru缓存淘汰算法","link":"#手写lru缓存淘汰算法","children":[{"level":3,"title":"LRU算法描述","slug":"lru算法描述","link":"#lru算法描述","children":[]},{"level":3,"title":"LRU算法设计","slug":"lru算法设计","link":"#lru算法设计","children":[]},{"level":3,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]}]},{"level":2,"title":"手写LFU算法","slug":"手写lfu算法","link":"#手写lfu算法","children":[{"level":3,"title":"算法描述","slug":"算法描述","link":"#算法描述","children":[]},{"level":3,"title":"思路分析","slug":"思路分析","link":"#思路分析","children":[]},{"level":3,"title":"代码框架","slug":"代码框架","link":"#代码框架","children":[]},{"level":3,"title":"LFU核心逻辑","slug":"lfu核心逻辑","link":"#lfu核心逻辑","children":[]}]},{"level":2,"title":"二叉树搜索树操作集锦","slug":"二叉树搜索树操作集锦","link":"#二叉树搜索树操作集锦","children":[{"level":3,"title":"判断BST的合法性","slug":"判断bst的合法性","link":"#判断bst的合法性","children":[]},{"level":3,"title":"在BST中查找一个数是否存在","slug":"在bst中查找一个数是否存在","link":"#在bst中查找一个数是否存在","children":[]},{"level":3,"title":"在BST中插入一个数","slug":"在bst中插入一个数","link":"#在bst中插入一个数","children":[]},{"level":3,"title":"在BST中删除一个数","slug":"在bst中删除一个数","link":"#在bst中删除一个数","children":[]}]},{"level":2,"title":"完全二叉树的节点数为什么难算","slug":"完全二叉树的节点数为什么难算","link":"#完全二叉树的节点数为什么难算","children":[{"level":3,"title":"思路分析","slug":"思路分析-1","link":"#思路分析-1","children":[]},{"level":3,"title":"复杂度分析","slug":"复杂度分析","link":"#复杂度分析","children":[]}]},{"level":2,"title":"用各种遍历框架序列化和反序列化二叉树","slug":"用各种遍历框架序列化和反序列化二叉树","link":"#用各种遍历框架序列化和反序列化二叉树","children":[{"level":3,"title":"题目描述","slug":"题目描述","link":"#题目描述","children":[]},{"level":3,"title":"前序遍历解法","slug":"前序遍历解法","link":"#前序遍历解法","children":[]},{"level":3,"title":"后序遍历解法","slug":"后序遍历解法","link":"#后序遍历解法","children":[]},{"level":3,"title":"中序遍历解法","slug":"中序遍历解法","link":"#中序遍历解法","children":[]},{"level":3,"title":"层级遍历解法","slug":"层级遍历解法","link":"#层级遍历解法","children":[]}]},{"level":2,"title":"Git原理之二叉树最近公共祖先","slug":"git原理之二叉树最近公共祖先","link":"#git原理之二叉树最近公共祖先","children":[{"level":3,"title":"二叉树的最近公共祖先","slug":"二叉树的最近公共祖先","link":"#二叉树的最近公共祖先","children":[]},{"level":3,"title":"思路分析","slug":"思路分析-2","link":"#思路分析-2","children":[]}]},{"level":2,"title":"特殊数据结构-单调栈","slug":"特殊数据结构-单调栈","link":"#特殊数据结构-单调栈","children":[{"level":3,"title":"单调栈解题模版","slug":"单调栈解题模版","link":"#单调栈解题模版","children":[]},{"level":3,"title":"题目变形","slug":"题目变形","link":"#题目变形","children":[]},{"level":3,"title":"如何处理循环数组","slug":"如何处理循环数组","link":"#如何处理循环数组","children":[]}]},{"level":2,"title":"特殊数据结构-单调队列","slug":"特殊数据结构-单调队列","link":"#特殊数据结构-单调队列","children":[{"level":3,"title":"搭建解题框架","slug":"搭建解题框架","link":"#搭建解题框架","children":[]},{"level":3,"title":"实现单调队列数据结构","slug":"实现单调队列数据结构","link":"#实现单调队列数据结构","children":[]},{"level":3,"title":"算法复杂度分析","slug":"算法复杂度分析","link":"#算法复杂度分析","children":[]}]},{"level":2,"title":"如何判断回文链表","slug":"如何判断回文链表","link":"#如何判断回文链表","children":[{"level":3,"title":"判断回文单链表","slug":"判断回文单链表","link":"#判断回文单链表","children":[]},{"level":3,"title":"优化空间复杂度","slug":"优化空间复杂度","link":"#优化空间复杂度","children":[]},{"level":3,"title":"最后总结","slug":"最后总结","link":"#最后总结","children":[]}]},{"level":2,"title":"秀操作-纯递归反转链表","slug":"秀操作-纯递归反转链表","link":"#秀操作-纯递归反转链表","children":[{"level":3,"title":"递归反转整个链表","slug":"递归反转整个链表","link":"#递归反转整个链表","children":[]},{"level":3,"title":"反转链表前N个节点","slug":"反转链表前n个节点","link":"#反转链表前n个节点","children":[]},{"level":3,"title":"反转链表的一部分","slug":"反转链表的一部分","link":"#反转链表的一部分","children":[]},{"level":3,"title":"最后总结","slug":"最后总结-1","link":"#最后总结-1","children":[]}]},{"level":2,"title":"秀操作-K个一组反转链表","slug":"秀操作-k个一组反转链表","link":"#秀操作-k个一组反转链表","children":[{"level":3,"title":"分析问题","slug":"分析问题","link":"#分析问题","children":[]},{"level":3,"title":"代码实现","slug":"代码实现-1","link":"#代码实现-1","children":[]},{"level":3,"title":"最后总结","slug":"最后总结-2","link":"#最后总结-2","children":[]}]}],"git":{"createdTime":1714199708000,"updatedTime":1714199708000,"contributors":[{"name":"yunfeidog","email":"1844025705@qq.com","commits":1}]},"readingTime":{"minutes":1.46,"words":439},"filePathRelative":"docs/algdata/lbld/算法小抄数据结构.md","localizedDate":"April 27, 2024","excerpt":"<h2>手写LRU缓存淘汰算法</h2>\\n<h3>LRU算法描述</h3>\\n<h3>LRU算法设计</h3>\\n<h3>代码实现</h3>\\n<h2>手写LFU算法</h2>\\n<h3>算法描述</h3>\\n<h3>思路分析</h3>\\n<h3>代码框架</h3>\\n<h3>LFU核心逻辑</h3>\\n<h2>二叉树搜索树操作集锦</h2>\\n<h3>判断BST的合法性</h3>\\n<h3>在BST中查找一个数是否存在</h3>","autoDesc":true}');export{o as comp,u as data};
