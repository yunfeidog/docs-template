const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":268,\"nextId\":268,\"documentIds\":{\"0\":\"1\",\"1\":\"1#标题显示在右侧\",\"2\":\"1@0\",\"3\":\"1@1\",\"4\":\"3\",\"5\":\"3#java核心\",\"6\":\"3#java虚拟机\",\"7\":\"3#企业级框架\",\"8\":\"3#netty\",\"9\":\"3#算法和数据结构\",\"10\":\"3#数据库\",\"11\":\"3#开发必备\",\"12\":\"3#在线技术文档\",\"13\":\"3@0\",\"14\":\"3@1\",\"15\":\"4\",\"16\":\"4@0\",\"17\":\"4@1\",\"18\":\"5\",\"19\":\"5#专业软件\",\"20\":\"5@0\",\"21\":\"5@1\",\"22\":\"6\",\"23\":\"6@0\",\"24\":\"6@1\",\"25\":\"7\",\"26\":\"7@0\",\"27\":\"7@1\",\"28\":\"8\",\"29\":\"8#optional类\",\"30\":\"8#引入\",\"31\":\"8#源码解读及各api的使用\",\"32\":\"8#of\",\"33\":\"8#empty\",\"34\":\"8#ofnullable\",\"35\":\"8#orelse\",\"36\":\"8#orelseget\",\"37\":\"8#orelsethrow\",\"38\":\"8#map\",\"39\":\"8#flatmap\",\"40\":\"8#filter\",\"41\":\"8#ispresent\",\"42\":\"8#ifpresent\",\"43\":\"8#get\",\"44\":\"8#equals\",\"45\":\"8#hashcode\",\"46\":\"8#tostring\",\"47\":\"8#使用例子\",\"48\":\"8#使用总结\",\"49\":\"8@0\",\"50\":\"8@1\",\"51\":\"10\",\"52\":\"10@0\",\"53\":\"10@1\",\"54\":\"11\",\"55\":\"11@0\",\"56\":\"11@1\",\"57\":\"12\",\"58\":\"12#前言\",\"59\":\"12#为什么会引入泛型\",\"60\":\"12@0\",\"61\":\"12@1\",\"62\":\"13\",\"63\":\"13@0\",\"64\":\"13@1\",\"65\":\"14\",\"66\":\"14#三大特性\",\"67\":\"14@0\",\"68\":\"14@1\",\"69\":\"15\",\"70\":\"15#概述\",\"71\":\"15#arraylist的实现\",\"72\":\"15#底层数据结构\",\"73\":\"15#构造函数\",\"74\":\"15#两个常用数组拷贝方法\",\"75\":\"15#自动扩容\",\"76\":\"15#add-addall\",\"77\":\"15#set\",\"78\":\"15#get\",\"79\":\"15#remove-removeall-retainall\",\"80\":\"15#size\",\"81\":\"15#isempty\",\"82\":\"15#contains\",\"83\":\"15#toarray\",\"84\":\"15#clear\",\"85\":\"15#sublist\",\"86\":\"15#trimtosize\",\"87\":\"15#indexof-lastindexof\",\"88\":\"15#foreach-removeif-replaceall-sort\",\"89\":\"15#fail-fast机制\",\"90\":\"15#参考\",\"91\":\"15@0\",\"92\":\"15@1\",\"93\":\"16\",\"94\":\"16#类关系图\",\"95\":\"16#简单介绍\",\"96\":\"16#collection\",\"97\":\"16#如何学习\",\"98\":\"16#如何遍历\",\"99\":\"16#set\",\"100\":\"16#list\",\"101\":\"16#queue\",\"102\":\"16#map\",\"103\":\"16#如何学习-1\",\"104\":\"16#如何遍历-1\",\"105\":\"16#treemap\",\"106\":\"16#hashmap\",\"107\":\"16#hashtable\",\"108\":\"16#linkedhashmap\",\"109\":\"16#参考\",\"110\":\"16@0\",\"111\":\"16@1\",\"112\":\"17\",\"113\":\"17@0\",\"114\":\"17@1\",\"115\":\"18\",\"116\":\"18@0\",\"117\":\"18@1\",\"118\":\"19\",\"119\":\"19@0\",\"120\":\"19@1\",\"121\":\"20\",\"122\":\"20@0\",\"123\":\"20@1\",\"124\":\"21\",\"125\":\"21@0\",\"126\":\"21@1\",\"127\":\"22\",\"128\":\"22#常用的位操作\",\"129\":\"22#java中的位操作符\",\"130\":\"22#_4个位逻辑运算符\",\"131\":\"22#_3个移位运算符\",\"132\":\"22#几个有趣的位操作\",\"133\":\"22#n-n-1-的运用\",\"134\":\"22#a-a-0的运用\",\"135\":\"22#两道常考的阶乘算法题\",\"136\":\"22#题一\",\"137\":\"22#题二\",\"138\":\"22#高效寻找素数\",\"139\":\"22#高效进行模幂运算\",\"140\":\"22#如何处理数组指数\",\"141\":\"22#如何处理mod运算\",\"142\":\"22#如何高效求幂-快速幂\",\"143\":\"22#同时寻找缺失和重复的元素\",\"144\":\"22#在无限序列中随机抽取元素\",\"145\":\"22#游戏中的随机算法\",\"146\":\"22#一行代码解决的算法题\",\"147\":\"22#几个反直觉的概率问题\",\"148\":\"22@0\",\"149\":\"22@1\",\"150\":\"23\",\"151\":\"23#手写lru缓存淘汰算法\",\"152\":\"23#lru算法描述\",\"153\":\"23#lru算法设计\",\"154\":\"23#代码实现\",\"155\":\"23#手写lfu算法\",\"156\":\"23#算法描述\",\"157\":\"23#思路分析\",\"158\":\"23#代码框架\",\"159\":\"23#lfu核心逻辑\",\"160\":\"23#二叉树搜索树操作集锦\",\"161\":\"23#判断bst的合法性\",\"162\":\"23#在bst中查找一个数是否存在\",\"163\":\"23#在bst中插入一个数\",\"164\":\"23#在bst中删除一个数\",\"165\":\"23#完全二叉树的节点数为什么难算\",\"166\":\"23#思路分析-1\",\"167\":\"23#复杂度分析\",\"168\":\"23#用各种遍历框架序列化和反序列化二叉树\",\"169\":\"23#题目描述\",\"170\":\"23#前序遍历解法\",\"171\":\"23#后序遍历解法\",\"172\":\"23#中序遍历解法\",\"173\":\"23#层级遍历解法\",\"174\":\"23#git原理之二叉树最近公共祖先\",\"175\":\"23#二叉树的最近公共祖先\",\"176\":\"23#思路分析-2\",\"177\":\"23#特殊数据结构-单调栈\",\"178\":\"23#单调栈解题模版\",\"179\":\"23#题目变形\",\"180\":\"23#如何处理循环数组\",\"181\":\"23#特殊数据结构-单调队列\",\"182\":\"23#搭建解题框架\",\"183\":\"23#实现单调队列数据结构\",\"184\":\"23#算法复杂度分析\",\"185\":\"23#如何判断回文链表\",\"186\":\"23#判断回文单链表\",\"187\":\"23#优化空间复杂度\",\"188\":\"23#最后总结\",\"189\":\"23#秀操作-纯递归反转链表\",\"190\":\"23#递归反转整个链表\",\"191\":\"23#反转链表前n个节点\",\"192\":\"23#反转链表的一部分\",\"193\":\"23#最后总结-1\",\"194\":\"23#秀操作-k个一组反转链表\",\"195\":\"23#分析问题\",\"196\":\"23#代码实现-1\",\"197\":\"23#最后总结-2\",\"198\":\"23@0\",\"199\":\"23@1\",\"200\":\"24\",\"201\":\"24#学习算法和刷题的框架思维\",\"202\":\"24#数据结构的存储方式\",\"203\":\"24#数据结构的基本操作\",\"204\":\"24#算法刷题指南\",\"205\":\"24#动态规划解题套路框架\",\"206\":\"24#回溯算法解题套路框架\",\"207\":\"24#全排列问题\",\"208\":\"24#n皇后问题\",\"209\":\"24#最后总结\",\"210\":\"24#bfs算法套路框架\",\"211\":\"24#算法框架\",\"212\":\"24#二叉树的最小高度\",\"213\":\"24#解开密码锁的最少次数\",\"214\":\"24#双指针技巧套路框架\",\"215\":\"24#快慢指针的常用算法\",\"216\":\"24#判定链表中是否含有环\",\"217\":\"24#已知链表中含有环-返回这个环的起始位置\",\"218\":\"24#寻找无环单链表的中点\",\"219\":\"24#寻找单链表的倒数第k个元素\",\"220\":\"24#左右指针的常用算法\",\"221\":\"24#二分搜索\",\"222\":\"24#两数之和\",\"223\":\"24#反转数组\",\"224\":\"24#滑动窗口算法\",\"225\":\"24#二分搜索算法\",\"226\":\"24#二分搜索框架\",\"227\":\"24#寻找一个数-基本的二分搜索\",\"228\":\"24#寻找左侧边界的二分搜索\",\"229\":\"24#寻找右侧边界的二分搜索\",\"230\":\"24#逻辑统一\",\"231\":\"24#滑动窗口算法变成默写题\",\"232\":\"24#最小覆盖子串\",\"233\":\"24#字符串排列\",\"234\":\"24#找所有字母异位词\",\"235\":\"24#最长无重复子串\",\"236\":\"24@0\",\"237\":\"24@1\",\"238\":\"25\",\"239\":\"25@0\",\"240\":\"25@1\",\"241\":\"26\",\"242\":\"26#如何高效寻找素数\",\"243\":\"26#一般实现\",\"244\":\"26#稍加优化\",\"245\":\"26#高效实现\",\"246\":\"26#如何高效进行模幂运算\",\"247\":\"26#如何处理数组指数\",\"248\":\"26#如何处理mod运算\",\"249\":\"26#如何高效求幂\",\"250\":\"26#如何运用二分搜索算法\",\"251\":\"26#如何高效解决接雨水问题\",\"252\":\"26#如何去除有序数组的重复元素\",\"253\":\"26#如何寻找最长回文子串\",\"254\":\"26#如何运用贪心思想玩跳跃游戏\",\"255\":\"26#如何运用贪心算法做时间管理\",\"256\":\"26#如何判定括号合法性\",\"257\":\"26#如何调度考生的座位\",\"258\":\"26#union-find算法详解\",\"259\":\"26#union-find算法应用\",\"260\":\"26#一行代码就能解决的算法题\",\"261\":\"26#nim游戏\",\"262\":\"26#石子游戏\",\"263\":\"26#电灯开关问题\",\"264\":\"26@0\",\"265\":\"26@1\",\"266\":\"27\",\"267\":\"28\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,5],\"2\":[null,null,2],\"3\":[null,null,2],\"4\":[1],\"5\":[1],\"6\":[1],\"7\":[1],\"8\":[1,2],\"9\":[1],\"10\":[1],\"11\":[1],\"12\":[1],\"13\":[null,null,2],\"14\":[null,null,2],\"15\":[1],\"16\":[null,null,2],\"17\":[null,null,2],\"18\":[2],\"19\":[1,7],\"20\":[null,null,1],\"21\":[null,null,1],\"22\":[2,1],\"23\":[null,null,1],\"24\":[null,null,1],\"25\":[1],\"26\":[null,null,2],\"27\":[null,null,2],\"28\":[1],\"29\":[1],\"30\":[1,52],\"31\":[1,41],\"32\":[1,20],\"33\":[1,14],\"34\":[1,39],\"35\":[1,40],\"36\":[1,46],\"37\":[1,70],\"38\":[1,61],\"39\":[1,64],\"40\":[1,50],\"41\":[1,9],\"42\":[1,14],\"43\":[1,15],\"44\":[1,29],\"45\":[1,9],\"46\":[1,14],\"47\":[1,125],\"48\":[1,47],\"49\":[null,null,1],\"50\":[null,null,1],\"51\":[1],\"52\":[null,null,1],\"53\":[null,null,1],\"54\":[1],\"55\":[null,null,1],\"56\":[null,null,1],\"57\":[1],\"58\":[1,18],\"59\":[1,136],\"60\":[null,null,1],\"61\":[null,null,1],\"62\":[1],\"63\":[null,null,1],\"64\":[null,null,1],\"65\":[1],\"66\":[1],\"67\":[null,null,1],\"68\":[null,null,1],\"69\":[1],\"70\":[1,35],\"71\":[1],\"72\":[1,20],\"73\":[1,65],\"74\":[1,64],\"75\":[1,138],\"76\":[3,212],\"77\":[2,15],\"78\":[2,12],\"79\":[4,114],\"80\":[2,8],\"81\":[2,9],\"82\":[2,12],\"83\":[2,36],\"84\":[2,22],\"85\":[2,15],\"86\":[2,20],\"87\":[3,26],\"88\":[5,76],\"89\":[2,6],\"90\":[1,28],\"91\":[null,null,1],\"92\":[null,null,1],\"93\":[1],\"94\":[1],\"95\":[1,35],\"96\":[1],\"97\":[1],\"98\":[1,7],\"99\":[1,167],\"100\":[1,44],\"101\":[1,6],\"102\":[1],\"103\":[1,19],\"104\":[1,50],\"105\":[1,2],\"106\":[1,2],\"107\":[1,17],\"108\":[1,68],\"109\":[1,19],\"110\":[null,null,1],\"111\":[null,null,1],\"112\":[1],\"113\":[null,null,2],\"114\":[null,null,2],\"115\":[1,38],\"116\":[null,null,1],\"117\":[null,null,1],\"118\":[1],\"119\":[null,null,2],\"120\":[null,null,2],\"121\":[1],\"122\":[null,null,2],\"123\":[null,null,2],\"124\":[1],\"125\":[null,null,2],\"126\":[null,null,2],\"127\":[1],\"128\":[1],\"129\":[1,22],\"130\":[1,109],\"131\":[1,97],\"132\":[1,70],\"133\":[3,64],\"134\":[1,120],\"135\":[1],\"136\":[1,104],\"137\":[1,163],\"138\":[1],\"139\":[1,28],\"140\":[1,59],\"141\":[1,94],\"142\":[3,171],\"143\":[1,111],\"144\":[1],\"145\":[1],\"146\":[1],\"147\":[1],\"148\":[null,null,2],\"149\":[null,null,2],\"150\":[1],\"151\":[1],\"152\":[1],\"153\":[1],\"154\":[1],\"155\":[1],\"156\":[1],\"157\":[1],\"158\":[1],\"159\":[1],\"160\":[1],\"161\":[1],\"162\":[1],\"163\":[1],\"164\":[1],\"165\":[1],\"166\":[1],\"167\":[1],\"168\":[1],\"169\":[1],\"170\":[1],\"171\":[1],\"172\":[1],\"173\":[1],\"174\":[1],\"175\":[1],\"176\":[1],\"177\":[2],\"178\":[1],\"179\":[1],\"180\":[1],\"181\":[2],\"182\":[1],\"183\":[1],\"184\":[1],\"185\":[1],\"186\":[1],\"187\":[1],\"188\":[1],\"189\":[2],\"190\":[1],\"191\":[1],\"192\":[1],\"193\":[1],\"194\":[2],\"195\":[1],\"196\":[1],\"197\":[1],\"198\":[null,null,2],\"199\":[null,null,2],\"200\":[1],\"201\":[1,9],\"202\":[1,63],\"203\":[1,64],\"204\":[1,9],\"205\":[1],\"206\":[1],\"207\":[1],\"208\":[1],\"209\":[1],\"210\":[1,21],\"211\":[1,69],\"212\":[1,123],\"213\":[1,232],\"214\":[1,12],\"215\":[1,4],\"216\":[1,44],\"217\":[2,39],\"218\":[1,33],\"219\":[1,31],\"220\":[1,8],\"221\":[1,34],\"222\":[1,39],\"223\":[1,25],\"224\":[1,10],\"225\":[1,48],\"226\":[1,33],\"227\":[3,42],\"228\":[1],\"229\":[1],\"230\":[1],\"231\":[1],\"232\":[1],\"233\":[1],\"234\":[1],\"235\":[1],\"236\":[null,null,2],\"237\":[null,null,2],\"238\":[1],\"239\":[null,null,2],\"240\":[null,null,2],\"241\":[1],\"242\":[1,13],\"243\":[1,32],\"244\":[1,38],\"245\":[1,64],\"246\":[1],\"247\":[1],\"248\":[1],\"249\":[1],\"250\":[1],\"251\":[1],\"252\":[1],\"253\":[1],\"254\":[1],\"255\":[1],\"256\":[1],\"257\":[1],\"258\":[2],\"259\":[2],\"260\":[1],\"261\":[1],\"262\":[1],\"263\":[1],\"264\":[null,null,2],\"265\":[null,null,2],\"266\":[1,3],\"267\":[1]},\"averageFieldLength\":[1.156447183056244,33.69132174058917,1.2787589410453473],\"storedFields\":{\"0\":{\"h\":\"项目目录页\"},\"1\":{\"h\":\"标题显示在右侧\",\"t\":[\"在项目目录页面建立一个README.md就可以定义这个页面的内容\",\"跳转\",\"[目录1](./目录1/目录1.md) \",\"目录1\"]},\"2\":{\"c\":[\"目录\",\"导航\"]},\"3\":{\"c\":[\"目录\",\"导航\"]},\"4\":{\"h\":\"笔记目录页\"},\"5\":{\"h\":\"Java核心\"},\"6\":{\"h\":\"Java虚拟机\"},\"7\":{\"h\":\"企业级框架\"},\"8\":{\"h\":\"Netty\",\"t\":[\"Netty核心\",\"Netty高级\"]},\"9\":{\"h\":\"算法和数据结构\"},\"10\":{\"h\":\"数据库\"},\"11\":{\"h\":\"开发必备\"},\"12\":{\"h\":\"在线技术文档\"},\"13\":{\"c\":[\"目录\",\"导航\"]},\"14\":{\"c\":[\"目录\",\"导航\"]},\"15\":{\"h\":\"资源目录页\"},\"16\":{\"c\":[\"目录\",\"导航\"]},\"17\":{\"c\":[\"目录\",\"导航\"]},\"18\":{\"h\":\"使用README.md做左侧标题\"},\"19\":{\"h\":\"专业软件\",\"t\":[\"RuanCang：专业软件免费下载。\",\"官网：https://ruancang.net/\"]},\"20\":{\"c\":[\"系统设计\"]},\"21\":{\"c\":[\"系统设计\"]},\"22\":{\"h\":\"不实用README.md做标题\",\"t\":[\"111\"]},\"23\":{\"c\":[\"实战项目\"]},\"24\":{\"c\":[\"实战项目\"]},\"25\":{\"h\":\"算法和数据结构\"},\"26\":{\"c\":[\"目录\",\"导航\"]},\"27\":{\"c\":[\"目录\",\"导航\"]},\"28\":{\"h\":\"Java8新特性\"},\"29\":{\"h\":\"Optional类\"},\"30\":{\"h\":\"引入\",\"t\":[\"NPE问题就是在开发中经常碰到的NullPointerException，即空指针问题，Optional类就是用来优雅解决该问题的方案。\",\"比如大家可能都有这样的经历：调用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。\",\"以用户类和地址类举例说明其用法：\",\"public class User { private String userName; private String phoneNumber; private Address address; //无参、部分参数、全参数构造器方法... //setter、getter方法... } \",\"public class Address { private String province; private String city; private String area; //无参、部分参数、全参数构造器方法... //setter、getter方法... } \",\"//这行代码可能会出问题 String province = user.getAddress().getProvince(); System.out.println(province); \",\"这种代码可能会出现空指针问题，在实际开发中，如果不使用Optional类，极其不优雅的处理方式如下：\",\"//极其不优雅的处理方式 if (user != null) {//对user对象的null值判断 Address address = user.getAddress(); if (address != null) {//对address对象的null值判断 String province = address.getProvince(); if (province != null) {//对province对象的null值判断 System.out.println(province); } else { System.out.println(\\\"province==null\\\"); } } } \",\"上面的代码保证了代码的第三行、第五行、第七行肯定不会出现空指针，但是这个代码真的是非常的冗长和丑陋。\",\"java.util包下面的Optional类提供了一套API来处理一个对象是否为null值的问题。\"]},\"31\":{\"h\":\"源码解读及各API的使用\",\"t\":[\"部分源码：\",\"public final class Optional<T> { //value为null的Optinal对象，类加载的时候就已经初始化完成该Optional对象 private static final Optional<?> EMPTY = new Optional<>(); //存储需要判断null的对象 private final T value; //无参构造函数 private Optional() { this.value = null; } //有参构造函数 private Optional(T value) { this.value = Objects.requireNonNull(value); } } \",\"其本质是内部有一个泛型容器存储外部需要判断null值的对象，同时提供了两个私有的构造函数，不能被外部所调用，只能由类内部的函数调用\",\"无参数的构造函数提供一个value=null的Optional对象\",\"有参数的构造函数提供一个value一定不能为null的Optional对象，因为它调用了Objects类的requireNonNull方法。\",\"//源码 public final class Objects { public static <T> T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } } \"]},\"32\":{\"h\":\"of\",\"t\":[\"//源码 public static <T> Optional<T> of(T value) { return new Optional<>(value); } \",\"这是一个静态方法，调用有参数的构造函数，返回的是value值一定不为null的Optional对象，因为有参数的构造方法底层调用了Objects的requireNonNull方法，如果传入的value为null值，那么一定会报空指针异常。不允许value为null，实际开发中不常用。\"]},\"33\":{\"h\":\"empty\",\"t\":[\"//源码 public static<T> Optional<T> empty() { @SuppressWarnings(\\\"unchecked\\\") Optional<T> t = (Optional<T>) EMPTY; return t; } \",\"这是一个静态方法，直接将类初始化时加载的value为null的Optional对象给用户。\"]},\"34\":{\"h\":\"ofNullable\",\"t\":[\"//源码 public static <T> Optional<T> ofNullable(T value) { return value == null ? empty() : of(value); } \",\"这是一个静态方法，代表value值是可为空的。如果为null值，那么返回一个value为null的Optional对象；如果不为null值，那么返回一个value不为null的Option对象。允许value为null，实际开发中常用。\",\"与of的区别：当value值为null时，of会报NullPointerException异常；ofNullable不会throw Exception，ofNullable直接返回一个EMPTY对象（value为null的Optional对象）。\",\"那是不是意味着，我们在项目中只用ofNullable函数而不用of函数呢?\",\"不是的，一个东西存在那么自然有存在的价值。\",\"当我们在运行过程中，不想隐藏NullPointerException，而是要立即报告，这种情况下就用of函数。\",\"但是不得不承认，这样的场景真的很少。\"]},\"35\":{\"h\":\"orElse\",\"t\":[\"//源码 public T orElse(T other) { return value != null ? value : other; } \",\"这是一个实例方法，会首先判断调用它的Optional对象中的value值，如果为不为null，那么就返回该value值，如果为null，就返回传入的other对象。\",\"@Test public void orElseTest() { //1 user不为null User user1 = new User(); user1.setUserName(\\\"1\\\"); //2 user为null User user2 = null; //测试第一种 User user3 = Optional.ofNullable(user1).orElse(new User(\\\"2\\\")); System.out.println(user3.getUserName()); //测试第二种 User user4 = Optional.ofNullable(user2).orElse(new User(\\\"3\\\")); System.out.println(user4.getUserName()); } //运行结果 1 3 \"]},\"36\":{\"h\":\"orElseGet\",\"t\":[\"//源码 public T orElseGet(Supplier<? extends T> other) { return value != null ? value : other.get(); } \",\"@Test public void orElseGetTest() { //1 user不为null User user1 = new User(); user1.setUserName(\\\"1\\\"); //2 user为null User user2 = null; //测试第一种 User user3 = Optional.ofNullable(user1).orElseGet(new Supplier<User>() { @Override public User get() { return new User(\\\"2\\\"); } }); System.out.println(user3.getUserName()); //测试第二种 User user4 = Optional.ofNullable(user2).orElseGet(new Supplier<User>() { @Override public User get() { return new User(\\\"3\\\"); } }); System.out.println(user4.getUserName()); } //运行结果 1 3 \",\"该方法与orElse方法类似，只不过传入的other对象可以通过一个提供者函数式接口提供，这里可以改成lambda表达式的形式。为了方便对代码的理解，所以上面写的测试代码稍显复杂，实际开发中可以使用lambda表达式简化。\"]},\"37\":{\"h\":\"orElseThrow\",\"t\":[\"//源码 public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X { if (value != null) { return value; } else { throw exceptionSupplier.get(); } } \",\"如果value值不为null，那么直接返回，如果value值为null，可以自定义业务逻辑功能说明语句抛出异常，不影响后续代码执行。\",\"@Test public void orElseThrowTest() { //1 user不为null User user1 = new User(); user1.setUserName(\\\"1\\\"); //2 user为null User user2 = null; //测试第一种 User user3 = null; try { user3 = Optional.ofNullable(user1).orElseThrow(new Supplier<Throwable>() { @Override public Throwable get() { return new Throwable(\\\"user1为null的业务逻辑功能说明\\\"); } }); } catch (Throwable throwable) { throwable.printStackTrace(); } System.out.println(user3.getUserName()); //测试第二种 User user4 = null; try { user4 = Optional.ofNullable(user2).orElseThrow(new Supplier<Throwable>() { @Override public Throwable get() { return new Throwable(\\\"user2为null的业务逻辑功能说明\\\"); } }); } catch (Throwable throwable) { throwable.printStackTrace(); } System.out.println(\\\"不影响后续业务逻辑的执行...\\\"); } //执行结果 1 java.lang.Throwable: user2为null的业务逻辑功能说明 at com.ouc.ystong.test.TestMain$4.get(TestMain.java:82) at com.ouc.ystong.test.TestMain$4.get(TestMain.java:79) ... 不影响后续业务逻辑的执行... \"]},\"38\":{\"h\":\"map\",\"t\":[\"//源码 public<U> Optional<U> map(Function<? super T, ? extends U> mapper) { Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else { return Optional.ofNullable(mapper.apply(value)); } } \",\"如果有值，则对其执行调用mapper函数得到返回值，将创建包含mapper返回值的Optional对象作为map方法返回值，否则返回空Optional对象。\",\"@Test public void mapTest() { //1 user不为null User user1 = new User(); user1.setUserName(\\\"1\\\"); //2 user为null User user2 = null; //测试第一种 Optional<String> stringOptional1 = Optional.ofNullable(user1).map(new Function<User, String>() { @Override public String apply(User user) { return user.getUserName() + \\\"xiaotongtong\\\"; } }); System.out.println(stringOptional1); //测试第二种 Optional<String> stringOptional2 = Optional.ofNullable(user2).map(new Function<User, String>() { @Override public String apply(User user) { return user.getUserName() + \\\"xiaotongtong\\\"; } }); System.out.println(stringOptional2); } //执行结果 Optional[1xiaotongtong] Optional.empty \",\"map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。\"]},\"39\":{\"h\":\"flatMap\",\"t\":[\"//源码 public<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper) { Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else { return Objects.requireNonNull(mapper.apply(value)); } } \",\"如果有值，为其执行mapper函数返回Optional对象类型返回值，否则返回空Optional对象。flatMap与map方法类似，区别在于flatMap中的mapper返回值必须是Optional对象。调用结束时，flatMap不会对结果用Optional封装。\",\"@Test public void flatMapTest() { //1 user不为null User user1 = new User(); user1.setUserName(\\\"1\\\"); //2 user为null User user2 = null; //测试第一种 Optional<String> stringOptional1 = Optional.ofNullable(user1).flatMap(new Function<User, Optional<String>>() { @Override public Optional<String> apply(User user) { return Optional.ofNullable(user.getUserName() + \\\"xiaotongtong\\\"); } }); System.out.println(stringOptional1); //测试第二种 Optional<String> stringOptional2 = Optional.ofNullable(user2).flatMap(new Function<User, Optional<String>>() { @Override public Optional<String> apply(User user) { return Optional.ofNullable(user.getUserName() + \\\"xiaotongtong\\\"); } }); System.out.println(stringOptional2); } //执行结果 Optional[1xiaotongtong] Optional.empty \",\"flatMap方法与map方法类似，区别在于mapper函数的返回值不同。map方法的mapper函数返回值可以是任何类型T，而flatMap方法的mapper函数必须是Optional对象。\"]},\"40\":{\"h\":\"filter\",\"t\":[\"//源码 public Optional<T> filter(Predicate<? super T> predicate) { Objects.requireNonNull(predicate); if (!isPresent()) return this; else return predicate.test(value) ? this : empty(); } \",\"如果有值并且满足断言条件返回包含该值的Optional对象，否则返回空Optional对象。\",\"@Test public void filterTest() { Optional<String> stringOptional1 = Optional.of(\\\"xiaotongtong\\\").filter(new Predicate<String>() { @Override public boolean test(String s) { return s.toCharArray().length > 8; } }); //满足条件，返回包含该值的Option对象 System.out.println(stringOptional1); Optional<String> stringOptional2 = Optional.of(\\\"xiaotongtong\\\").filter(new Predicate<String>() { @Override public boolean test(String s) { return s.toCharArray().length > 15; } }); //不满足条件，返回值为空的Optional对象 System.out.println(stringOptional2); } //执行结果 Optional[xiaotongtong] Optional.empty \"]},\"41\":{\"h\":\"isPresent\",\"t\":[\"//源码 public boolean isPresent() { return value != null; } \"]},\"42\":{\"h\":\"ifPresent\",\"t\":[\"//源码 public void ifPresent(Consumer<? super T> consumer) { if (value != null) consumer.accept(value); } \"]},\"43\":{\"h\":\"get\",\"t\":[\"//源码 public T get() { if (value == null) { throw new NoSuchElementException(\\\"No value present\\\"); } return value; } \"]},\"44\":{\"h\":\"equals\",\"t\":[\"//源码 @Override public boolean equals(Object obj) { //两者指向的内存地址相同，那么Optional对象肯定相同 if (this == obj) { return true; } //如果obj不是Optional类型的，那肯定是不相同的 if (!(obj instanceof Optional)) { return false; } //已经确定是Optional类型的，所以可以强转 Optional<?> other = (Optional<?>) obj; //比较两个Optional的value值是不是相同 return Objects.equals(value, other.value); } \"]},\"45\":{\"h\":\"hashCode\",\"t\":[\"//源码 @Override public int hashCode() { return Objects.hashCode(value); } \"]},\"46\":{\"h\":\"toString\",\"t\":[\"//源码 @Override public String toString() { return value != null ? String.format(\\\"Optional[%s]\\\", value) : \\\"Optional.empty\\\"; } \"]},\"47\":{\"h\":\"使用例子\",\"t\":[\"基本使用\",\"public class OptionalDemo { public static void main(String[] args) { //创建Optional实例，也可以通过方法返回值得到。 Optional<String> name = Optional.of(\\\"Sanaulla\\\"); //创建没有值的Optional实例，例如值为'null' Optional empty = Optional.ofNullable(null); //isPresent方法用来检查Optional实例是否有值。 if (name.isPresent()) { //调用get()返回Optional值。 System.out.println(name.get()); } try { //在Optional实例上调用get()抛出NoSuchElementException。 System.out.println(empty.get()); } catch (NoSuchElementException ex) { System.out.println(ex.getMessage()); } //ifPresent方法接受lambda表达式参数。 //如果Optional值不为空，lambda表达式会处理并在其上执行操作。 name.ifPresent((value) -> { System.out.println(\\\"The length of the value is: \\\" + value.length()); }); //如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。 System.out.println(empty.orElse(\\\"There is no value present!\\\")); System.out.println(name.orElse(\\\"There is some value!\\\")); //orElseGet与orElse类似，区别在于传入的默认值。 //orElseGet接受lambda表达式生成默认值。 System.out.println(empty.orElseGet(() -> \\\"Default Value\\\")); System.out.println(name.orElseGet(() -> \\\"Default Value\\\")); try { //orElseThrow与orElse方法类似，区别在于返回值。 //orElseThrow抛出由传入的lambda表达式/方法生成异常。 empty.orElseThrow(ValueAbsentException::new); } catch (Throwable ex) { System.out.println(ex.getMessage()); } //map方法通过传入的lambda表达式修改Optonal实例默认值。 //lambda表达式返回值会包装为Optional实例。 Optional<String> upperName = name.map((value) -> value.toUpperCase()); System.out.println(upperName.orElse(\\\"No value found\\\")); //flatMap与map(Funtion)非常相似，区别在于lambda表达式的返回值。 //map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。 //但是flatMap方法的lambda返回值总是Optional类型。 upperName = name.flatMap((value) -> Optional.of(value.toUpperCase())); System.out.println(upperName.orElse(\\\"No value found\\\")); //filter方法检查Optiona值是否满足给定条件。 //如果满足返回Optional实例值，否则返回空Optional。 Optional<String> longName = name.filter((value) -> value.length() > 6); System.out.println(longName.orElse(\\\"The name is less than 6 characters\\\")); //另一个示例，Optional值不满足给定条件。 Optional<String> anotherName = Optional.of(\\\"Sana\\\"); Optional<String> shortName = anotherName.filter((value) -> value.length() > 6); System.out.println(shortName.orElse(\\\"The name is less than 6 characters\\\")); } } \",\"运行结果：\",\"Sanaulla No value present The length of the value is: 8 There is no value present! Sanaulla Default Value Sanaulla No value present in the Optional instance SANAULLA SANAULLA Sanaulla The name is less than 6 characters \",\"在Java8中提高对象的null值安全性\",\"假设有如下的类层次结构：\",\"class Outer { Nested nested; Nested getNested() { return nested; } } class Nested { Inner inner; Inner getInner() { return inner; } } class Inner { String foo; String getFoo() { return foo; } } \",\"解决这种结构的深层嵌套路径是有点麻烦的，我们必须编写一堆null检查来确保不会导致一个 NullPointerException。\",\"我们可以通过利用Optional类型来摆脱所有这些null检查。map方法接收一个Function类型的lambda表达式，并自动将每个function的结果包装成一个Optional对象，这使我们能够在一行中进行多个 map 操作。\",\"Optional.of(new Outer()) .map(Outer::getNested) .map(Nested::getInner) .map(Inner::getFoo) .ifPresent(System.out::println); \"]},\"48\":{\"h\":\"使用总结\",\"t\":[\"使用Optional工具类判断一个对象的NPE问题，一定要先通过其静态方法（of、empty、ofNullable）获得Optional对象，进而通过一些实例方法进行一系列的操作获得最后的对象。\",\"API方法名称\",\"用处\",\"of\",\"为非null的值创建一个Optional对象。\",\"empty\",\"为null的值创建一个Optional对象。\",\"ofNullable\",\"为指定的值创建一个Optional对象，如果指定的值为null，则返回一个空的Optional对象。\",\"isPresent\",\"如果值不为null，则返回true，否则返回false。\",\"get\",\"如果Optional对象的值并不为空则将其返回，否则抛出NoSuchElementException。\",\"ifPresent\",\"如果Optional对象有值（不为空）则为其调用Consumer，否则不做处理\",\"orElse\",\"如果有值则将其返回，否则返回指定的其它值。\",\"orElseGet\",\"orElseGet方法可以接受Supplier接口的实现用来生成默认值。\",\"orElseThrow\",\"如果有值则将其返回，否则抛出Supplier接口创建的异常。\",\"map\",\"如果有值，则对其执行调用mapper函数得到返回值，并且将创建包含mapper返回值的Optional对象作为map方法返回值，否则返回空Optional对象。\",\"flatMap\",\"如果有值，为其执行mapper函数返回Optional类型返回值，否则返回空Optional对象。flatMap与map方法类似，区别在于flatMap中的mapper返回值必须是Optional对象。调用结束时，flatMap不会对结果用Optional封装。\",\"filter\",\"如果有值并且满足断言条件返回包含该值的Optional对象，否则返回空Optional对象。\"]},\"49\":{\"c\":[\"Java\"]},\"50\":{\"c\":[\"Java\"]},\"51\":{\"h\":\"Java反射机制\"},\"52\":{\"c\":[\"Java\"]},\"53\":{\"c\":[\"Java\"]},\"54\":{\"h\":\"Java异常机制\"},\"55\":{\"c\":[\"Java\"]},\"56\":{\"c\":[\"Java\"]},\"57\":{\"h\":\"Java泛型机制\"},\"58\":{\"h\":\"前言\",\"t\":[\"Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。\"]},\"59\":{\"h\":\"为什么会引入泛型\",\"t\":[\"泛型的本质是为了参数化类型，也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\",\"适用于多种数据类型执行相同的代码（代码复用）\",\"private static int add(int a, int b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a + b)); return a + b; } private static float add(float a, float b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a + b)); return a + b; } private static double add(double a, double b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a + b)); return a + b; } \",\"如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：\",\"// 泛型方法 private static <T extends Number> double add(T a, T b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue(); } \",\"重载和重写的区别：\",\"重写其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型都相同的情况下， 对方法体进行修改或重写。【子父类中多态性的表现】\",\"public class Father { public static void main(String[] args) { // 1、创建一个子类对象，使用子类对象接收 Son s1 = new Son(); s1.sayHello();// Son: sayHello! // 2、创建一个子类对象，使用父类对象接收(多态机制) Father s2 = new Son(); s2.sayHello();// Son: sayHello! // 3、新建一个父类对象，使用父类对象接收 Father f1 = new Father(); f1.sayHello();// Father: sayHello! // 3、新建一个父类对象，使用子类对象接收 // Son f2 = new Father();// 直接报错 可以说老虎是动物，但不能说动物是老虎 // f2.sayHello(); } public void sayHello() { System.out.println(\\\"Father: sayHello!\\\"); } } class Son extends Father { // IDEA快捷键 ctrl+o @Override public void sayHello() { // 重写 System.out.println(\\\"Son: sayHello!\\\"); // 如果想要执行父类的sayHello方法，可以直接调用super.sayHello(); } } // 方法名，参数列表，返回类型（除了子类中方法的返回类型是父类中返回类型的子类）必须相同 // 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private) // 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常 \",\"在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。【一个类中多态性的表现】\",\"public class Father { public static void main(String[] args) { Father father = new Father(); father.sayHello(); father.sayHello(\\\"xiaotong\\\"); } public void sayHello() { System.out.println(\\\"Father: sayHello!\\\"); } // 重载：满足一个类中，方法名相同且参数不同（个数、顺序、类型） public String sayHello(String name) { System.out.println(\\\"Father: sayHello!\\\" + name); return name; } } \",\"参考：https://blog.csdn.net/wintershii/article/details/80558739\",\"泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）\",\"// ArrayList有泛型机制，但是使用的时候没有指定 List list = new ArrayList(); list.add(\\\"xxString\\\"); list.add(100d); list.add(new Person()); \",\"我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。\",\"引入泛型，它将提供类型的约束，提供编译前的检查：\",\"List<String> list = new ArrayList<String>(); // list中只能放String, 不能放其它类型的元素 \"]},\"60\":{\"c\":[\"Java\"]},\"61\":{\"c\":[\"Java\"]},\"62\":{\"h\":\"Java注解机制\"},\"63\":{\"c\":[\"Java\"]},\"64\":{\"c\":[\"Java\"]},\"65\":{\"h\":\"面向对象\"},\"66\":{\"h\":\"三大特性\"},\"67\":{\"c\":[\"Java\"]},\"68\":{\"c\":[\"Java\"]},\"69\":{\"h\":\"ArrayList\"},\"70\":{\"h\":\"概述\",\"t\":[\"ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。\",\"size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。\",\"为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。\"]},\"71\":{\"h\":\"ArrayList的实现\"},\"72\":{\"h\":\"底层数据结构\",\"t\":[\"// 底层维护的数据结构 transient Object[] elementData; // non-private to simplify nested class access // size维护了数组中元素的数量，不同于数组的长度elementData.length=capacity private int size; \",\"底层数据结构就是Object类型的数组，这样可以放置任何类型的对象，因为所有的对象都继承了Obejct。\"]},\"73\":{\"h\":\"构造函数\",\"t\":[\"// 默认的初始容量 private static final int DEFAULT_CAPACITY = 10; // 空elementData private static final Object[] EMPTY_ELEMENTDATA = {}; // 默认容量（10）的elementData private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 构造函数1 public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\\\"Illegal Capacity: \\\"+ initialCapacity); } } // 构造函数2 public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } // 构造函数3 public ArrayList(Collection<? extends E> c) { Object[] a = c.toArray(); if ((size = a.length) != 0) { if (c.getClass() == ArrayList.class) { elementData = a; } else { elementData = Arrays.copyOf(a, size, Object[].class); } } else { // replace with empty array. elementData = EMPTY_ELEMENTDATA; } } \",\"构造函数1：给定initialCapacity，判断该值的合法性必须是大于等于0，如果大于0，就创建一个长度为initialCapacity的Object数组；如果等于0，就会把一个空数组给elementData。\",\"构造函数2：不给定initialCapacity，就会给一个默认容量（后面会用到这个默认容量）的空数组，注意此时的elementData还是空数组，还没有实际分配默认容量长度的数组，在add元素的时候会修正默认容量（10）。\"]},\"74\":{\"h\":\"两个常用数组拷贝方法\",\"t\":[\"// Arrays类中的静态方法 // 参数说明 // @param original the array to be copied // @param newLength the length of the copy to be returned public static <T> T[] copyOf(T[] original, int newLength) { // 调用更加通用的copyOf方法 return (T[]) copyOf(original, newLength, original.getClass()); } public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) { @SuppressWarnings(\\\"unchecked\\\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); // 底层的数组拷贝，是一个native方法，速度快 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } \",\"// System类中的静态本地方法 // 参数说明 // @param src the source array. // @param srcPos starting position in the source array. // @param dest the destination array. // @param destPos starting position in the destination data. // @param length the number of array elements to be copied. public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); \"]},\"75\":{\"h\":\"自动扩容\",\"t\":[\"每当向数组中添加元素时，都要去检查添加后元素的个数（size+1）是否会超出当前数组的长度（elementData.length），如果超出，数组将会进行扩容，以满足添加数据的需求。\",\"数组扩容通过一个公开（public）的方法ensureCapacity(int minCapacity)来实现，在实际添加大量元素前，也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。\",\"数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。\",\"// 注意这是一个公开的自动扩容方法（保证容量），保证最小容量minCapacity public void ensureCapacity(int minCapacity) { int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity > minExpand) { ensureExplicitCapacity(minCapacity); } } // 重新修正一下添加元素的时候应该保证的最小的容量minCapacity private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } // add添加元素的时候会首先进入该方法，保证有minCapacity的容量 private void ensureCapacityInternal(int minCapacity) { // 修正应该保证的最小容量：calculateCapacity(elementData, minCapacity) ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } // 显示的进行扩容操作-保证minCapacity的容量 private void ensureExplicitCapacity(int minCapacity) { // elementData的修改次数+1，无论是否需要扩容 modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0)// 需要扩容 // 真正在做扩容的是grow grow(minCapacity); } // 数组扩容的最大长度限制 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 真正在做扩容的方法 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1);// 新数组的长度是旧数组的1.5倍 if (newCapacity - minCapacity < 0) newCapacity = minCapacity;// 扩容1.5倍之后，新数组的长度有可能还是无法满足minCapacity，此时要保证新数组的长度最低也要和minCapacity相等。 if (newCapacity - MAX_ARRAY_SIZE > 0)// 新数组的长度如果超过了限制MAX_ARRAY_SIZE newCapacity = hugeCapacity(minCapacity);// 保证newCapacity不会超出最大限制Integer.MAX_VALUE elementData = Arrays.copyOf(elementData, newCapacity);// https://www.cnblogs.com/lzh-csust-code/p/14840194.html // Arrays.copyOf方法返回的是一个新的数组，与原来的数组不同，并不是在原来的数组上面增大length // 第一个参数是被拷贝的数组 // 第二个参数是拷贝之后返回的新数组的长度（创建了新数组，即在此过程进行new Obejct[newCapacity]） } // 分配新数组的最大容量（minCapacity如果超过了MAX_ARRAY_SIZE，最大容量就是Integer.MAX_VALUE，没有超过最大容量就是MAX_ARRAY_SIZE） private static int hugeCapacity(int minCapacity) { if (minCapacity < 0) // overflow throw new OutOfMemoryError(); return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } \"]},\"76\":{\"h\":\"add()-addAll()\",\"t\":[\"跟C++的vector不同，ArrayList没有push_back()方法，对应的方法是add(E e)，ArrayList也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。\",\"public boolean add(E e) { // 保证size + 1的容量 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! // 数组的拷贝-使用的是更加底层（native）的数组拷贝方法，效率比较高 // 自动扩容1.5倍的底层也是用的这个数组方法 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 添加元素到index位置 elementData[index] = element; // 元素个数增加 size++; } \",\"add(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。\",\"addAll()方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的addAll(Collection<? extends E> c)方法，一个是从指定位置开始插入的addAll(int index, Collection<? extends E> c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。\",\"// 在列表末尾一次性添加多个元素 public boolean addAll(Collection<? extends E> c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } // 在指定index位置一次性添加多个元素 public boolean addAll(int index, Collection<? extends E> c) { rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved > 0) // 移动元素 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 在指定元素赋值 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } \",\"关于modCount：\",\"在ArrayList中有个成员变量modCount，继承于AbstractList。\",\"记录着集合的修改次数，也就每次add或者remove它的值都会加1。\",\"@Test public void testArrayList() { List<String> list = new ArrayList<String>(); list.add(\\\"a\\\"); Iterator iterator = list.iterator(); while (iterator.hasNext()) { String str = (String) iterator.next(); list.remove(str); } // java.util.ConcurrentModificationException } \",\"在使用迭代器遍历集合的时候同时修改集合元素。因为ArrayList被设计成非同步的，所以理所当然会抛异常。但是该抛什么异常才能说明该问题呢？答案是：java.util.ConcurrentModificationException，即并发修改异常，也就是说有一个线程在读数据，现在还有另一个线程在修改数据，但是ArrayList不是线程安全的，所以这样做会很危险，就会直接报异常。\",\"首先得了解ArrayList的迭代器\",\"// 获取ArrayList的迭代器 public Iterator<E> iterator() { return new Itr(); } // 在调用list.iterator()的时候返回的是一个Itr对象，它是ArrayList中的一个内部类。 private class Itr implements Iterator<E> { int cursor; // index of next element to return 默认值为0 int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor != size; } @SuppressWarnings(\\\"unchecked\\\") public E next() { checkForComodification(); int i = cursor; if (i >= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } public void remove() { if (lastRet < 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } @Override @SuppressWarnings(\\\"unchecked\\\") public void forEachRemaining(Consumer<? super E> consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i >= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) { throw new ConcurrentModificationException(); } while (i != size && modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } \",\"主要关注3个点：\",\"1、expectedModCount的初值为modCount\",\"2、hasNext的判断条件为cursor!=size，就是当前迭代的位置不是数组的最大容量值就返回true\",\"3、next和remove操作之前都会先调用checkForComodification来检查expectedModCount和modCount是否相等\",\"分析原因：add操作之后，modCount的值为1，通过iterator方法获得迭代器之后，expectedModCount的值就是1，第一次cursor的值为0，并不等于size=1，所以hasNext为true，此时next方法会通过checkForComodification进行检查，发现是正常的，会继续向下走，将cursor的值执行++操作，此时cursor的值为1。当执行到remove方法，将modCount的值变为2，size的值变为0，此时执行到hasNext方法，发现cursor的值为1，并不等于size的值为0，所以还是true，会继续向下走，此时执行next方法的时候，再次通过checkForComodification进行检查，发现expectedModCount的值为1，但是modCount的值已经变为了2，两者不相等，所以就直接报出并发修改异常了。\",\"参考：https://www.cnblogs.com/zuochengsi-9/p/7050351.html\"]},\"77\":{\"h\":\"set()\",\"t\":[\"既然底层是一个数组ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。\",\"public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; } \"]},\"78\":{\"h\":\"get()\",\"t\":[\"get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。\",\"public E get(int index) { rangeCheck(index); return elementData(index); } \"]},\"79\":{\"h\":\"remove()-removeAll()-retainAll()\",\"t\":[\"remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值，那么在最后一个位置的元素没有引用就会被GC回收掉。\",\"// 删除指定位置的元素 public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } // 删除第一个满足条件o.equals(elementData[index])的元素 public boolean remove(Object o) { if (o == null) { for (int index = 0; index < size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index < size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } // Removes from this list all of its elements that are contained in the specified collection. public boolean removeAll(Collection<?> c) { Objects.requireNonNull(c); return batchRemove(c, false); } // Retains only the elements in this list that are contained in the specified collection. In other words, removes from this list all of its elements that are not contained in the specified collection. // retain：保留 public boolean retainAll(Collection<?> c) { Objects.requireNonNull(c); return batchRemove(c, true); } // 私有方法-批量删除 private boolean batchRemove(Collection<?> c, boolean complement) { final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try { for (; r < size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; } finally { // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) { System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; } if (w != size) { // clear to let GC do its work for (int i = w; i < size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; } } return modified; } \",\"关于Java GC这里需要特别说明一下，对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。\"]},\"80\":{\"h\":\"size()\",\"t\":[\"// 返回元素的个数，注意并不是底层数组的长度，而是数组中有效数据的个数 public int size() { return size; } \"]},\"81\":{\"h\":\"isEmpty()\",\"t\":[\"// 列表是否为空 public boolean isEmpty() { return size == 0; } \"]},\"82\":{\"h\":\"contains()\",\"t\":[\"// 调用了indexof方法 public boolean contains(Object o) { // 元素第一次出现的index return indexOf(o) >= 0; } \"]},\"83\":{\"h\":\"toArray()\",\"t\":[\"// 转成数组 public Object[] toArray() { // 底层用的就是数组，所以只要将elementData的数据拷贝出来即可 return Arrays.copyOf(elementData, size); } // 转成数组并且将其拷贝到数组a中 public <T> T[] toArray(T[] a) { if (a.length < size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length > size) a[size] = null; return a; } \"]},\"84\":{\"h\":\"clear()\",\"t\":[\"// 有效元素清空 public void clear() { modCount++; // clear to let GC do its work for (int i = 0; i < size; i++) elementData[i] = null; size = 0; } \"]},\"85\":{\"h\":\"subList()\",\"t\":[\"// 截取一段成为子List public List<E> subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); } \"]},\"86\":{\"h\":\"trimToSize()\",\"t\":[\"ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能，它可以通过trimToSize方法来实现。代码如下:\",\"public void trimToSize() { modCount++; if (size < elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } } \"]},\"87\":{\"h\":\"indexOf()-lastIndexOf()\",\"t\":[\"获取元素的第一次出现的index：\",\"public int indexOf(Object o) { if (o == null) { for (int i = 0; i < size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i < size; i++) if (o.equals(elementData[i])) return i; } return -1; } \",\"获取元素的最后一次出现的index：\",\"public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i >= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i >= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } \"]},\"88\":{\"h\":\"forEach()-removeIf()-replaceAll()-sort()\",\"t\":[\"// 如何使用？ // 声明：public void forEach(Consumer<? super E> action) // 声明：public boolean removeIf(Predicate<? super E> filter) // 声明：public void replaceAll(UnaryOperator<E> operator) // 声明：public void sort(Comparator<? super E> c) // Consumer、Predicate、UnaryOperator、Comparator都是函数式接口，都可以使用lambda表达式优化代码的书写 public static void main(String[] args) { ArrayList<String> list = new ArrayList<>(); list.add(\\\"a\\\"); list.add(\\\"bb\\\"); list.add(\\\"ccc\\\"); list.add(\\\"dddd\\\"); // 1、forEach的使用 list.forEach(new Consumer<String>() { @Override public void accept(String s) { System.out.print(s + \\\"测试 \\\"); } });// a测试 bb测试 ccc测试 dddd测试 System.out.println(); // 2、removeIf的使用 list.removeIf(new Predicate<String>() { @Override public boolean test(String s) { return s == \\\"a\\\"; } }); System.out.println(list);// [bb, ccc, dddd] // 3、replaceAll的使用 list.replaceAll(new UnaryOperator<String>() { @Override public String apply(String s) { return \\\"测试\\\" + s; } }); System.out.println(list);// [测试bb, 测试ccc, 测试dddd] // 4、sort的使用 list.sort(new Comparator<String>() { @Override public int compare(String o1, String o2) { return o2.length() - o1.length(); } }); System.out.println(list);// [测试dddd, 测试ccc, 测试bb] } \"]},\"89\":{\"h\":\"Fail-Fast机制\",\"t\":[\"ArrayList也采用了快速失败的机制，通过记录modCount参数来实现，在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。\"]},\"90\":{\"h\":\"参考\",\"t\":[\"https://www.cnblogs.com/zuochengsi-9/p/7050351.html\",\"https://www.pdai.tech/md/java/collection/java-collection-ArrayList.html\",\"https://www.cnblogs.com/lzh-csust-code/p/14840194.html\",\"https://blog.csdn.net/u012926924/article/details/50452411\",\"https://www.cnblogs.com/ccgjava/p/6347425.html\"]},\"91\":{\"c\":[\"Java\"]},\"92\":{\"c\":[\"Java\"]},\"93\":{\"h\":\"集合类关系图\"},\"94\":{\"h\":\"类关系图\"},\"95\":{\"h\":\"简单介绍\",\"t\":[\"容器就是可以容纳其他Java对象的对象。Java Collections Framework(JCF)为Java开发者提供了通用的容器，其始于JDK 1.2。\",\"Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。\",\"容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。\"]},\"96\":{\"h\":\"Collection\"},\"97\":{\"h\":\"如何学习\"},\"98\":{\"h\":\"如何遍历\",\"t\":[\"遍历操作是集合最基本的操作，顶层的Collection接口提供一个通用高级的遍历方式：迭代器。\",\"Collection顶层接口负责定义获得迭代器的方法，底层的数据结构负责实现自己的迭代器，迭代器的工作原理如下图所示：\"]},\"99\":{\"h\":\"Set\",\"t\":[\"TreeSet【无序集合】\",\"基于红黑树实现，支持有序性操作，但是无序集合。其查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。\",\"TreeSet支持有序性操作的理解：https://blog.csdn.net/qq_36437446/article/details/80089609\",\"HashSet【无序集合】\",\"基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的，即是一个无序集合。\",\"HashSet不支持有序性操作的理解：https://blog.csdn.net/qq_43541242/article/details/108013680\",\"LinkedHashSet【有序集合】\",\"具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。\",\"TreeSet和HashSet都是属于无序的集合，而LinkedHashSet是属于有序的集合，就是说对于TreeSet和HashSet，存储和取出元素的顺序有可能不一致，但是对于LinkedHashSet，其存储和取出元素的顺序是一致的。\",\"public class Main { public static void main(String[] args) { TreeSet<Integer> integers = new TreeSet<>(); integers.add(3); integers.add(4); integers.add(1); integers.add(2); Iterator<Integer> iterator = integers.iterator(); while (iterator.hasNext()) { System.out.print(iterator.next() + \\\" \\\"); } // 1 2 3 4 System.out.println(); HashSet<Integer> set = new HashSet<>(); set.add(5); set.add(6); set.add(1); set.add(2); set.add(8); Iterator<Integer> iterator1 = set.iterator(); while (iterator1.hasNext()) { System.out.print(iterator1.next() + \\\" \\\"); } // 1 2 5 6 8 System.out.println(); HashSet<Integer> set1 = new LinkedHashSet<>(); set1.add(5); set1.add(6); set1.add(1); set1.add(2); set1.add(8); Iterator<Integer> iterator2 = set1.iterator(); while (iterator2.hasNext()) { System.out.print(iterator2.next() + \\\" \\\"); } // 5 6 1 2 8 } } \",\"TreeSet支持有序性操作（可以使其有序），而HashSet不支持有序性操作（不能使其有序）的意思是说对存储进集合的元素是否会自动排序或者按照我们自定义的方式进行排序（是否能使其有序），最后取出的元素又是否有序（按照自动排序的方式或者我们自定义的方式）。对于有序性操作具体可以看两者的构造函数，TreeSet的构造函数有一个含有Comparator参数，而HashSet是没有的，也就是说HashSet不会对存储的元素进行排序，输出的结果不保证有序，如果有序，那也是凑巧。\",\"// TreeSet构造函数 public TreeSet(Comparator<? super E> comparator) { this(new TreeMap<>(comparator)); } \",\"// TreeSet使其有序性操作（在插入的时候就使其按照我们自定义排序的方式存储） public class Main { public static void main(String[] args) { TreeSet<Student> students = new TreeSet<>(new Comparator<Student>() { @Override public int compare(Student o1, Student o2) { // 先按年龄进行升序，年龄相同的按照学号降序 int i = o1.getAge() - o2.getAge(); if (i == 0) {// 年龄相等 return o2.getIdNumber() - o1.getIdNumber(); } return i; } }); students.add(new Student(2, 3)); students.add(new Student(3, 3)); students.add(new Student(4, 3)); students.add(new Student(6, 5)); students.add(new Student(1, 2)); students.add(new Student(5, 4)); Iterator<Student> iterator = students.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } } @NoArgsConstructor @AllArgsConstructor @ToString @Getter @Setter class Student { private int idNumber; private int age; } // 对于Comparator接口的使用总结： // 1、jdk官方默认是升序 // 2、a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. // 3、总结：升序就是第一个减去第二个，降序就是第二个减去第一个 \",\"总结一下（区别无序集合、有序集合、有序操作三者的区别很重要）：\",\"1、TreeSet：是无序集合，但是支持有序操作（使其有序）\",\"2、HashSet：是无序集合，也不支持有序操作（查找效率高）\",\"3、LinkedHashSet：是有序集合（是不是支持有序操作已没有意义）\"]},\"100\":{\"h\":\"List\",\"t\":[\"ArrayList\",\"基于动态数组实现，支持随机访问，可以很快的根据下标查找元素。\",\"Vector\",\"和 ArrayList 类似，但它是线程安全的。\",\"LinkedList\",\"基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。\",\"ArrayList与LinkedList的区别：\",\"ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。\",\"对于随机访问，ArrayList优于LinkedList，ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问。而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。\",\"ArrayList与LinkedList在API层面都可以通过index获取，但是底层一个是随机访问，一个是顺序访问。\",\"对于插入和删除操作，LinkedList优于ArrayList，因为当元素被添加到LinkedList任意位置的时候，不需要像ArrayList那样重新计算大小或者是更新索引。\",\"LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。\",\"业务中如果想要快速的进行插入和删除，就用LinkedList，如果想快速获取元素或者降低空间消耗，就使用ArrayList。\"]},\"101\":{\"h\":\"Queue\",\"t\":[\"LinkedList\",\"可以用它来实现双向队列。\",\"PriorityQueue\",\"基于堆结构实现，可以用它来实现优先队列。\"]},\"102\":{\"h\":\"Map\"},\"103\":{\"h\":\"如何学习\",\"t\":[\"Map的键是唯一的，值可以重复。\",\"学习Map顶层接口，注意顶层接口中还定义了一个内部的接口Entry，这代表的是一个键值对，源码中对其解释：A map entry (key-value pair)。\",\"Map顶层接口中定义了一个方法可以获取键值对的集合，其方法声明：Set<Map.Entry<K, V>> entrySet()。\"]},\"104\":{\"h\":\"如何遍历\",\"t\":[\"通过KeySet集合遍历\",\"通过EntrySet集合遍历\",\"代码演示\",\"// Map遍历的两种方式 public class Main { public static void main(String[] args) { Map<Integer, String> map = new HashMap<>(); map.put(1, \\\"2\\\"); map.put(2, \\\"2\\\"); map.put(3, \\\"2\\\"); map.put(4, \\\"2\\\"); // 1、通过EntrySet集合遍历 Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator(); while (iterator.hasNext()) { // 打印键值对 Map.Entry<Integer, String> next = iterator.next(); System.out.println(\\\"键：\\\" + next.getKey() + \\\" 值：\\\" + next.getValue()); } System.out.println(\\\"=======\\\"); // 2、通过KeySet集合遍历（forEach、增强for循环、迭代器都可以实现） map.keySet().forEach((item) -> { System.out.println(\\\"键：\\\" + item + \\\" 值：\\\" + map.get(item)); }); } } \"]},\"105\":{\"h\":\"TreeMap\",\"t\":[\"基于红黑树实现。\"]},\"106\":{\"h\":\"HashMap\",\"t\":[\"基于哈希表实现。\"]},\"107\":{\"h\":\"HashTable\",\"t\":[\"和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。\"]},\"108\":{\"h\":\"LinkedHashMap\",\"t\":[\"使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。\",\"深入理解HashMap和TreeMap的区别：\",\"两者都是无序Map，就是说存储的顺序和读取的顺序有可能不一致。\",\"排序的区别：从类的定义来看，HashMap和TreeMap都继承自AbstractMap，不同的是HashMap实现的是Map接口，而TreeMap实现的是NavigableMap接口。NavigableMap是SortedMap的一种，实现了对Map中key的排序。所以TreeMap是排序的而HashMap不是。\",\"null值的区别：HashMap可以允许一个null key和多个null value。而TreeMap不允许null key，但是可以允许多个null value。\",\"两者都不允许duplicate key,两者都不是线程安全的。\",\"@Test public void testMap() { // 1、HashMap是无序Map HashMap<String, String> map = new HashMap<>(); map.put(\\\"3\\\", \\\"3\\\"); map.put(\\\"4\\\", \\\"4\\\"); map.put(\\\"1\\\", \\\"1\\\"); map.put(\\\"2\\\", \\\"2\\\"); map.keySet().forEach(s -> System.out.print(\\\"键：\\\" + s + \\\" 值：\\\" + map.get(s) + \\\" | \\\")); // 键：1 值：1 | 键：2 值：2 | 键：3 值：3 | 键：4 值：4 | System.out.println(); // 2、TreeMap是无序Map TreeMap<String, String> treeMap = new TreeMap<>(); treeMap.put(\\\"3\\\", \\\"3\\\"); treeMap.put(\\\"4\\\", \\\"4\\\"); treeMap.put(\\\"1\\\", \\\"1\\\"); treeMap.put(\\\"2\\\", \\\"2\\\"); treeMap.keySet().forEach(s -> System.out.print(\\\"键：\\\" + s + \\\" 值：\\\" + map.get(s) + \\\" | \\\")); // 键：1 值：1 | 键：2 值：2 | 键：3 值：3 | 键：4 值：4 | System.out.println(); // 3、LinkedHashMap是有序Map LinkedHashMap<String, String> linkedHashMap = new LinkedHashMap<>(); linkedHashMap.put(\\\"3\\\", \\\"3\\\"); linkedHashMap.put(\\\"4\\\", \\\"4\\\"); linkedHashMap.put(\\\"1\\\", \\\"1\\\"); linkedHashMap.put(\\\"2\\\", \\\"2\\\"); linkedHashMap.keySet().forEach(s -> System.out.print(\\\"键：\\\" + s + \\\" 值：\\\" + map.get(s) + \\\" | \\\")); // 键：3 值：3 | 键：4 值：4 | 键：1 值：1 | 键：2 值：2 | System.out.println(); // 4、TreeMap使其有序 TreeMap<String, String> linkedTreeMap = new TreeMap<>((o1, o2) -> Integer.parseInt(o2) - Integer.parseInt(o1)); linkedTreeMap.put(\\\"3\\\", \\\"3\\\"); linkedTreeMap.put(\\\"4\\\", \\\"4\\\"); linkedTreeMap.put(\\\"1\\\", \\\"1\\\"); linkedTreeMap.put(\\\"2\\\", \\\"2\\\"); linkedTreeMap.keySet().forEach(s -> System.out.print(\\\"键：\\\" + s + \\\" 值：\\\" + map.get(s) + \\\" | \\\")); // 键：4 值：4 | 键：3 值：3 | 键：2 值：2 | 键：1 值：1 | } \"]},\"109\":{\"h\":\"参考\",\"t\":[\"https://www.pdai.tech/md/java/collection/java-collection-all.html\",\"https://zhuanlan.zhihu.com/p/33141246\",\"https://www.cnblogs.com/flydean/p/hashmap-vs-treemap.html\"]},\"110\":{\"c\":[\"Java\"]},\"111\":{\"c\":[\"Java\"]},\"112\":{\"h\":\"Java核心\"},\"113\":{\"c\":[\"目录\",\"导航\"]},\"114\":{\"c\":[\"目录\",\"导航\"]},\"115\":{\"h\":\"书籍资源\",\"t\":[\"资源名称\",\"分享链接\",\"《Labuladong的算法小抄》\",\"https://www.aliyundrive.com/s/8ouAjxFVgUX\",\"《小傅哥的IDEA插件开发手册》\",\"https://www.aliyundrive.com/s/Pq7xVp9bXdR\",\"《疯狂Java讲义第四版》\",\"https://www.aliyundrive.com/s/Yd2L8XtGWUa\",\"《Java核心技术-卷1-基础知识》\",\"https://www.aliyundrive.com/s/EvpXjq55LXn\",\"《Java核心技术-卷2-高级特性》\",\"https://www.aliyundrive.com/s/hT5RQDe6q1k\",\"《Linux命令速查手册》\",\"https://www.aliyundrive.com/s/ophXiMFVPrB\",\"《鸟哥的Linux私房菜-高清》\",\"https://www.aliyundrive.com/s/bd9PeqCf82N\",\"《鸟哥的Linux私房菜-非高清》\",\"https://www.aliyundrive.com/s/e9ag9zBwTCS\",\"《数学建模算法与应用-第二版-司守奎》\",\"https://www.aliyundrive.com/s/uDtSpLzFqz2\",\"《统计学习方法-李航》\",\"https://www.aliyundrive.com/s/Gae5A3tJaZn\",\"《Matlab神经网络30个案例分析》\",\"https://www.aliyundrive.com/s/EVibkTrcFex\",\"《具有AI功能加持的终端工具warp使用总结》\",\"https://www.aliyundrive.com/s/kXKqP4RqyUD\"]},\"116\":{\"c\":[\"书籍\"]},\"117\":{\"c\":[\"书籍\"]},\"118\":{\"h\":\"影音资源\"},\"119\":{\"c\":[\"影视\",\"音乐\"]},\"120\":{\"c\":[\"影视\",\"音乐\"]},\"121\":{\"h\":\"算法小抄\"},\"122\":{\"c\":[\"目录\",\"导航\"]},\"123\":{\"c\":[\"目录\",\"导航\"]},\"124\":{\"h\":\"动态规划\"},\"125\":{\"c\":[\"算法\",\"数据结构\"]},\"126\":{\"c\":[\"算法\",\"数据结构\"]},\"127\":{\"h\":\"数学运算\"},\"128\":{\"h\":\"常用的位操作\"},\"129\":{\"h\":\"Java中的位操作符\",\"t\":[\"注意\",\"Java中位操作符的操作数只能是整型（byte、short、int、long）和字符型数据（char）。\",\"Java中位操作符一共有7个，其中4个是位逻辑运算符，3个是移位运算符。\",\"使用按位操作符时要注意：相等（==）与不相等（!=）的优先级在按位操作符之上！这意味着，位运算符的优先级极小，所以使用位运算符时，最好加上括号。\"]},\"130\":{\"h\":\"4个位逻辑运算符\",\"t\":[\"位逻辑运算符包括按位取反（~）、按位与（&）、按位或（|）和按位异或（^）4种。 \",\"与操作符 “&”，如果两个输入位都是 1，那么输出位是 1，否则输入位是 0。【对应位全都为1，则为1】\",\"或操作符 “|” ，如果两个输入位有一个是 1，那么输出位是 1，只有两个输入位都是 0，输出位才是 0。【对应位含有1，则为1】\",\"异或运算符 “^”，如果两个输入位都为 1 或者都为 0，那么输出位是 0，否则输出位是 1。【对应位相同，则为0，反之为1】\",\"非运算符 “~”，这个一元操作符，只能对一个数操作，规则是输出位与输入位相反。【一元操作符，输入1，则输出0；输入0，则输出1】\",\"@Test public void test() { //转化为二进制：0101 int num1 = 5; //转化为二进制：1001 int num2 = 9; //与运算，二进制结果为 0001，打印结果为 1 System.out.println(num1 & num2); //或运算，二进制结果为 1101，打印结果为 13 System.out.println(num1 | num2); //异或运算，二进制结果为 1100，打印结果为 12 System.out.println(num1 ^ num2); //非运算，打印结果 -6 System.out.println((~num1)); //非运算，二进制结果为 11111111 11111111 11111111 11111010 System.out.println(Integer.toBinaryString(~num1)); } \",\"补充\",\"数字的二进制表现形式为 “有符号的二进制补码”。\",\"原码：数字的二进制表示法，最高位为符号位，“ 0 ” 为正，“ 1 ” 为负。\",\"反码：正数的反码与原码相同，负数的反码对原码逐位取反，符号位除外。\",\"补码：正数的补码与原码相同，负数的补码在其反码末位加 1。\",\"负数的二进制算法（以 -6 为例，int类型占 4 个字节， 1 个字节是 8 位）： \",\"求-6 的原码，即：10000000 00000000 00000000 00000110\",\"求该二进制数的反码，即：11111111 11111111 11111111 11111001\",\"对以上求得的二进制数加 1，即：11111111 11111111 11111111 11111010\",\"说明\",\"位逻辑运算符用来操作整数的二进制位，会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。\"]},\"131\":{\"h\":\"3个移位运算符\",\"t\":[\"移位运算符包括左移（<<）、右移（>>）和无符号右移（>>>）3种。 \",\"左移位操作符 “<<” 按照操作符右侧指定的位数将操作符左边的操作数向左移动（低位补零）。【左移之后，低位补0】\",\"“有符号”右移位操作符 “>>” 按照操作符右侧指定的位数将操作符左边的操作数向右移动。该操作符使用 “符号扩展”：若符号为正，则高位插入 0；若符号为负，则高位插入 1。【右移之后，高位进行符号扩展】\",\"“无符号”右移位操作符 “>>>”，该操作符使用 “零扩展”，无论正负，都在高位插入 0。【右移之后，高位进行零扩展】\",\"@Test public void test() { //二进制 1111; int i = 15; //向右边移动两位，二进制结果为 0011，打印结果为 3 System.out.println(i >> 2); //向左边移动两位，二进制结果为 111100，打印结果为 60 System.out.println(i << 2); } \",\"移位运算符可以与等号组合使用（<<= 或 >>= 或 >>>=），表示操作符左边的值会移动由右边数值指定的位数，再将得到的结果赋给左边的变量。\",\"在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方，右移一位相当于除2，右移n位相当于除以2的n次方。\",\"@Test public void test() { int i = 10; // 左移1位，相当于乘2的1次方 System.out.println(i << 1);// 20 // 左移4位，相当于乘2的4次方 System.out.println(i << 4);// 160 // 右移1位，相当于除2的1次方 System.out.println(i >> 1);// 5 // 左移3位，相当于除2的3次方 System.out.println(i >> 3);// 1 } \",\"说明\",\"移位操作符的运算对象也是二进制的 “位”，但是只能用来处理整数类型。\",\"注意\",\"逻辑运算符包括逻辑与（&&）、逻辑或（||）和逻辑非（!），前两个是二元运算符，后一个是一元运算符。\",\"参考：https://www.cnblogs.com/blknemo/p/14141417.html\"]},\"132\":{\"h\":\"几个有趣的位操作\",\"t\":[\"利用或操作 | 和空格将英文字符转换为小写\",\"('a' | ' ') = 'a' ('A' | ' ') = 'a' \",\"利用与操作 & 和下划线将英文字符转换为大写\",\"('b' & '_') = 'B' ('B' & '_') = 'B' \",\"利用异或操作 ^ 和空格进行英文字符大小写互换\",\"('d' ^ ' ') = 'D' ('D' ^ ' ') = 'd' \",\"以上操作能够产生奇特效果的原因在于 ASCII码。字符的ASCII码其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果。\",\"@Test public void test() { // 测试和空格进行按位或操作转为小写字母 int i1 = 'a' | ' '; int j1 = 'A' | ' '; log.debug(\\\"{},{}\\\", (char) i1, (char) j1);//a,a // 测试和下划线进行按位与操作转为大写字母 int i2 = 'a' & '_'; int j2 = 'A' & '_'; log.debug(\\\"{},{}\\\", (char) i2, (char) j2);//A,A // 测试和空格进行按位异或操作进行大小写转换 int i3 = 'a' ^ ' '; int j3 = 'A' ^ ' '; log.debug(\\\"{},{}\\\", (char) i3, (char) j3);//A,a } \",\"判断两个数是否异号\",\"int x = -1, y = 2; boolean f = ((x ^ y) < 0); // true int x = 3, y = 2; boolean f = ((x ^ y) < 0); // false \",\"不用临时变量交换两个数\",\"int a = 1, b = 2; a ^= b; b ^= a; a ^= b; // 现在 a = 2, b = 1 // 或者 b ^= a; a ^= b; b ^= a; \",\"加一\",\"int n = 1; n = -~n; // 现在 n = 2 \",\"减一\",\"int n = 2; n = ~-n; // 现在 n = 1 \",\"位操作的黑科技玩法\",\"有一个叫做Bit Twiddling Hacks的外国网站收集了几乎所有位操作的黑科技玩法。\",\"网址：http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\"]},\"133\":{\"h\":\"n&(n-1)的运用\",\"t\":[\"n & (n-1) 是算法中常见的位操作，作用是消除数字 n 的二进制表示中的最后一个 1。\",\"其核心逻辑就是，n - 1 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 n 做一次 & 运算，就可以仅仅把最后一个 1 变成 0 了。\",\"1、计算汉明权重（Hamming Weight）\",\"LeetCode相关题目：位1的个数\",\"就是让你返回 n 的二进制表示中有几个 1。因为 n & (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。\",\"public int hammingWeight(int n) { int sum = 0; while (n != 0) { n = n & (n - 1); sum++; } return sum; } \",\"2、判断一个数是不是 2 的指数\",\"LeetCode相关题目：2的幂\",\"一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：\",\"2^0 = 1 = 0b0001 2^1 = 2 = 0b0010 2^2 = 4 = 0b0100 \",\"如果使用 n & (n-1) 的技巧就很简单了（注意运算符优先级，括号不可以省略）：\",\"public boolean isPowerOfTwo(int n) { if (n <= 0) return false; n = n & (n - 1); return n == 0; } //或者 public boolean isPowerOfTwo(int n) { // 一句代码解决问题 return n > 0 && ((n & (n - 1)) == 0); } \"]},\"134\":{\"h\":\"a^a=0的运用\",\"t\":[\"异或运算的性质\",\"一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。\",\"满足结合律和交换律。\",\"由于异或运算满足交换律和结合律，所以总是能把成对儿的数字消去，留下缺失的那个元素。\",\"1、查找只出现一次的元素\",\"LeetCode相关题目：只出现一次的数字\",\"把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素。\",\"// 满足结合律和交换律 // 以[4, 1, 2, 1, 2]为例 0 ^ 4 ^ 1 ^ 2 ^ 1 ^ 2 0 ^ 4 ^ (1 ^ 1) ^ (2 ^ 2) 0 ^ 4 ^ (0 ^ 0) 0 ^ 4 ^ 0 (0 ^ 0) ^ 4 0 ^ 4 4 \",\"public int singleNumber(int[] nums) { int res = 0; for (int n : nums) { res ^= n; } return res; } \",\"2、寻找缺失的元素\",\"LeetCode相关题目：丢失的数字\",\"给一个长度为 n 的数组，其索引应该在 [0,n)，但是现在你要装进去 n + 1 个元素 [0,n]，那么肯定有一个元素装不下，请找出这个缺失的元素。\",\"思路一：把这个数组排个序，然后遍历一遍，就可以很容易的找到缺失的那个元素\",\"public int missingNumber(int[] nums) { Arrays.sort(nums); for (int i = 0; i < nums.length; i++) { if (i != nums[i]) { return i; } } return nums.length; } \",\"思路二：利用数据结构的特性，用一个 HashSet 把数组里出现的数字都储存下来，再遍历 [0,n] 之间的数字，去 HashSet 中查询，也可以很容易查出那个缺失的元素。\",\"public int missingNumber(int[] nums) { HashSet<Integer> set = new HashSet<>(); for (int num : nums) { set.add(num); } for (int i = 0; i <= nums.length; i++) { if (!set.contains(i)) { return i; } } return 0; } \",\"思路三：利用等差数列求和公式，题目的意思可以这样理解：现在有个等差数列 0, 1, 2,..., n，其中少了某一个数字，那这个数字就是 sum(0,1,..n) - sum(nums) 。\",\"public int missingNumber(int[] nums) { int sum1 = (1 + nums.length) * nums.length / 2; int sum2 = 0; for (int num : nums) { sum2 += num; } return sum1 - sum2; } \",\"思路四：利用一个数和它本身做异或运算结果为 0，一个数和 0 做异或运算还是它本身的性质。\",\"异或运算满足交换律和结合律\",\"2 ^ 3 ^ 2 = 3 ^ (2 ^ 2) = 3 ^ 0 = 3 \",\"比如说 nums = [0,3,1,4]：\",\"假设先把索引补一位，然后让每个元素和自己相等的索引相对应：\",\"通过上图可以发现：只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元素会剩下。\",\"public int missingNumber(int[] nums) { // 时间复杂度O(N) // 空间复杂度O(1) int result = 0; // 把索引全都异或一遍，范围是[0,n]，左右都包括，即n+1个数 for (int i = 0; i <= nums.length; i++) { result ^= i; } // 把nums中的值全都异或一遍，即n个数 for (int num : nums) { result ^= num; } return result; } \",\"public int missingNumber(int[] nums) { // 时间复杂度O(N) // 空间复杂度O(N) // list放置索引和nums中的所有值，后续依次对list中的数据进行异或操作 ArrayList<Integer> list = new ArrayList<>(); // 把索引全都加入list for (int i = 0; i <= nums.length; i++) { list.add(i); } // 把nums中的值全都加入list for (int num : nums) { list.add(num); } // 对list中的所有值进行异或操作 int result = 0; for (Integer integer : list) { result ^= integer; } return result; } // 本思路直接将题目演变成了LeetCode的第136题目，即只出现一次的数字。 \"]},\"135\":{\"h\":\"两道常考的阶乘算法题\"},\"136\":{\"h\":\"题一\",\"t\":[\"LeetCode相关题目：阶乘后的零\",\"输入一个非负整数 n，请你计算阶乘 n! 的结果末尾有几个 0。\",\"比如说输入 n = 5，算法返回 1，因为 5! = 120，末尾有一个 0。\",\"两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，因为 10 = 2 x 5。\",\"问题转化为：n! 最多可以分解出多少个因子 2 和 5？\",\"比如说 n = 25，那么 25! 最多可以分解出几个 2 和 5 相乘？这个主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。25! 中 5 可以提供一个，10 可以提供一个，15 可以提供一个，20 可以提供一个，25 可以提供两个，总共有 6 个因子 5，所以 25! 的结果末尾就有 6 个 0。\",\"问题转化为：n! 最多可以分解出多少个因子 5？\",\"难点在于像 25，50，125 这样的数，可以提供不止一个因子 5，怎么才能不漏掉呢？\",\"假设 n = 125，来算一算 125! 的结果末尾有几个 0：\",\"首先，125 / 5 = 25，这一步就是计算有多少个像 5，15，20，25 这些 5 的倍数，它们一定可以提供一个因子 5。\",\"然后，像 25，50，75 这些 25 的倍数，可以提供两个因子 5，那么我们再计算出 125! 中有 125 / 25 = 5 个 25 的倍数，它们每人可以额外再提供一个因子 5。\",\"最后，我们发现 125 = 5 x 5 x 5，像 125，250 这些 125 的倍数，可以提供 3 个因子 5，那么我们还得再计算出 125! 中有 125 / 125 = 1 个 125 的倍数，它还可以额外再提供一个因子 5。\",\"125! 最多可以分解出 25 + 5 + 1 = 31 个因子 5，也就是说阶乘结果的末尾有 31 个 0。\",\"public int trailingZeroes(int n) { /* n / 5 n / 5 / 5 n / 5 / 5 / 5 */ int result = 0; // d有可能越界 long d = 5; // n可以分解出多少个因子5 while (d <= n) { result += (n / d); d *= 5; } // d>n的时候退出循环，n如果是int的最大值，那么d使用int类型有可能越界，所以使用long类型 return result; } \",\"public int trailingZeroes(int n) { /* n / 5 n / 5 / 5 n / 5 / 5 / 5 */ int result = 0; for (int i = 1; Math.pow(5, i) <= n; i++) { result += (n / Math.pow(5, i)); } return result; } \",\"public int trailingZeroes(int n) { /* n / 5 n / 5 / 5 n / 5 / 5 / 5 */ int res = 0; for (int d = n; d / 5 > 0; d = d / 5) { res += d / 5; } return res; } \",\"时间复杂度是底数为 5 的对数，也就是 O(logN)。\"]},\"137\":{\"h\":\"题二\",\"t\":[\"LeetCode相关题目：阶乘函数后K个零\",\"输入一个非负整数 K，请你计算有多少个 n，满足 n! 的结果末尾恰好有 K 个 0。\",\"比如说输入 K = 1，算法返回 5，因为 5!,6!,7!,8!,9! 这 5 个阶乘的结果最后只有一个 0，即有 5 个 n 满足条件。\",\"一个直观地暴力解法就是穷举，因为随着 n 的增加，n! 肯定是递增的，trailingZeroes(n!) 肯定也是递增的，伪码逻辑如下：\",\"int res = 0; for (int n = 0; n < +inf; n++) { if (trailingZeroes(n) < K) { continue; } if (trailingZeroes(n) > K) { break; } if (trailingZeroes(n) == K) { res++; } } return res; \",\"对于这种具有单调性的函数，用 for 循环遍历，可以用二分查找进行降维打击。\",\"搜索有多少个 n 满足 trailingZeroes(n) == K，其实就是在问，满足条件的 n 最小是多少，最大是多少，最大值和最小值一减，就可以算出来有多少个 n 满足条件，这就是二分查找中搜索左侧边界和搜索右侧边界。\",\"寻找上界和下界\",\"因为二分查找需要给一个搜索区间，也就是上界和下界，上述伪码中 n 的下界显然是 0，但上界是 +inf，这个正无穷应该如何表示出来呢？\",\"首先，数学上的正无穷肯定是无法编程表示出来的，我们一般的方法是用一个非常大的值，大到这个值一定不会被取到。比如说 int 类型的最大值 INT_MAX（2^31 - 1），还不够的话就 long 类型的最大值 LONG_MAX（2^63 - 1）。\",\"需要多大才能一定不会被取到呢？这就需要认真读题，看看题目给的数据范围有多大。\",\"这道题目实际上给了限制，K 是在 [0, 10^9] 区间内的整数，也就是说，trailingZeroes(n) 的结果最多可以达到 10^9。然后我们可以反推，当 trailingZeroes(n) 结果为 10^9 时，n 为多少？这个不需要你精确计算出来，你只要找到一个数 hi，使得 trailingZeroes(hi) 比 10^9 大，就可以把 hi 当做正无穷，作为搜索区间的上界。\",\"trailingZeroes 函数是单调函数，那可以先算一下 trailingZeroes(INT_MAX) 的结果，比 10^9 小一些，那再用 LONG_MAX 算一下，远超 10^9 了，所以 LONG_MAX 可以作为搜索的上界。\",\"在区间 [0, LONG_MAX] 中寻找满足 trailingZeroes(n) == K 的左侧边界和右侧边界。\",\"/* 主函数 */ public int preimageSizeFZF(int K) { // 左边界和右边界之差 + 1 就是答案 return (int) (right_bound(K) - left_bound(K) + 1); } /* 搜索 trailingZeroes(n) == K 的左侧边界 */ public long left_bound(int target) { long lo = 0, hi = Long.MAX_VALUE; while (lo < hi) { long mid = lo + (hi - lo) / 2; if (trailingZeroes(mid) < target) { lo = mid + 1; } else if (trailingZeroes(mid) > target) { hi = mid; } else { hi = mid; } } return lo; } /* 搜索 trailingZeroes(n) == K 的右侧边界 */ public long right_bound(int target) { long lo = 0, hi = Long.MAX_VALUE; while (lo < hi) { long mid = lo + (hi - lo) / 2; if (trailingZeroes(mid) < target) { lo = mid + 1; } else if (trailingZeroes(mid) > target) { hi = mid; } else { lo = mid + 1; } } return lo - 1; } // 全都改成long类型，避免整型溢出 public long trailingZeroes(long n) { long result = 0; long d = 5; while (d <= n) { result += n / d; d *= 5; } return result; } \",\"时间复杂度主要是二分搜索，从数值上来说 LONG_MAX 是 2^63 - 1，虽然大得离谱，但是二分搜索是对数级的复杂度，log(LONG_MAX) 是一个常数；\",\"每次二分的时候都会调用一次 trailingZeroes 函数，复杂度 O(logK)；\",\"所以总体的时间复杂度就是 O(logK)。\",\"规律和优化\",\"这个题的答案其实不是0就是5，所以其实只需要判断阶乘结果末尾恰好有 K 个 0的值是否存在即可，如果存在，那么我们直接return 5；如果不存在，则直接return 0即可。\",\"此优化效率提升明显。\",\"public int preimageSizeFZF(int K) { long lo = 0, hi = Long.MAX_VALUE; while (lo < hi) { long mid = lo + (hi - lo) / 2; if (trailingZeroes(mid) < K) { lo = mid + 1; } else if (trailingZeroes(mid) > K) { hi = mid; } else { // 找到之后直接返回结果5 return 5; } } return 0; } // 全都改成long类型，避免整型溢出 public long trailingZeroes(long n) { long result = 0; long d = 5; while (d <= n) { result += n / d; d *= 5; } return result; } \"]},\"138\":{\"h\":\"高效寻找素数\"},\"139\":{\"h\":\"高效进行模幂运算\",\"t\":[\"LeetCode相关题目：超级次方\",\"要求你的算法返回幂运算 a^b 的计算结果与 1337 取模（mod，也就是余数）后的结果，这个 b 是一个非常大的正整数且会以数组形式给出。\",\"一是如何处理用数组表示的指数。现在 b 是一个数组，也就是说 b 可以非常大，没办法直接转成整型，否则可能溢出。\",\"二是如何得到求模之后的结果。先把幂运算结果算出来，然后做 % 1337 ，但指数运算的真实结果肯定会大得吓人，也就是说，算出来真实结果也没办法表示，早都溢出报错了。\",\"三是如何高效进行幂运算。\"]},\"140\":{\"h\":\"如何处理数组指数\",\"t\":[\"首先明确问题：现在 b 是一个数组，不能表示成整型，而且数组的特点是随机访问，删除最后一个元素比较高效。\",\"以 b = [1,5,6,4] 来举例，结合指数运算的法则，我们可以发现这样的一个规律：\",\"问题规模缩小，这是递归的标志。\",\"先不考虑取模的情况：\",\"// 手动实现pow(a,b)-不使用递归 public int myPow(int a, int b) { if (b < 0) return -1;//非法情况 if (b == 0) return 1;//不能丢掉，否则会遗漏b=0的情况【仔细分析，由于res的值为1，实际上可以丢掉】 int res = 1; for (int i = 1; i <= b; i++) { res *= a; } return res; } // 手动实现pow(a,b)-使用递归 public int myPow(int a, int b) { if (b < 0) return -1;//非法情况 if (b == 0) return 1;//能丢掉，实际上走不到这 if (b == 1) return a; return a * myPow(a, b - 1); } // 递归 public int superPow(int a, int[] b) { // 递归终止条件 if (b.length == 0) return 1; // 将原问题化简，缩小规模递归求解 // 计算第一部分 int part1 = myPow(a, b[b.length - 1]); // 计算第二部分 int part2 = myPow(superPow(a, Arrays.copyOf(b, b.length - 1)), 10); // 合并结果 return part1 * part2; } \"]},\"141\":{\"h\":\"如何处理mod运算\",\"t\":[\"首先明确问题：由于计算机的编码方式，形如 (a * b) % base 这样的运算，乘法的结果可能导致溢出，我们希望找到一种技巧，能够化简这种表达式，避免溢出同时得到结果。 \",\"比如在二分查找中，我们求中点索引时用 (l+r)/2 转化成 l+(r-l)/2，避免溢出的同时得到正确的结果。\",\"快速进行mod运算公式：(a * b) % k = [(a % k)(b % k)] % k\",\"对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模。\",\"完整代码：\",\"public int base = 1337; // 手动实现pow(a,b) // 函数返回的是pow(a,b)取模之后的结果 public int myPow(int a, int b) { // 1*a*a*a*a... if (b < 0) return -1;//非法情况 if (b == 0) return 1;//不能丢掉，否则会遗漏b=0的情况【仔细分析，由于res的值为1，实际上可以丢掉】 int res = 1; a %= base; for (int i = 1; i <= b; i++) { res *= a; res %= base; } return res; } // 递归 public int superPow(int a, int[] b) { // 递归终止条件 if (b.length == 0) return 1; // 将原问题化简，缩小规模递归求解 // 计算第一部分 int part1 = myPow(a, b[b.length - 1]); // 计算第二部分 int part2 = myPow(superPow(a, Arrays.copyOf(b, b.length - 1)), 10); // 合并结果 return (part1 * part2) % base; } \",\"myPow函数先对因子 a 求模，然后每次都对乘法结果 res 求模，这样可以保证 res *= a 这句代码执行时两个因子都是小于 base 的，也就一定不会造成溢出，同时结果也是正确的。\",\"myPow函数也可以通过递归方式进行优化，完整代码如下（推荐使用高级的快速幂算法，时间复杂度可以达到O(logN)对数级别）：\",\"// 手动实现pow(a,b) // 函数返回的是pow(a,b)取模之后的结果 public int myPow(int a, int b) { /** * 以a^4为例，则b=4，该函数返回的是a^4取模之后的结果 * 即：(a^4)%base * (a*a^3)%base * (a%base)((a^3)%base)%base * 其中：(a^3)%base是(a^4)%base规模缩小的问题 * 所以可以使用递归进行求解 */ if (b < 0) return -1;//非法情况 if (b == 0) return 1;//能丢掉，实际上走不到这 if (b == 1) return a % base; return ((a % base) * (myPow(a, b - 1))) % base; } // 时间复杂度为O(N) \"]},\"142\":{\"h\":\"如何高效求幂（快速幂）\",\"t\":[\"快速幂（快速的进行幂运算）是一种简单而有效的小算法，它能够以O(log⁡N)的时间复杂度进行幂运算，快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。\",\"举个例子：7的10次方，怎样算比较快？\",\"最朴素的想法：7*7=49、49*7=343，依次一步一步算，共进行了9次乘法。\",\"先算7的5次方，即7*7*7*7*7，再算它的平方，共进行了5次乘法。\",\"先算7*7得49，则7的5次方为49*49*7，再算它的平方，共进行了4次乘法。\",\"模仿这样的过程，我们得到一个在 O(log⁡N) 时间内计算出幂的算法，也就是快速幂。\",\"递归快速幂【 重点掌握 】\",\"// 递归快速幂 public int recursionPow(int a, int b) { if (b < 0) return -1;// 非法情况 if (b == 0) {// 0 return 1;// 相当于是递归的结束条件 } else if (b % 2 == 1) {// 奇数 return recursionPow(a, b - 1) * a; } else {// 偶数 // tmp变量是必要的 // 如果写成recursionPow(a, b / 2)*recursionPow(a, b / 2) // 则计算机会计算两次，那么算法退化成O(N)的时间复杂度 int tmp = recursionPow(a, b / 2); return tmp * tmp; } } \",\"注意\",\"在实际问题中，题目常常会要求对一个大数取模，这是因为幂运算的计算结果可能会非常巨大。\",\"快速幂也应当进行取模，此时应当注意：三种情况都需要考虑取模，如果取模的base较大，还应当使用long类型进行定义。\",\"// 递归快速幂 // 返回的是取模之后的结果 public int recursionPow(int a, int b) { if (b < 0) return -1;// 非法情况 if (b == 0) {// 0 return 1;// 相当于是递归的结束条件 } else if (b % 2 == 1) {// 奇数 return (recursionPow(a, b - 1) * (a % base)) % base; } else {// 偶数 // tmp变量是必要的 // 如果写成recursionPow(a, b / 2)*recursionPow(a, b / 2) // 则计算机会计算两次，那么算法退化成O(N)的时间复杂度 int tmp = recursionPow(a, b / 2); return (tmp * tmp) % base; } } \",\"递归虽然简洁且运算速度快，但会产生额外的空间开销，可以把递归改写为循环，来避免对栈空间的大量占用，也就是非递归快速幂。 \",\"时间复杂度：O(log⁡N)，即为递归的层数。\",\"空间复杂度：O(log⁡N)，即为递归的层数。这是由于递归的函数调用会使用栈空间。\",\"非递归快速幂【 重点掌握 】\",\"引入\",\"换一个角度来引入非递归的快速幂，还是7的10次方，但这次，把10写成二进制的形式，也就是 0b1010 。\",\"要计算 70b1010 ，可以怎么做？ \",\"很自然地想到可以把它拆分为 70b1000*70b10 。\",\"实际上，对于任意的整数，都可以把它拆成若干个 70b100...的形式相乘。\",\"而这些70b100...，恰好就是 71 、72、74等等，我们只需不断把底数平方就可以算出它们。\",\"不考虑取模的情况：\",\"// 非递归快速幂 public int unRecursionPow(int a, int n) { if (n < 0) return -1;//非法情况 if (n == 0) return 1;//不能丢掉，否则会遗漏b=0的情况【仔细分析，由于res的值为1，实际上可以丢掉】 int ans = 1; while (n != 0) { if ((n & 1) == 1) //如果n的当前末位为1 ans *= a; //ans乘上当前的a a *= a; //a自乘 n >>= 1; //n往右移一位 } return ans; } \",\"考虑取模的情况：\",\"// 非递归快速幂 // 返回的是取模之后的结果 public int unRecursionPow(int a, int n) { if (n < 0) return -1;//非法情况 if (n == 0) return 1;//不能丢掉，否则会遗漏b=0的情况【仔细分析，由于res的值为1，实际上可以丢掉】 int ans = 1; a %= base; while (n != 0) { if ((n & 1) == 1) {//如果n的当前末位为1 ans *= a; //ans乘上当前的a ans %= base; } // 潜在的整型溢出 a *= a; //a自乘 a %= base; n >>= 1; //n往右移一位 } return ans; } \",\"复杂度分析 \",\"时间复杂度：O(log⁡N)，即为对 n 进行二进制拆分的时间复杂度。\",\"空间复杂度：O(1)。\",\"总结 \",\"空间复杂度要求的不是太高的话，建议还是使用递归快速幂。\",\"参考：\",\"https://zhuanlan.zhihu.com/p/95902286\",\"https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/\",\"LeetCode相关题目：\",\"Pow(x, n)：考虑指数为负数的情况。\",\"// 主函数 public double myPow(double x, int n) { long N = n; if (N == 0) return 1; return N < 0 ? 1 / unRPow(x, -N) : unRPow(x, N); } // 使用非递归快速幂 public double unRPow(double a, long b) { if (b < 0) return -1;// 非法情况 if (b == 0) return 1; double res = 1.0; while (b != 0) { if ((b & 1) == 1) {//末位是1 res *= a; } a *= a; b >>= 1; } return res; } \",\"注意\",\"Java中int类型的范围是[-2147483648,2147483647]，即最大值是231-1，最小值是-231。\",\"所以在测试用例x=1，n=-2147483648运行时，使用下面的代码会出现问题：\",\"// 主函数 public double myPow(double x, int n) { if (n == 0) return 1; return n < 0 ? 1 / unRPow(x, -n) : unRPow(x, n); // 当n=-2147483648时候，取相反数应该是2147483648，但int类型最大值才是2147483647，所以取相反数是不变的，还是原值-2147483648。 // 解决办法是将其转为long类型 } \",\"数值的整数次方\"]},\"143\":{\"h\":\"同时寻找缺失和重复的元素\",\"t\":[\"LeetCode相关题目：错误的集合\",\"给一个长度为 N 的数组 nums，其中本来装着 [1..N] 这 N 个元素，无序。但是现在出现了一些错误，nums 中的一个元素出现了重复，也就同时导致了另一个元素的缺失。\",\"正常思路：首先记录每一个元素出现的次数，找到重复的元素，然后在找缺失的元素。\",\"import java.util.*; class Solution { public int[] findErrorNums(int[] nums) { int[] res = new int[2]; // 存储每一个元素出现的此次数 Hashtable<Integer, Integer> hashtable = new Hashtable<>(); for (int num : nums) { if (!hashtable.containsKey(num)) { hashtable.put(num, 1); } else { hashtable.put(num, hashtable.get(num) + 1); } } Set<Integer> set = hashtable.keySet(); for (Integer integer : set) { if (hashtable.get(integer) != 1) res[0] = integer; } for (int i = 1; i <= nums.length; i++) { if (set.contains(i)) continue; else res[1] = i; } return res; } } \",\"复杂度分析\",\"时间复杂度：O(N)\",\"空间复杂度：O(N)\",\"O(N) 的时间复杂度遍历数组是无法避免的，所以可以想想办法如何降低空间复杂度，是否可以在 O(1) 的空间复杂度之下找到重复和缺失的元素？\",\"思路分析（优化空间复杂度到O(1)） \",\"每个元素和数组索引有一定的对应关系。\",\"暂且将 nums 中的元素变为 [0..N-1]，这样每个元素就和一个数组索引完全对应了，这样方便理解一些。\",\"如果说 nums 中不存在重复元素和缺失元素，那么每个元素就和唯一一个索引值对应。\",\"有一个元素重复了，同时导致一个元素缺失了，会导致有两个元素对应到了同一个索引，而且会有一个索引没有元素对应过去。\",\"找到这个重复对应的索引，就找到了那个重复的元素；找到那个没有元素对应的索引，就找到了那个缺失的元素。\",\"思路分析\",\"用数组元素的绝对值做下标，然后让这个下标对应的元素置为负的，相当于把它标记为已访问过的元素，如果某个元素做下标时对应的元素值为负，则这个数是重复值。再次遍历数组寻找唯一没有置为负的那个元素，它的下标就是缺失的元素值。\",\"假设元素是 [0..N-1]，但题目要求是 [1..N]，所以需要修改部分的值才能得到正确结果。\",\"时间复杂度：O(N)\",\"空间复杂度：O(1)\",\"原理图如下：\",\"完整代码如下：\",\"public int[] findErrorNums(int[] nums) { int[] res = new int[2]; // 寻找重复的元素 int length = nums.length; for (int i = 0; i < length; i++) { int index = Math.abs(nums[i]) - 1; if (nums[index] >= 0) { nums[index] *= -1; } else { res[0] = index+1; } } // 寻找缺失的元素 for (int i = 0; i < length; i++) { if (nums[i] > 0) { res[1] = i + 1; break; } } return res; } \",\"对于这种数组问题，关键点在于元素和索引是成对儿出现的，常用的方法是排序、异或、映射。\",\"LeetCode相关题目： \",\"数组中重复的数据\",\"找到所有数组中消失的数字\"]},\"144\":{\"h\":\"在无限序列中随机抽取元素\"},\"145\":{\"h\":\"游戏中的随机算法\"},\"146\":{\"h\":\"一行代码解决的算法题\"},\"147\":{\"h\":\"几个反直觉的概率问题\"},\"148\":{\"c\":[\"算法\",\"数据结构\"]},\"149\":{\"c\":[\"算法\",\"数据结构\"]},\"150\":{\"h\":\"数据结构\"},\"151\":{\"h\":\"手写LRU缓存淘汰算法\"},\"152\":{\"h\":\"LRU算法描述\"},\"153\":{\"h\":\"LRU算法设计\"},\"154\":{\"h\":\"代码实现\"},\"155\":{\"h\":\"手写LFU算法\"},\"156\":{\"h\":\"算法描述\"},\"157\":{\"h\":\"思路分析\"},\"158\":{\"h\":\"代码框架\"},\"159\":{\"h\":\"LFU核心逻辑\"},\"160\":{\"h\":\"二叉树搜索树操作集锦\"},\"161\":{\"h\":\"判断BST的合法性\"},\"162\":{\"h\":\"在BST中查找一个数是否存在\"},\"163\":{\"h\":\"在BST中插入一个数\"},\"164\":{\"h\":\"在BST中删除一个数\"},\"165\":{\"h\":\"完全二叉树的节点数为什么难算\"},\"166\":{\"h\":\"思路分析\"},\"167\":{\"h\":\"复杂度分析\"},\"168\":{\"h\":\"用各种遍历框架序列化和反序列化二叉树\"},\"169\":{\"h\":\"题目描述\"},\"170\":{\"h\":\"前序遍历解法\"},\"171\":{\"h\":\"后序遍历解法\"},\"172\":{\"h\":\"中序遍历解法\"},\"173\":{\"h\":\"层级遍历解法\"},\"174\":{\"h\":\"Git原理之二叉树最近公共祖先\"},\"175\":{\"h\":\"二叉树的最近公共祖先\"},\"176\":{\"h\":\"思路分析\"},\"177\":{\"h\":\"特殊数据结构-单调栈\"},\"178\":{\"h\":\"单调栈解题模版\"},\"179\":{\"h\":\"题目变形\"},\"180\":{\"h\":\"如何处理循环数组\"},\"181\":{\"h\":\"特殊数据结构-单调队列\"},\"182\":{\"h\":\"搭建解题框架\"},\"183\":{\"h\":\"实现单调队列数据结构\"},\"184\":{\"h\":\"算法复杂度分析\"},\"185\":{\"h\":\"如何判断回文链表\"},\"186\":{\"h\":\"判断回文单链表\"},\"187\":{\"h\":\"优化空间复杂度\"},\"188\":{\"h\":\"最后总结\"},\"189\":{\"h\":\"秀操作-纯递归反转链表\"},\"190\":{\"h\":\"递归反转整个链表\"},\"191\":{\"h\":\"反转链表前N个节点\"},\"192\":{\"h\":\"反转链表的一部分\"},\"193\":{\"h\":\"最后总结\"},\"194\":{\"h\":\"秀操作-K个一组反转链表\"},\"195\":{\"h\":\"分析问题\"},\"196\":{\"h\":\"代码实现\"},\"197\":{\"h\":\"最后总结\"},\"198\":{\"c\":[\"算法\",\"数据结构\"]},\"199\":{\"c\":[\"算法\",\"数据结构\"]},\"200\":{\"h\":\"核心套路\"},\"201\":{\"h\":\"学习算法和刷题的框架思维\",\"t\":[\"学习解决问题的思路、套路、框架，养成“框架思维”，不应该纠结于问题的细节，把握问题的共性和本质，做到举一反三。\"]},\"202\":{\"h\":\"数据结构的存储方式\",\"t\":[\"数据结构的底层存储方式只有两种：数组（顺序存储）和链表（链式存储）。\",\"其他的数据结构，比如哈希表、栈、队列、堆、树、图等都是属于具体的上层建筑，都是在数组或者链表上的特殊操作，只是API特性不同而已。\",\"数组\",\"数组由于是紧凑连续存储，因此可以随机访问，通过索引快速找到对应的元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配足，所以数组如果要扩容，需要先重新分配一块更大的空间，再把数据全部复制进去，时间复杂度为O(N)；而且如果想在数组中间和开始位置进行插入和删除操作，每次必须移动后面的所有数据以保持连续，时间复杂度为O(N)。\",\"数组在开始、中间、最后位置的增删改查分析如下：\",\"开始位置：增加和删除都需要挪动元素，所以效率不高，但是查询和修改就比较高效。\",\"中间位置：增加和删除都需要挪动元素，所以效率不高，但是查询和修改就比较高效。\",\"最后位置：增加和删除位置不需要挪动元素，效率比较高，同时查询和修改效率也比较高。\",\"链表\",\"链表因为元素不连续，靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后继，操作指针即可删除该元素或者插入新元素，时间复杂度为O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，因此会消耗相对更多的存储空间。\",\"链表在开始、中间、最后位置的增删改查分析如下：\",\"开始位置：增加和删除元素只需要操作指针，效率较高，查询和修改元素就在头节点不需要进行遍历，所以效率也比较高。\",\"中间位置：增加和删除元素只需要操作指针，效率较高，查询和修改元素需要从头节点开始进行遍历，时间复杂度为O(N)，所以效率不高。\",\"最后位置：增加和删除元素只需要操作指针，效率较高，查询和修改元素需要从头节点开始进行遍历，时间复杂度为O(N)，所以效率不高。\",\"综上所述：\",\"如果想要查询和修改比较高效，那就使用数组的底层结构。\",\"如果想要插入和删除比较高效，那就使用链表的底层结构。\"]},\"203\":{\"h\":\"数据结构的基本操作\",\"t\":[\"任何的数据结构其基本操作就是遍历+访问，在详细一点就是：各种数据结构在不同的应用场景下尽可能高效地进行增删改查。\",\"各种数据结构的遍历+访问无非就是两种形式：线性（for/while迭代）和非线性（递归）。\",\"数组遍历框架，是典型的线形结构：\",\"void traverse(int[] arr) { for (int i = 0; i < arr.length; i++) { //迭代访问arr[i] } } \",\"链表遍历框架，兼具迭代和递归结构：\",\"class ListNode { int val; ListNode next; } void traverse1(ListNode head) { for (ListNode p = head; p != null; p = p.next) { //迭代遍历p.val } } void traverse2(ListNode head) { //前序遍历head.val traverse2(head.next); //后序遍历head.val } \",\"二叉树具有前序遍历、中序遍历、后序遍历，其实链表也有前序遍历和后序遍历。如果在前序遍历的位置打印head.val，那么就是正序打印链表；如果在后序遍历的位置打印head.val，那么就是倒序打印链表。\",\"二叉树遍历框架，是典型的非线性递归遍历结构：\",\"class TreeNode { int val; TreeNode left, right; } void traverse(TreeNode root) { //前序遍历 traverse(root.left); //中序遍历 traverse(root.right); //后序遍历 } \",\"通过上面的代码可以看到二叉树的遍历与链表的遍历方式非常相似，所以可以将遍历方式扩展到N叉树。\",\"N叉树的遍历框架如下所示：\",\"class TreeNode { int val; TreeNode[] childrens; } void traverse(TreeNode root) { for (TreeNode children : root.childrens) { traverse(children); } } \",\"N叉树的遍历又可以扩展到图的遍历，因为图就是好几个N叉树的结合体。但是图有可能出现环，这其实很好解决，使用布尔数组visited做标记就可以了。所谓的框架思维就是记住这些遍历框架，根据具体问题在框架上添加代码即可。\"]},\"204\":{\"h\":\"算法刷题指南\",\"t\":[\"数据结构和算法\",\"数据结构是工具，算法是通过合适的工具解决特定问题的方法。\",\"先刷二叉树，因为二叉树是最容易培养框架思维的，而且大部分的常考算法本质上都是树的遍历问题。\",\"试着从框架看问题，而不要纠结于细节。\"]},\"205\":{\"h\":\"动态规划解题套路框架\"},\"206\":{\"h\":\"回溯算法解题套路框架\"},\"207\":{\"h\":\"全排列问题\"},\"208\":{\"h\":\"N皇后问题\"},\"209\":{\"h\":\"最后总结\"},\"210\":{\"h\":\"BFS算法套路框架\",\"t\":[\"BFS（广度优先搜索-Broad First Search）和DFS（深度优先搜索-Depth First Search）是两种特别常用的算法，其中DFS可被认为就是前面的回溯算法。\",\"BFS核心思想：把一些问题抽象成图，从一个点开始，向四周扩散，一般来说，BFS都是用队列这种数据结构，每次都是将一个节点周围的所有节点加入队列。\",\"BFS和DFS的区别：BFS找到的路径一定是最短的，但代价是空间复杂度要比DFS大很多。\"]},\"211\":{\"h\":\"算法框架\",\"t\":[\"BFS出现的场景：问题的本质就是让你在一幅图中找到从起点到终点的最近距离。所谓的BFS本质就是解决该问题的，但是实际中很多题目的描述都是这个本质场景的各种变体，要把现实问题的场景抽象成一幅图，使用BFS的思想进行求解。\",\"框架如下：\",\"int BFS(Node start, Node target) { //核心数据结构，节点类型的队列 Queue<Node> q; //记录已经走过的节点，避免走回头路 Set<Node> visited; //将起点加入队列中 q.offer(start); visited.add(start); //记录扩散的步数 int step = 0; //队列非空执行 while (q not empty){ //获取队列长度 int sz = q.size(); //将当前队列中的所有节点向四周扩散 for (int i = 0; i < sz; i++) { //取出队列头元素 Node cur = q.poll(); //划重点：这里判断是否达到终点 if (cur is target){ return step; } //将cur的相邻节点加入队列 for (Node x : cur.adj()) { //判断当前节点是否被访问过 if (x not in visited){ //加入相邻节点到队列中 q.offer(x); visited.add(x); } } } //划重点：队列中的数据已经更新为新的数据，在这里更新步数 step++; } return step; } \",\"变量解释\",\"q就是核心的队列数据结构；\",\"cur就是当前节点，即队列的头元素；\",\"cur.adj()泛指与cur相邻的所有节点，比如在二维数组中，cur上下左右四面的位置就是相邻节点；\",\"visited的主要作用是防止走回头路，大部分时候都是必需的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要visited；\"]},\"212\":{\"h\":\"二叉树的最小高度\",\"t\":[\"需求：计算一棵二叉树的最小高度，输入一棵二叉树，计算它的最小高度，也就是根节点到叶子节点的最短距离。\",\"分析：起点是什么？root！终点是什么？cur.left == null and cur.right == null!\",\"代码如下：\",\"/*** * @Description: 二叉树节点 * @Author: Mr.Tong */ class TreeNode { int val; TreeNode left, right; } /*** * @Description: 二叉树的最小高度 * @Author: Mr.Tong */ int minDepth(TreeNode root) { if (root == null) return 0; Queue<TreeNode> q = new LinkedList<>(); q.offer(root); int depth = 1;//root本身就是一层 while (!q.isEmpty()) { int size = q.size(); //队列中所有节点向四周扩散 for (int i = 0; i < size; i++) { TreeNode cur = q.poll(); //判断当前节点是不是终点 if (cur.left == null && cur.right == null) { return depth; } //将当前节点相邻的所有节点放入队列 if (cur.left != null) { q.offer(cur.left); } if (cur.right != null) { q.offer(cur.right); } } //更新步数 depth++; } return depth; } \",\"理解\",\"整个算法过程通过画图可以很容易的理解，后面的几个LeetCode题目也建议通过画图的方式加深对BFS思想的理解。\",\"两个问题\",\"为什么BFS可以找到最短距离，DFS不行吗？\",\"BFS的逻辑是depth每增加一次，队列中所有节点都向前迈了一步，这个逻辑保证了一旦找到一个终点，走的步数是最少的，BFS的时间复杂度最坏情况是O(N)。\",\"DFS也是可以找到最短路径的，时间复杂度也是O(N)，但是实际上比BFS低效很多。这是因为DFS是靠递归的堆栈记录走过的路径的，如果要找到最短路径，肯定要把二叉树中的所有树杈都走完，然后才能对比得到最短路径，但是BFS借助队列可以做到一步一步“齐头并进”，是可以在还没遍历完整的一棵树的时候就可以找到最短距离。\",\"总结一下：DFS是线，BFS是面，DFS是单打独斗，BFS是集体行动。\",\"既然BFS那么好，那么为什么还需要DFS？\",\"BFS是可以找到最短路径，但是其空间复杂度高，而DFS的空间复杂度较低。\",\"假设有一棵树是满二叉树，节点数为N，对于DFS算法来说，空间复杂度无非就是递归堆栈，在最坏情况下顶多就是树的高度，也就是O(logN)。但是对于BFS算法来说。队列中每次都会存储二叉树一层的节点，这样在最坏情况下空间复杂度应该是树的最下层节点的数量，也就是N/2，即O(N)。\",\"BFS还是有代价的，一般来说在找最短路径的时候用的是BFS，其他情况用的还是DFS多一些（递归代码好写）。\",\"LeetCode相关题目\",\"二叉树的最小深度\",\"二叉树的层序遍历\",\"二叉树的层序遍历2\",\"二叉树的最大深度\",\"N叉树的层序遍历\",\"二叉树的锯齿形层序遍历\",\"路径之和\",\"小总结\",\"BFS是广度优先搜索，其抽象是以图的概念进行说明，但是在二叉树等数据结构中却频繁用到该算法，这是因为二叉树、二维数组等就是图的具体化。\",\"图中某个节点向四周扩散具体到二叉树、二维数组等数据结构分别是：二叉树某个节点扩散到其左右子节点、二维数组某个节点扩散到其上下左右四个子节点。但是树结构一般不用visited来防止走回头路，因为根本就没有子节点到父节点的指针存在，所以不用担心会走回头路。\"]},\"213\":{\"h\":\"解开密码锁的最少次数\",\"t\":[\"题目链接：打开转盘锁\",\"不管所有的限制条件，不管 deadends 和 target 的限制，就思考⼀个问题：如果让你设计⼀个算法，穷举所有可能的密码组合，你怎么做？\",\"穷举：总共有 4 个位置， 每个位置可以向上转，也可以向下转，也就是有 8 种可能，然后，再以这 8 种密码作为基础，对每个密码再转⼀下，穷举出所有可能。\",\"仔细想想，这就可以抽象成⼀幅图，每个节点有 8 个相邻的节点，⼜让求最短距离，这就是典型的 BFS。\",\"穷举所有可能的密码组合\",\"// 将 s[j] 向上拨动⼀次 String plusOne(String s, int j) { char[] ch = s.toCharArray(); if (ch[j] == '9') ch[j] = '0'; else ch[j] += 1; return new String(ch); } // 将 s[j] 向下拨动⼀次 String minusOne(String s, int j) { char[] ch = s.toCharArray(); if (ch[j] == '0') ch[j] = '9'; else ch[j] -= 1; return new String(ch); } // BFS 框架，打印出所有可能的密码 void BFS(String target) { // 核心数据结构-队列 Queue<String> q = new LinkedList<>(); // 添加根节点 q.offer(\\\"0000\\\"); while (!q.isEmpty()) { int sz = q.size(); /* 将当前队列中的所有节点向周围扩散 */ for (int i = 0; i < sz; i++) { String cur = q.poll(); /* 判断是否到达终点 */ System.out.println(cur); /* 将⼀个节点的相邻节点加⼊队列 */ for (int j = 0; j < 4; j++) { String up = plusOne(cur, j); String down = minusOne(cur, j); q.offer(up); q.offer(down); } } // 队列中的数据已经更新完 /* 在这⾥增加步数 */ } return; } // 1000 9000 0100 0900 0010 0090 0001 0009 -> 第一次更新数据 // ... -> 以上面的八个数为基础进行第二次数据的更新，以此类推 \",\"上面的代码可以穷举所有的密码组合，但是还存在如下问题：\",\"会走回头路。比如从0000转到1000之后，在转1000的时候还会转到0000，这样就产生了死循环。\",\"没有终止条件。按照题目要求找到target就应该返回步数。\",\"没有对deadends进行处理。这些死亡密码是不能出现的，所以在碰到这些密码的时候应该跳过。\",\"通过对上述代码进行修改：\",\"class Solution { // 将 s[j] 向上拨动⼀次 String plusOne(String s, int j) { char[] ch = s.toCharArray(); if (ch[j] == '9') ch[j] = '0'; else ch[j] += 1; return new String(ch); } // 将 s[j] 向下拨动⼀次 String minusOne(String s, int j) { char[] ch = s.toCharArray(); if (ch[j] == '0') ch[j] = '9'; else ch[j] -= 1; return new String(ch); } public int openLock(String[] deadends, String target) { // 记录需要跳过的死亡密码 Set<String> deads = new HashSet<>(); for (String s : deadends) deads.add(s); // 记录已经穷举过的密码，防⽌⾛回头路 Set<String> visited = new HashSet<>(); Queue<String> q = new LinkedList<>(); // 从起点开始启动⼴度优先搜索 int step = 0; q.offer(\\\"0000\\\"); visited.add(\\\"0000\\\"); while (!q.isEmpty()) { int sz = q.size(); /* 将当前队列中的所有节点向周围扩散 */ for (int i = 0; i < sz; i++) { String cur = q.poll(); /* 判断是否到达终点 */ if (deads.contains(cur)) // 出现死亡密码，直接跳过，开始下一个密码 continue; if (cur.equals(target)) // 返回步数 return step; /* 将⼀个节点的未遍历相邻节点加⼊队列 */ for (int j = 0; j < 4; j++) { // 向上转动 String up = plusOne(cur, j); if (!visited.contains(up)) { q.offer(up); visited.add(up); } // 向下转动 String down = minusOne(cur, j); if (!visited.contains(down)) { q.offer(down); visited.add(down); } } } /* 在这⾥增加步数 */ step++; } // 如果穷举完都没找到⽬标密码，那就是找不到了 return -1; } } \",\"优化\",\"deads集合和visited集合都是记录不合法访问的集合，可以不需要 visited 这个哈希集合，直接将遍历过的元素加到deads集合中，效果是⼀样的，可能更加优雅⼀些。\",\"BFS算法还有一种稍微高级的优化思路：双向BFS，使用双向BFS可以进一步提高算法的效率。\",\"传统的BFS和双向BFS的区别\",\"传统的BFS框架就是从起点开始向四周扩散，遇到终点时停⽌；⽽双向BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停⽌。\",\"从 Big O 表⽰法分析算法复杂度的话，它俩的最坏复杂度都是 O(N) ，但是实际上双向BFS 确实会快⼀些。\",\"按照传统BFS算法的策略，会把整棵树的节点都搜索⼀遍，最后找到target ；⽽双向BFS其实只遍历了半棵树就出现了交集，也就是找到了最短距离，明显实现了效率上的提升。\",\"双向BFS的局限性\",\"双向BFS也有局限，因为必须要知道终点在哪⾥。\",\"⽐如刚才讨论的⼆叉树最⼩⾼度的问题，⼀开始根本就不知道终点在哪⾥，也就⽆法使⽤双向BFS；但是第⼆个密码锁的问题，是可以使⽤双向BFS算法来提⾼效率。\",\"使用双向BFS进行优化：\",\"public int openLock(String[] deadends, String target) { // 记录需要跳过的死亡密码 Set<String> deads = new HashSet<>(); for (String s : deadends) deads.add(s); // ⽤集合不⽤队列，可以快速判断元素是否存在 Set<String> q1 = new HashSet<>(); Set<String> q2 = new HashSet<>(); Set<String> visited = new HashSet<>(); int step = 0; q1.add(\\\"0000\\\"); q2.add(target); while (!q1.isEmpty() && !q2.isEmpty()) { // 哈希集合在遍历的过程中不能修改，⽤ temp 存储扩散结果 Set<String> temp = new HashSet<>(); /* 将 q1 中的所有节点向周围扩散 */ for (String cur : q1) { // 不能出现死亡密码 if (deads.contains(cur)) continue; /* 判断是否到达终点 */ if (q2.contains(cur)) return step; visited.add(cur); /* 将⼀个节点的未遍历相邻节点加⼊集合 */ for (int j = 0; j < 4; j++) { String up = plusOne(cur, j); if (!visited.contains(up)) temp.add(up); String down = minusOne(cur, j); if (!visited.contains(down)) temp.add(down); } } /* 在这⾥增加步数 */ step++; // temp 相当于 q1 // 这⾥交换 q1 q2，下⼀轮 while 就是扩散 q2 q1 = q2; q2 = temp; } return -1; } \",\"不再使⽤队列，⽽是使⽤ HashSet ⽅便快速判断两个集合是否有交集。\",\"另外的⼀个技巧点就是 while 循环的最后交换 q1 和 q2 的内容，所以只要默认扩散 q1 就相当于轮流扩散 q1 和 q2 。\",\"双向BFS还有⼀个优化，就是每次将少的那个集合进行扩散，避免轮流扩散q1和q2。\",\"public int openLock(String[] deadends, String target) { // 记录需要跳过的死亡密码 Set<String> deads = new HashSet<>(); for (String s : deadends) deads.add(s); // ⽤集合不⽤队列，可以快速判断元素是否存在 Set<String> q1 = new HashSet<>(); Set<String> q2 = new HashSet<>(); Set<String> visited = new HashSet<>(); int step = 0; q1.add(\\\"0000\\\"); q2.add(target); while (!q1.isEmpty() && !q2.isEmpty()) { // 哈希集合在遍历的过程中不能修改，⽤ temp 存储扩散结果 Set<String> temp = new HashSet<>(); /* 将 q1 中的所有节点向周围扩散 */ for (String cur : q1) { // 不能出现死亡密码 if (deads.contains(cur)) continue; /* 判断是否到达终点 */ if (q2.contains(cur)) return step; visited.add(cur); /* 将⼀个节点的未遍历相邻节点加⼊集合 */ for (int j = 0; j < 4; j++) { String up = plusOne(cur, j); if (!visited.contains(up)) temp.add(up); String down = minusOne(cur, j); if (!visited.contains(down)) temp.add(down); } } /* 在这⾥增加步数 */ step++; // 下一轮进行扩散的时候，扩散较少的那个集合 // 对于temp和q2来说，将最小的那个给q1 if (temp.size() <= q2.size()) { q1 = temp; } else { q1 = q2; q2 = temp; } } return -1; } \",\"因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列 （集合）中的元素就越多；在双向BFS算法中，如果我们每次都选择⼀个较⼩的集合进⾏扩散，那么占⽤的空间增⻓速度就会慢⼀些，效率就会⾼⼀ 些。\",\"时间复杂度\",\"⽆论传统BFS还是双向BFS，⽆论做不做优化，从Big O衡量标准来看，时间复杂度都是⼀样的。因为双向BFS的代码只是更换了返回结果的方式（哈希集合是否有交集），每次进行扩散的方式不是并行扩散的，而是轮流进行扩散。\",\"LeetCode相关题目\",\"开密码锁\"]},\"214\":{\"h\":\"双指针技巧套路框架\",\"t\":[\"双指针技巧可以分为如下的两类：\",\"一类是“快慢指针”，主要解决链表中的问题，比如典型的判定链表中是否包含环。\",\"一类事“左右指针”，主要解决数组（或者字符串）中的问题，比如二分搜索。\"]},\"215\":{\"h\":\"快慢指针的常用算法\",\"t\":[\"快慢指针一般会初始化指向链表的头节点head，前进时快指针fast在前，慢指针slow在后。\"]},\"216\":{\"h\":\"判定链表中是否含有环\",\"t\":[\"链表的特点是每个节点只知道下一个节点，所以一个指针是无法判断链表中是否含有环的。\",\"如果链表中不含环，那么这个指针最终会遇到空指针null，表示链表到头了，可以判断当前链表是不含有环的。\",\"boolean hasCycle(ListNode head) { while (head != null) { head = head.next; } return false; } \",\"如果链表中含有环，上述代码就会陷入死循环，因为环形链表中没有空指针null，无法判断当前链表含有环。\",\"判断单链表中是否有环，经典的算法就是使用双指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到null，说明链表不含环；如果含有环，快指针最终会和慢指针相遇，说明链表含有环。\",\"boolean hasCycle(ListNode head) { //定义快慢指针 ListNode fast, slow; //初始化快慢指针都指向头节点 fast = slow = head; while (fast != null && fast.next != null) { //快指针每次走两步 fast = fast.next.next; //慢指针每次走一步 slow = slow.next; //如果存在环，快慢指针必然会相遇 if (fast == slow) { return true; } } //循环可以停止，说明单链表中不存在环 return false; } \"]},\"217\":{\"h\":\"已知链表中含有环，返回这个环的起始位置\",\"t\":[\"ListNode detectCycle(ListNode head) { ListNode fast, slow; //快慢指针初始化 fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { break; } } //上面的代码类似于hasCycle函数 //现在fast=slow，两者相遇，说明链表存在环，并且相遇点肯定是在环内部（包括环起点）的内部的某个节点 //相遇点不可能在环外部，因为fast虽然跑得快，但是跑不出环 //先把一个指针重新指向head slow = head; //现在slow在fast后面，两者在以相同的速度跑，下一次相遇点就是环的起点 while (slow != fast) { //两个指针以相同的速度向前跑 fast = fast.next; slow = slow.next; } //slow=fast的时候，跳出循环，两个指针再次相遇 //两个指针再次相遇的那个单链表节点就是环的起点 return slow; } \",\"结论：当快慢指针相遇时，让其中任何一个指针指向头节点，然后让两个指针以相同的速度前进，再次相遇时所在的节点位置就是环的起点位置。\"]},\"218\":{\"h\":\"寻找无环单链表的中点\",\"t\":[\"最直接的思路：先遍历一遍链表，算出链表的长度n，然后再一次遍历链表，走n/2步，这样就得到了链表的中点。\",\"漂亮的思路：使用双指针，让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头的时候，慢指针就处于链表的中间位置。\",\"ListNode getMidNodeFromList(ListNode head) { ListNode fast, slow; //初始化快慢指针 fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } \",\"注意\",\"当链表长度为奇数的时候，slow恰巧停留在中间位置；当链表长度为偶数的时候，slow最终的位置是中间偏右。\",\"寻找链表中点作用\",\"寻找链表中点的一个重要作用是对链表进行归并排序，可以尝试参考数组的归并排序写出链表的归并排序。\"]},\"219\":{\"h\":\"寻找单链表的倒数第K个元素\",\"t\":[\"使用快慢指针，让快指针先走k步，然后快慢指针开始以相同速率前进，这样当快指针到链表末尾的时候，慢指针所在的位置就是链表倒数第k个节点（为了简化，假设k不会超过链表长度）。\",\"ListNode findKNodeFromListEnd(ListNode head, int k) { ListNode fast, slow; fast = slow = head; //快指针先走k步 while (k != 0) { fast = fast.next; k--; } //快慢指针以相同的速率跑 while (fast != null) { slow = slow.next; fast = fast.next; } //此时slow所在的节点就是倒数第k个节点 return slow; } \",\"LeetCode相关题目：\",\"剑指Offer22.链表中倒数第k个节点\",\"面试题02.02.返回倒数第k个节点\",\"剑指OfferII022.链表中环的入口节点\"]},\"220\":{\"h\":\"左右指针的常用算法\",\"t\":[\"左右指针一般运用在数组问题中，实际就是两个索引值，一般初始化规则如下：\",\"left=0;\",\"right=length(array)-1;\"]},\"221\":{\"h\":\"二分搜索\",\"t\":[\"后续会有二分搜索的细节描述，在此给出最简单的二分查找算法，旨在突出其双指针特性。\",\"/*** * @Description: 二分查找算法，默认nums数组升序 * @Author: Mr.Tong */ int binarySearch(int[] nums, int target) { //初始化左右指针 int left = 0; int right = nums.length - 1; while (left <= right) { int mid = (left + right) / 2; if (nums[mid] == target) { return mid;//找到就返回其索引 } else if (nums[mid] < target) { left = mid + 1; } else if (nums[mid] > target) { right = mid - 1; } } //找不到直接返回-1 return -1; } \"]},\"222\":{\"h\":\"两数之和\",\"t\":[\"输入一个已按照升序排列的有序数组nums和一个目标值target，在nums中找到两个数使得它们相加之和等于target，请返回这两个数的索引（可以假设这两个数一定存在，索引从1开始）。\",\"只要数组有序，就应该想到使用双指针技巧，通过sum的大小来调节left和right的移动。\",\"/*** * @Description: 两数之和 * @Author: Mr.Tong */ int[] twoSum(int[] nums, int target) { //左右指针初始化 int left = 0; int right = nums.length - 1; while (left < right) { int sum = nums[left] + nums[right]; if (sum == target) { return new int[]{left + 1, right + 1}; } else if (sum > target) { //让sum小一点 right--; } else if (sum < target) { //让sum大一点 left++; } } //找不到 return new int[]{-1, -1}; } \"]},\"223\":{\"h\":\"反转数组\",\"t\":[\"虽然很多编程语言提供了原地反转数组的API，但是仍然要懂得其原理。\",\"/*** * @Description: 原地反转数据 * @Author: Mr.Tong */ void reverse(int[] nums) { //初始化左右指针 int left = 0; int right = nums.length - 1; while (left < right) { //交换左右两个指针指向的数据 int tmp = nums[left]; nums[left] = nums[right]; nums[right] = tmp; //指针移动 left++; right--; } } \"]},\"224\":{\"h\":\"滑动窗口算法\",\"t\":[\"滑动窗口算法是双指针技巧的最高境界，严格讲，它是快慢指针在数组（字符串）上的应用。若掌握该算法，可以解决一大类字符串匹配问题。该部分比前面稍微复杂，可以查看后续的滑动窗口算法框架。\"]},\"225\":{\"h\":\"二分搜索算法\",\"t\":[\"一个笑话\",\"有一天阿东到图书馆借了N本书，出图书馆的时候，警报响了，于是保安把阿东拦下， 要检查哪本书没有登记出借。阿东正准备把每一本书放在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分搜索都不会吗？\",\"于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成 两堆。最终，检测了logN次之后，保安成功地找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。\",\"从此，图书馆丢了N-1本书。\",\"二分搜索并不简单，Knuth“大佬”（发明KMP算法的那位）是这么评价二分搜索的：\",\"Although the basic idea of binary search is comparatively straightforward, the details canbe surprisingly tricky.\",\"说人话就是：思路很简单，细节是魔鬼。\",\"其细节在于到底要给mid加1还是减1，while里面到底是<=还是<。\"]},\"226\":{\"h\":\"二分搜索框架\",\"t\":[\"基础框架如下所示，后面的二分搜索的变形都是基于该框架。\",\"/*** * @Description: 二分搜索框架 * @Author: Mr.Tong */ int binarySearch(int[] nums, int target) { int left = 0; int right =...; while (...){ int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] < target) { left =...; } else if (nums[mid] > target) { right =...; } } return ...; } \",\"注意：\",\"不要出现else，而是使用else-if考虑到所有的情况，可以清楚展现细节。\",\"...标记的地方都是出现细节问题的地方。\",\"int mid = left + (right - left) / 2是为了防止溢出。\"]},\"227\":{\"h\":\"寻找一个数（基本的二分搜索）\",\"t\":[\"需求：在一个有序数组中查找一个数，如果找到就返回其索引，如果找不到就返回-1。\",\"int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1;//注意 while (left <= right) {//注意 int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] < target) { left = mid + 1;//注意 } else if (nums[mid] > target) { right = mid - 1;//注意 } } //循环跳出，找不到就返回-1 return -1; } \",\"问题一：为什么while循环的条件中是<=，而不是<？\",\"问题二：为什么left = mid + 1和right = mid - 1？有的代码是right = mid或者left = mid，没有这些加加减减，到底是怎么回事？怎么判断？\",\"问题三：该算法有什么缺陷？\"]},\"228\":{\"h\":\"寻找左侧边界的二分搜索\"},\"229\":{\"h\":\"寻找右侧边界的二分搜索\"},\"230\":{\"h\":\"逻辑统一\"},\"231\":{\"h\":\"滑动窗口算法变成默写题\"},\"232\":{\"h\":\"最小覆盖子串\"},\"233\":{\"h\":\"字符串排列\"},\"234\":{\"h\":\"找所有字母异位词\"},\"235\":{\"h\":\"最长无重复子串\"},\"236\":{\"c\":[\"算法\",\"数据结构\"]},\"237\":{\"c\":[\"算法\",\"数据结构\"]},\"238\":{\"h\":\"算法思维\"},\"239\":{\"c\":[\"算法\",\"数据结构\"]},\"240\":{\"c\":[\"算法\",\"数据结构\"]},\"241\":{\"h\":\"高频面试\"},\"242\":{\"h\":\"如何高效寻找素数\",\"t\":[\"素数\",\"如果一个数只能被1和它本身整除，那么这个数就是素数。\",\"实现一个函数，输入一个正整数n，函数返回区间[2,n)中素数的个数。\",\"函数签名如下：int countPrimes(int n)\"]},\"243\":{\"h\":\"一般实现\",\"t\":[\"/*** * @Description: [2, n)素数的个数 * @Author: Mr.Tong */ int countPrimes(int n) { int count = 0; for (int i = 2; i < n; i++) { if (isPrime(i)) { count++; } } return count; } /*** * @Description: 判断一个数是不是素数 * @Author: Mr.Tong */ boolean isPrime(int n) { for (int i = 2; i < n; i++) { if (n % i == 0) { return false; } } return true; } \",\"分析问题：该算法的时间复杂度为O(n^2)，使用isPrime函数一个一个的进行判断不是高效的做法，而且就算是使用isPrime函数，也是存在计算冗余的。\"]},\"244\":{\"h\":\"稍加优化\",\"t\":[\"isPrime函数是可以进行优化的，优化代码如下：\",\"/*** * @Description: 判断一个数是不是素数 * @Author: Mr.Tong */ boolean isPrime(int n) { for (int i = 2; i * i <= n; i++) { if (n % i == 0) { return false; } } return true; } \",\"i不需要遍历到n，只需要遍历到sqrt(n)即可，这是因为sqrt(n)是反转临界点，一个数等于两个数相乘，中间的临界点就是sqrt(n)*sqrt(n)，[2,sqrt(n)]之间如果找不到可整除的因子，那么[sqrt(n),n]之间也肯定找不到可整除的因子了，因为是后半部分是前半部分的因子交换所得，这就叫做“乘法因子的交换性”。\"]},\"245\":{\"h\":\"高效实现\",\"t\":[\"使用“筛数法”进行实现，2是素数，那么在n的范围中，2的倍数就不再是素数了；3是素数，那么在n的范围中，3的倍数就不再是素数了。\",\"/*** * @Description: 筛数法实现求解素数个数 * @Author: Mr.Tong */ int countPrimes(int n) { //各个数的标记 boolean[] isPrime = new boolean[n]; //填充都为true Arrays.fill(isPrime, true); //从头开始，把所有n范围内的素数的倍数都标记为false for (int i = 2; i < n; i++) { //如果i为素数 if (isPrime[i]) { //实际标记过程 for (int j = 2 * i; j < n; j += i) { isPrime[j] = false; } } } //求解true的个数 int count = 0; for (int i = 0; i < isPrime.length; i++) { if (isPrime[i]) count++; } //最后结果去掉两个，因为0和1也都是true return count - 2; } \",\"上述的过程仍然是可以进行优化的，优化的地方主要有两点：\",\"外层循环：因为乘法因子的对称性，遍历范围可以设置为[2,sqrt(n)]。\",\"内层循环：j每次都从2开始存在冗余计算，只需要从i的平方开始标记即可。\",\"重新优化后的代码：\",\"/*** * @Description: 筛数法实现求解素数个数 * @Author: Mr.Tong */ int countPrimes(int n) { //各个数的标记 boolean[] isPrime = new boolean[n]; //填充都为true Arrays.fill(isPrime, true); //从头开始，把所有n范围内的素数的倍数都标记为false for (int i = 2; i * i <= n; i++) { //如果i为素数 if (isPrime[i]) { //实际标记过程 for (int j = i * i; j < n; j += i) { isPrime[j] = false; } } } //求解true的个数 int count = 0; for (int i = 0; i < isPrime.length; i++) { if (isPrime[i]) count++; } //最后结果去掉两个，因为0和1也都是true return count - 2; } \",\"这样的算法有一个名字，叫做Sieve of Eratosthenes，该算法的时间复杂度为O(NloglogN)。\"]},\"246\":{\"h\":\"如何高效进行模幂运算\"},\"247\":{\"h\":\"如何处理数组指数\"},\"248\":{\"h\":\"如何处理mod运算\"},\"249\":{\"h\":\"如何高效求幂\"},\"250\":{\"h\":\"如何运用二分搜索算法\"},\"251\":{\"h\":\"如何高效解决接雨水问题\"},\"252\":{\"h\":\"如何去除有序数组的重复元素\"},\"253\":{\"h\":\"如何寻找最长回文子串\"},\"254\":{\"h\":\"如何运用贪心思想玩跳跃游戏\"},\"255\":{\"h\":\"如何运用贪心算法做时间管理\"},\"256\":{\"h\":\"如何判定括号合法性\"},\"257\":{\"h\":\"如何调度考生的座位\"},\"258\":{\"h\":\"Union-Find算法详解\"},\"259\":{\"h\":\"Union-Find算法应用\"},\"260\":{\"h\":\"一行代码就能解决的算法题\"},\"261\":{\"h\":\"Nim游戏\"},\"262\":{\"h\":\"石子游戏\"},\"263\":{\"h\":\"电灯开关问题\"},\"264\":{\"c\":[\"算法\",\"数据结构\"]},\"265\":{\"c\":[\"算法\",\"数据结构\"]},\"266\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"267\":{\"h\":\"目录1\"}},\"dirtCount\":0,\"index\":[[\"电灯开关问题\",{\"0\":{\"263\":1}}],[\"石子游戏\",{\"0\":{\"262\":1}}],[\"叫做sieve\",{\"1\":{\"245\":1}}],[\"内层循环\",{\"1\":{\"245\":1}}],[\"内存空间必须一次性分配足\",{\"1\":{\"202\":1}}],[\"外层循环\",{\"1\":{\"245\":1}}],[\"填充都为true\",{\"1\":{\"245\":2}}],[\"各个数的标记\",{\"1\":{\"245\":2}}],[\"各种数据结构的遍历+访问无非就是两种形式\",{\"1\":{\"203\":1}}],[\"各种数据结构在不同的应用场景下尽可能高效地进行增删改查\",{\"1\":{\"203\":1}}],[\"筛数法实现求解素数个数\",{\"1\":{\"245\":2}}],[\"筛数法\",{\"1\":{\"245\":1}}],[\"乘法因子的交换性\",{\"1\":{\"244\":1}}],[\"乘法的结果可能导致溢出\",{\"1\":{\"141\":1}}],[\"之间也肯定找不到可整除的因子了\",{\"1\":{\"244\":1}}],[\"之间如果找不到可整除的因子\",{\"1\":{\"244\":1}}],[\"之间的数字\",{\"1\":{\"134\":1}}],[\"稍加优化\",{\"0\":{\"244\":1}}],[\"素数的个数\",{\"1\":{\"243\":1}}],[\"素数\",{\"1\":{\"242\":1}}],[\"到底是怎么回事\",{\"1\":{\"227\":1}}],[\"标记的地方都是出现细节问题的地方\",{\"1\":{\"226\":1}}],[\"标题显示在右侧\",{\"0\":{\"1\":1}}],[\"细节是魔鬼\",{\"1\":{\"225\":1}}],[\"说人话就是\",{\"1\":{\"225\":1}}],[\"说明单链表中不存在环\",{\"1\":{\"216\":1}}],[\"说明链表存在环\",{\"1\":{\"217\":1}}],[\"说明链表含有环\",{\"1\":{\"216\":1}}],[\"说明链表不含环\",{\"1\":{\"216\":1}}],[\"说明\",{\"1\":{\"130\":1,\"131\":1}}],[\"发明kmp算法的那位\",{\"1\":{\"225\":1}}],[\"发现expectedmodcount的值为1\",{\"1\":{\"76\":1}}],[\"发现cursor的值为1\",{\"1\":{\"76\":1}}],[\"发现是正常的\",{\"1\":{\"76\":1}}],[\"露出了得意和嘲讽的笑容\",{\"1\":{\"225\":1}}],[\"检测了logn次之后\",{\"1\":{\"225\":1}}],[\"于是阿东背着剩下的书走了\",{\"1\":{\"225\":1}}],[\"于是再把这堆书分成\",{\"1\":{\"225\":1}}],[\"于是保安把书分成两堆\",{\"1\":{\"225\":1}}],[\"于是保安把阿东拦下\",{\"1\":{\"225\":1}}],[\"报警器响\",{\"1\":{\"225\":1}}],[\"阿东正准备把每一本书放在报警器下过一下\",{\"1\":{\"225\":1}}],[\"警报响了\",{\"1\":{\"225\":1}}],[\"出图书馆的时候\",{\"1\":{\"225\":1}}],[\"出现死亡密码\",{\"1\":{\"213\":1}}],[\"若掌握该算法\",{\"1\":{\"224\":1}}],[\"若符号为负\",{\"1\":{\"131\":1}}],[\"若符号为正\",{\"1\":{\"131\":1}}],[\"字符串排列\",{\"0\":{\"233\":1}}],[\"字符串\",{\"1\":{\"224\":1}}],[\"字符的ascii码其实就是数字\",{\"1\":{\"132\":1}}],[\"严格讲\",{\"1\":{\"224\":1}}],[\"滑动窗口算法变成默写题\",{\"0\":{\"231\":1}}],[\"滑动窗口算法是双指针技巧的最高境界\",{\"1\":{\"224\":1}}],[\"滑动窗口算法\",{\"0\":{\"224\":1}}],[\"指针移动\",{\"1\":{\"223\":1}}],[\"交换左右两个指针指向的数据\",{\"1\":{\"223\":1}}],[\"虽然很多编程语言提供了原地反转数组的api\",{\"1\":{\"223\":1}}],[\"虽然大得离谱\",{\"1\":{\"137\":1}}],[\"索引从1开始\",{\"1\":{\"222\":1}}],[\"找所有字母异位词\",{\"0\":{\"234\":1}}],[\"找不到就返回\",{\"1\":{\"227\":1}}],[\"找不到\",{\"1\":{\"222\":1}}],[\"找不到直接返回\",{\"1\":{\"221\":1}}],[\"找到就返回其索引\",{\"1\":{\"221\":1}}],[\"找到所有数组中消失的数字\",{\"1\":{\"143\":1}}],[\"找到那个没有元素对应的索引\",{\"1\":{\"143\":1}}],[\"找到这个重复对应的索引\",{\"1\":{\"143\":1}}],[\"找到重复的元素\",{\"1\":{\"143\":1}}],[\"找到之后直接返回结果5\",{\"1\":{\"137\":1}}],[\"初始化左右指针\",{\"1\":{\"221\":1,\"223\":1}}],[\"初始化快慢指针\",{\"1\":{\"218\":1}}],[\"初始化快慢指针都指向头节点\",{\"1\":{\"216\":1}}],[\"旨在突出其双指针特性\",{\"1\":{\"221\":1}}],[\"剑指offerii022\",{\"1\":{\"219\":1}}],[\"剑指offer22\",{\"1\":{\"219\":1}}],[\"面试题02\",{\"1\":{\"219\":1}}],[\"面向对象\",{\"0\":{\"65\":1}}],[\"让第一堆过一下报警器\",{\"1\":{\"225\":1}}],[\"让sum大一点\",{\"1\":{\"222\":1}}],[\"让sum小一点\",{\"1\":{\"222\":1}}],[\"让快指针先走k步\",{\"1\":{\"219\":1}}],[\"让快指针一次前进两步\",{\"1\":{\"218\":1}}],[\"让其中任何一个指针指向头节点\",{\"1\":{\"217\":1}}],[\"漂亮的思路\",{\"1\":{\"218\":1}}],[\"走n\",{\"1\":{\"218\":1}}],[\"走的步数是最少的\",{\"1\":{\"212\":1}}],[\"跳出循环\",{\"1\":{\"217\":1}}],[\"跳转\",{\"1\":{\"1\":1}}],[\"包括环起点\",{\"1\":{\"217\":1}}],[\"已知链表中含有环\",{\"0\":{\"217\":1}}],[\"已经确定是optional类型的\",{\"1\":{\"44\":1}}],[\"慢指针所在的位置就是链表倒数第k个节点\",{\"1\":{\"219\":1}}],[\"慢指针就处于链表的中间位置\",{\"1\":{\"218\":1}}],[\"慢指针一次前进一步\",{\"1\":{\"218\":1}}],[\"慢指针每次走一步\",{\"1\":{\"216\":1}}],[\"慢指针slow在后\",{\"1\":{\"215\":1}}],[\"定义快慢指针\",{\"1\":{\"216\":1}}],[\"跑得快的那个指针最终会遇到null\",{\"1\":{\"216\":1}}],[\"经典的算法就是使用双指针\",{\"1\":{\"216\":1}}],[\"判定链表中是否含有环\",{\"0\":{\"216\":1}}],[\"判断单链表中是否有环\",{\"1\":{\"216\":1}}],[\"判断是否到达终点\",{\"1\":{\"213\":4}}],[\"判断当前节点是不是终点\",{\"1\":{\"212\":1}}],[\"判断当前节点是否被访问过\",{\"1\":{\"211\":1}}],[\"判断回文单链表\",{\"0\":{\"186\":1}}],[\"判断bst的合法性\",{\"0\":{\"161\":1}}],[\"判断一个数是不是素数\",{\"1\":{\"243\":1,\"244\":1}}],[\"判断一个数是不是\",{\"1\":{\"133\":1}}],[\"判断两个数是否异号\",{\"1\":{\"132\":1}}],[\"判断该值的合法性必须是大于等于0\",{\"1\":{\"73\":1}}],[\"快指针先走k步\",{\"1\":{\"219\":1}}],[\"快指针每次走两步\",{\"1\":{\"216\":1}}],[\"快指针最终会和慢指针相遇\",{\"1\":{\"216\":1}}],[\"快慢指针以相同的速率跑\",{\"1\":{\"219\":1}}],[\"快慢指针初始化\",{\"1\":{\"217\":1}}],[\"快慢指针必然会相遇\",{\"1\":{\"216\":1}}],[\"快慢指针一般会初始化指向链表的头节点head\",{\"1\":{\"215\":1}}],[\"快慢指针的常用算法\",{\"0\":{\"215\":1}}],[\"快慢指针\",{\"1\":{\"214\":1}}],[\"快速的进行幂运算\",{\"1\":{\"142\":1}}],[\"快速幂也应当进行取模\",{\"1\":{\"142\":1}}],[\"快速幂不仅本身非常常见\",{\"1\":{\"142\":1}}],[\"快速幂\",{\"0\":{\"142\":1},\"1\":{\"142\":1}}],[\"快速进行mod运算公式\",{\"1\":{\"141\":1}}],[\"双指针技巧可以分为如下的两类\",{\"1\":{\"214\":1}}],[\"双指针技巧套路框架\",{\"0\":{\"214\":1}}],[\"双向bfs还有⼀个优化\",{\"1\":{\"213\":1}}],[\"双向bfs也有局限\",{\"1\":{\"213\":1}}],[\"双向bfs的局限性\",{\"1\":{\"213\":1}}],[\"双向bfs\",{\"1\":{\"213\":1}}],[\"哈希集合是否有交集\",{\"1\":{\"213\":1}}],[\"哈希集合在遍历的过程中不能修改\",{\"1\":{\"213\":2}}],[\"⽆论做不做优化\",{\"1\":{\"213\":1}}],[\"⽆论传统bfs还是双向bfs\",{\"1\":{\"213\":1}}],[\"些\",{\"1\":{\"213\":1}}],[\"集合\",{\"1\":{\"213\":2}}],[\"集合类关系图\",{\"0\":{\"93\":1}}],[\"扩散之后新的队列\",{\"1\":{\"213\":1}}],[\"扩散较少的那个集合\",{\"1\":{\"213\":1}}],[\"扩容操作最终是通过grow\",{\"1\":{\"76\":1}}],[\"扩容1\",{\"1\":{\"75\":1}}],[\"下一次相遇点就是环的起点\",{\"1\":{\"217\":1}}],[\"下一轮进行扩散的时候\",{\"1\":{\"213\":1}}],[\"下⼀轮\",{\"1\":{\"213\":1}}],[\"循环跳出\",{\"1\":{\"227\":1}}],[\"循环可以停止\",{\"1\":{\"216\":1}}],[\"循环的最后交换\",{\"1\":{\"213\":1}}],[\"循环遍历\",{\"1\":{\"137\":1}}],[\"另外的⼀个技巧点就是\",{\"1\":{\"213\":1}}],[\"另一个是remove\",{\"1\":{\"79\":1}}],[\"另一个示例\",{\"1\":{\"47\":1}}],[\"⽅便快速判断两个集合是否有交集\",{\"1\":{\"213\":1}}],[\"⽽是使⽤\",{\"1\":{\"213\":1}}],[\"⽽双向bfs其实只遍历了半棵树就出现了交集\",{\"1\":{\"213\":1}}],[\"⽽双向bfs\",{\"1\":{\"213\":1}}],[\"⽤\",{\"1\":{\"213\":2}}],[\"⽤集合不⽤队列\",{\"1\":{\"213\":2}}],[\"⼀开始根本就不知道终点在哪⾥\",{\"1\":{\"213\":1}}],[\"⽐如刚才讨论的⼆叉树最⼩⾼度的问题\",{\"1\":{\"213\":1}}],[\"明显实现了效率上的提升\",{\"1\":{\"213\":1}}],[\"确实会快⼀些\",{\"1\":{\"213\":1}}],[\"表⽰法分析算法复杂度的话\",{\"1\":{\"213\":1}}],[\"表示链表到头了\",{\"1\":{\"216\":1}}],[\"表示操作符左边的值会移动由右边数值指定的位数\",{\"1\":{\"131\":1}}],[\"表示底层数组的实际大小\",{\"1\":{\"70\":1}}],[\"遇到终点时停⽌\",{\"1\":{\"213\":1}}],[\"传统的bfs框架就是从起点开始向四周扩散\",{\"1\":{\"213\":1}}],[\"传统的bfs和双向bfs的区别\",{\"1\":{\"213\":1}}],[\"可能更加优雅⼀些\",{\"1\":{\"213\":1}}],[\"可以清楚展现细节\",{\"1\":{\"226\":1}}],[\"可以查看后续的滑动窗口算法框架\",{\"1\":{\"224\":1}}],[\"可以解决一大类字符串匹配问题\",{\"1\":{\"224\":1}}],[\"可以假设这两个数一定存在\",{\"1\":{\"222\":1}}],[\"可以尝试参考数组的归并排序写出链表的归并排序\",{\"1\":{\"218\":1}}],[\"可以判断当前链表是不含有环的\",{\"1\":{\"216\":1}}],[\"可以快速判断元素是否存在\",{\"1\":{\"213\":2}}],[\"可以不需要\",{\"1\":{\"213\":1}}],[\"可以怎么做\",{\"1\":{\"142\":1}}],[\"可以把递归改写为循环\",{\"1\":{\"142\":1}}],[\"可以非常大\",{\"1\":{\"139\":1}}],[\"可以作为搜索的上界\",{\"1\":{\"137\":1}}],[\"可以用二分查找进行降维打击\",{\"1\":{\"137\":1}}],[\"可以用它来实现优先队列\",{\"1\":{\"101\":1}}],[\"可以用它来实现双向队列\",{\"1\":{\"101\":1}}],[\"可以提供\",{\"1\":{\"136\":1}}],[\"可以提供不止一个因子\",{\"1\":{\"136\":1}}],[\"可以提供两个因子\",{\"1\":{\"136\":1}}],[\"可以提供两个\",{\"1\":{\"136\":1}}],[\"可以提供一个\",{\"1\":{\"136\":4}}],[\"可以消除最后一个\",{\"1\":{\"133\":1}}],[\"可以很快的根据下标查找元素\",{\"1\":{\"100\":1}}],[\"可以使其有序\",{\"1\":{\"99\":1}}],[\"可以相同也可以不同\",{\"1\":{\"59\":1}}],[\"可以直接调用super\",{\"1\":{\"59\":1}}],[\"可以说老虎是动物\",{\"1\":{\"59\":1}}],[\"可以自定义业务逻辑功能说明语句抛出异常\",{\"1\":{\"37\":1}}],[\"效果是⼀样的\",{\"1\":{\"213\":1}}],[\"效率就会⾼⼀\",{\"1\":{\"213\":1}}],[\"效率较高\",{\"1\":{\"202\":3}}],[\"效率比较高\",{\"1\":{\"76\":1,\"202\":1}}],[\"优化的地方主要有两点\",{\"1\":{\"245\":1}}],[\"优化代码如下\",{\"1\":{\"244\":1}}],[\"优化\",{\"1\":{\"213\":1}}],[\"优化空间复杂度\",{\"0\":{\"187\":1}}],[\"优化空间复杂度到o\",{\"1\":{\"143\":1}}],[\"防⽌⾛回头路\",{\"1\":{\"213\":1}}],[\"添加根节点\",{\"1\":{\"213\":1}}],[\"添加元素到index位置\",{\"1\":{\"76\":1}}],[\"⼜让求最短距离\",{\"1\":{\"213\":1}}],[\"仔细想想\",{\"1\":{\"213\":1}}],[\"仔细分析\",{\"1\":{\"140\":1,\"141\":1,\"142\":2}}],[\"种密码作为基础\",{\"1\":{\"213\":1}}],[\"种可能\",{\"1\":{\"213\":1}}],[\"穷举出所有可能\",{\"1\":{\"213\":1}}],[\"穷举\",{\"1\":{\"213\":1}}],[\"穷举所有可能的密码组合\",{\"1\":{\"213\":2}}],[\"打开转盘锁\",{\"1\":{\"213\":1}}],[\"打印出所有可能的密码\",{\"1\":{\"213\":1}}],[\"打印结果\",{\"1\":{\"130\":1}}],[\"打印结果为\",{\"1\":{\"130\":3,\"131\":2}}],[\"打印键值对\",{\"1\":{\"104\":1}}],[\"解开密码锁的最少次数\",{\"0\":{\"213\":1}}],[\"解决办法是将其转为long类型\",{\"1\":{\"142\":1}}],[\"解决这种结构的深层嵌套路径是有点麻烦的\",{\"1\":{\"47\":1}}],[\"图书馆丢了n\",{\"1\":{\"225\":1}}],[\"图中某个节点向四周扩散具体到二叉树\",{\"1\":{\"212\":1}}],[\"图等都是属于具体的上层建筑\",{\"1\":{\"202\":1}}],[\"路径之和\",{\"1\":{\"212\":1}}],[\"节点数为n\",{\"1\":{\"212\":1}}],[\"节点类型的队列\",{\"1\":{\"211\":1}}],[\"既然bfs那么好\",{\"1\":{\"212\":1}}],[\"既然底层是一个数组arraylist的set\",{\"1\":{\"77\":1}}],[\"齐头并进\",{\"1\":{\"212\":1}}],[\"整个算法过程通过画图可以很容易的理解\",{\"1\":{\"212\":1}}],[\"理解\",{\"1\":{\"212\":1}}],[\"更新步数\",{\"1\":{\"212\":1}}],[\"终点是什么\",{\"1\":{\"212\":1}}],[\"起点是什么\",{\"1\":{\"212\":1}}],[\"需求\",{\"1\":{\"212\":1,\"227\":1}}],[\"需要先重新分配一块更大的空间\",{\"1\":{\"202\":1}}],[\"需要先对元素进行移动\",{\"1\":{\"76\":1}}],[\"需要多大才能一定不会被取到呢\",{\"1\":{\"137\":1}}],[\"需要将其包装成对象类型后\",{\"1\":{\"95\":1}}],[\"需要将删除点之后的元素向前移动一个位置\",{\"1\":{\"79\":1}}],[\"需要注意的是为了让gc起作用\",{\"1\":{\"79\":1}}],[\"需要扩容\",{\"1\":{\"75\":1}}],[\"泛指与cur相邻的所有节点\",{\"1\":{\"211\":1}}],[\"泛型中的类型在使用时指定\",{\"1\":{\"59\":1}}],[\"泛型方法\",{\"1\":{\"59\":2}}],[\"泛型接口\",{\"1\":{\"59\":1}}],[\"泛型的本质是为了参数化类型\",{\"1\":{\"59\":1}}],[\"变量解释\",{\"1\":{\"211\":1}}],[\"变成\",{\"1\":{\"133\":2}}],[\"加入相邻节点到队列中\",{\"1\":{\"211\":1}}],[\"加一\",{\"1\":{\"132\":1}}],[\"划重点\",{\"1\":{\"211\":2}}],[\"记录已经穷举过的密码\",{\"1\":{\"213\":1}}],[\"记录已经走过的节点\",{\"1\":{\"211\":1}}],[\"记录需要跳过的死亡密码\",{\"1\":{\"213\":3}}],[\"记录扩散的步数\",{\"1\":{\"211\":1}}],[\"记录着集合的修改次数\",{\"1\":{\"76\":1}}],[\"核心数据结构\",{\"1\":{\"211\":1,\"213\":1}}],[\"核心套路\",{\"0\":{\"200\":1}}],[\"深度优先搜索\",{\"1\":{\"210\":1}}],[\"深入理解hashmap和treemap的区别\",{\"1\":{\"108\":1}}],[\"广度优先搜索\",{\"1\":{\"210\":1}}],[\"回溯算法解题套路框架\",{\"0\":{\"206\":1}}],[\"试着从框架看问题\",{\"1\":{\"204\":1}}],[\"根据具体问题在框架上添加代码即可\",{\"1\":{\"203\":1}}],[\"根据位置不同也有两个版本\",{\"1\":{\"76\":1}}],[\"所谓的bfs本质就是解决该问题的\",{\"1\":{\"211\":1}}],[\"所谓的框架思维就是记住这些遍历框架\",{\"1\":{\"203\":1}}],[\"所以一个指针是无法判断链表中是否含有环的\",{\"1\":{\"216\":1}}],[\"所以只要默认扩散\",{\"1\":{\"213\":1}}],[\"所以只要将elementdata的数据拷贝出来即可\",{\"1\":{\"83\":1}}],[\"所以效率也比较高\",{\"1\":{\"202\":1}}],[\"所以效率不高\",{\"1\":{\"202\":4}}],[\"所以不用担心会走回头路\",{\"1\":{\"212\":1}}],[\"所以不能随机访问\",{\"1\":{\"202\":1}}],[\"所以不存在数组的扩容问题\",{\"1\":{\"202\":1}}],[\"所以数组如果要扩容\",{\"1\":{\"202\":1}}],[\"所以需要修改部分的值才能得到正确结果\",{\"1\":{\"143\":1}}],[\"所以取相反数是不变的\",{\"1\":{\"142\":1}}],[\"所以其实只需要判断阶乘结果末尾恰好有\",{\"1\":{\"137\":1}}],[\"所以总体的时间复杂度就是\",{\"1\":{\"137\":1}}],[\"所以总是能把成对儿的数字消去\",{\"1\":{\"134\":1}}],[\"所以使用long类型\",{\"1\":{\"136\":1}}],[\"所以使用位运算符时\",{\"1\":{\"129\":1}}],[\"所以\",{\"1\":{\"136\":1,\"137\":1}}],[\"所以最后异或的结果就是只出现一次的元素\",{\"1\":{\"134\":1}}],[\"所以可以将遍历方式扩展到n叉树\",{\"1\":{\"203\":1}}],[\"所以可以想想办法如何降低空间复杂度\",{\"1\":{\"143\":1}}],[\"所以可以使用递归进行求解\",{\"1\":{\"141\":1}}],[\"所以可以用一个循环不停地消除\",{\"1\":{\"133\":1}}],[\"所以可以强转\",{\"1\":{\"44\":1}}],[\"所以treemap是排序的而hashmap不是\",{\"1\":{\"108\":1}}],[\"所以就直接报出并发修改异常了\",{\"1\":{\"76\":1}}],[\"所以还是true\",{\"1\":{\"76\":1}}],[\"所以hasnext为true\",{\"1\":{\"76\":1}}],[\"所以这样做会很危险\",{\"1\":{\"76\":1}}],[\"所以这里的数组是一个object数组\",{\"1\":{\"70\":1}}],[\"所以理所当然会抛异常\",{\"1\":{\"76\":1}}],[\"所以在碰到这些密码的时候应该跳过\",{\"1\":{\"213\":1}}],[\"所以在测试用例x=1\",{\"1\":{\"142\":1}}],[\"所以在取出集合元素时需要人为的强制类型转化到具体的目标类型\",{\"1\":{\"59\":1}}],[\"所以在方法名\",{\"1\":{\"59\":1}}],[\"所以上面写的测试代码稍显复杂\",{\"1\":{\"36\":1}}],[\"兼具迭代和递归结构\",{\"1\":{\"203\":1}}],[\"迭代遍历p\",{\"1\":{\"203\":1}}],[\"迭代访问arr\",{\"1\":{\"203\":1}}],[\"迭代器都可以实现\",{\"1\":{\"104\":1}}],[\"迭代器的工作原理如下图所示\",{\"1\":{\"98\":1}}],[\"迭代器\",{\"1\":{\"98\":1}}],[\"迭代器很快就会完全失败\",{\"1\":{\"89\":1}}],[\"线性\",{\"1\":{\"203\":1}}],[\"任何的数据结构其基本操作就是遍历+访问\",{\"1\":{\"203\":1}}],[\"综上所述\",{\"1\":{\"202\":1}}],[\"查询和修改元素需要从头节点开始进行遍历\",{\"1\":{\"202\":2}}],[\"查询和修改元素就在头节点不需要进行遍历\",{\"1\":{\"202\":1}}],[\"查找只出现一次的元素\",{\"1\":{\"134\":1}}],[\"查找某个元素的时间复杂度是o\",{\"1\":{\"100\":1}}],[\"查找效率高\",{\"1\":{\"99\":1}}],[\"查找的时间复杂度为\",{\"1\":{\"99\":1}}],[\"你连二分搜索都不会吗\",{\"1\":{\"225\":1}}],[\"你怎么做\",{\"1\":{\"213\":1}}],[\"你无法根据一个索引算出对应元素的地址\",{\"1\":{\"202\":1}}],[\"你只要找到一个数\",{\"1\":{\"137\":1}}],[\"靠指针指向下一个元素的位置\",{\"1\":{\"202\":1}}],[\"链表中环的入口节点\",{\"1\":{\"219\":1}}],[\"链表中倒数第k个节点\",{\"1\":{\"219\":1}}],[\"链表的特点是每个节点只知道下一个节点\",{\"1\":{\"216\":1}}],[\"链表遍历框架\",{\"1\":{\"203\":1}}],[\"链表在开始\",{\"1\":{\"202\":1}}],[\"链表因为元素不连续\",{\"1\":{\"202\":1}}],[\"链表\",{\"1\":{\"202\":1}}],[\"链式存储\",{\"1\":{\"202\":1}}],[\"增加和删除元素只需要操作指针\",{\"1\":{\"202\":3}}],[\"增加和删除位置不需要挪动元素\",{\"1\":{\"202\":1}}],[\"增加和删除都需要挪动元素\",{\"1\":{\"202\":2}}],[\"增强for循环\",{\"1\":{\"104\":1}}],[\"开密码锁\",{\"1\":{\"213\":1}}],[\"开始下一个密码\",{\"1\":{\"213\":1}}],[\"开始位置\",{\"1\":{\"202\":2}}],[\"开发必备\",{\"0\":{\"11\":1}}],[\"树\",{\"1\":{\"202\":1}}],[\"堆\",{\"1\":{\"202\":1}}],[\"队列中的数据已经更新完\",{\"1\":{\"213\":1}}],[\"队列中的数据已经更新为新的数据\",{\"1\":{\"211\":1}}],[\"队列中每次都会存储二叉树一层的节点\",{\"1\":{\"212\":1}}],[\"队列中所有节点都向前迈了一步\",{\"1\":{\"212\":1}}],[\"队列中所有节点向四周扩散\",{\"1\":{\"212\":1}}],[\"队列非空执行\",{\"1\":{\"211\":1}}],[\"队列\",{\"1\":{\"202\":1,\"213\":2}}],[\"队列和双向队列\",{\"1\":{\"100\":1}}],[\"栈\",{\"1\":{\"202\":1}}],[\"养成\",{\"1\":{\"201\":1}}],[\"框架如下\",{\"1\":{\"211\":1}}],[\"框架思维\",{\"1\":{\"201\":1}}],[\"框架\",{\"1\":{\"201\":1,\"213\":1}}],[\"套路\",{\"1\":{\"201\":1}}],[\"学习解决问题的思路\",{\"1\":{\"201\":1}}],[\"学习算法和刷题的框架思维\",{\"0\":{\"201\":1}}],[\"学习map顶层接口\",{\"1\":{\"103\":1}}],[\"纯递归反转链表\",{\"0\":{\"189\":1}}],[\"秀操作\",{\"0\":{\"189\":1,\"194\":1}}],[\"搭建解题框架\",{\"0\":{\"182\":1}}],[\"单调队列\",{\"0\":{\"181\":1}}],[\"单调栈解题模版\",{\"0\":{\"178\":1}}],[\"单调栈\",{\"0\":{\"177\":1}}],[\"特殊数据结构\",{\"0\":{\"177\":1,\"181\":1}}],[\"层级遍历解法\",{\"0\":{\"173\":1}}],[\"完全二叉树的节点数为什么难算\",{\"0\":{\"165\":1}}],[\"完整代码如下\",{\"1\":{\"141\":1,\"143\":1}}],[\"完整代码\",{\"1\":{\"141\":1}}],[\"手写lfu算法\",{\"0\":{\"155\":1}}],[\"手写lru缓存淘汰算法\",{\"0\":{\"151\":1}}],[\"手动实现pow\",{\"1\":{\"140\":2,\"141\":2}}],[\"几个反直觉的概率问题\",{\"0\":{\"147\":1}}],[\"几个有趣的位操作\",{\"0\":{\"132\":1}}],[\"游戏中的随机算法\",{\"0\":{\"145\":1}}],[\"映射\",{\"1\":{\"143\":1}}],[\"异或\",{\"1\":{\"143\":1}}],[\"异或运算满足交换律和结合律\",{\"1\":{\"134\":1}}],[\"异或运算的性质\",{\"1\":{\"134\":1}}],[\"异或运算\",{\"1\":{\"130\":1}}],[\"异或运算符\",{\"1\":{\"130\":1}}],[\"常用的方法是排序\",{\"1\":{\"143\":1}}],[\"常用的位操作\",{\"0\":{\"128\":1}}],[\"关键点在于元素和索引是成对儿出现的\",{\"1\":{\"143\":1}}],[\"关于java\",{\"1\":{\"79\":1}}],[\"关于modcount\",{\"1\":{\"76\":1}}],[\"原地反转数据\",{\"1\":{\"223\":1}}],[\"原理图如下\",{\"1\":{\"143\":1}}],[\"原码\",{\"1\":{\"130\":1}}],[\"暂且将\",{\"1\":{\"143\":1}}],[\"正常思路\",{\"1\":{\"143\":1}}],[\"正数的补码与原码相同\",{\"1\":{\"130\":1}}],[\"正数的反码与原码相同\",{\"1\":{\"130\":1}}],[\"错误的集合\",{\"1\":{\"143\":1}}],[\"取出队列头元素\",{\"1\":{\"211\":1}}],[\"取相反数应该是2147483648\",{\"1\":{\"142\":1}}],[\"取模之后的结果\",{\"1\":{\"141\":2}}],[\"取模\",{\"1\":{\"139\":1}}],[\"末位是1\",{\"1\":{\"142\":1}}],[\"末尾有一个\",{\"1\":{\"136\":1}}],[\"考虑指数为负数的情况\",{\"1\":{\"142\":1}}],[\"考虑取模的情况\",{\"1\":{\"142\":1}}],[\"建议还是使用递归快速幂\",{\"1\":{\"142\":1}}],[\"进行实现\",{\"1\":{\"245\":1}}],[\"进行二进制拆分的时间复杂度\",{\"1\":{\"142\":1}}],[\"进而通过一些实例方法进行一系列的操作获得最后的对象\",{\"1\":{\"48\":1}}],[\"潜在的整型溢出\",{\"1\":{\"142\":1}}],[\"恰好就是\",{\"1\":{\"142\":1}}],[\"恰巧这些字符对应的数字通过位运算就能得到正确的结果\",{\"1\":{\"132\":1}}],[\"很自然地想到可以把它拆分为\",{\"1\":{\"142\":1}}],[\"很多时候拆包装和解包装能够自动完成\",{\"1\":{\"95\":1}}],[\"换一个角度来引入非递归的快速幂\",{\"1\":{\"142\":1}}],[\"偶数\",{\"1\":{\"142\":2}}],[\"奇数\",{\"1\":{\"142\":2}}],[\"模仿这样的过程\",{\"1\":{\"142\":1}}],[\"共进行了4次乘法\",{\"1\":{\"142\":1}}],[\"共进行了5次乘法\",{\"1\":{\"142\":1}}],[\"共进行了9次乘法\",{\"1\":{\"142\":1}}],[\"依次一步一步算\",{\"1\":{\"142\":1}}],[\"怎么判断\",{\"1\":{\"227\":1}}],[\"怎么才能不漏掉呢\",{\"1\":{\"136\":1}}],[\"怎样算比较快\",{\"1\":{\"142\":1}}],[\"举个例子\",{\"1\":{\"142\":1}}],[\"推荐使用高级的快速幂算法\",{\"1\":{\"141\":1}}],[\"等价于先对每个因子都求模\",{\"1\":{\"141\":1}}],[\"避免轮流扩散q1和q2\",{\"1\":{\"213\":1}}],[\"避免走回头路\",{\"1\":{\"211\":1}}],[\"避免溢出的同时得到正确的结果\",{\"1\":{\"141\":1}}],[\"避免溢出同时得到结果\",{\"1\":{\"141\":1}}],[\"避免整型溢出\",{\"1\":{\"137\":2}}],[\"能够化简这种表达式\",{\"1\":{\"141\":1}}],[\"能丢掉\",{\"1\":{\"140\":1,\"141\":1}}],[\"形如\",{\"1\":{\"141\":1}}],[\"合并结果\",{\"1\":{\"140\":1,\"141\":1}}],[\"计算它的最小高度\",{\"1\":{\"212\":1}}],[\"计算一棵二叉树的最小高度\",{\"1\":{\"212\":1}}],[\"计算第二部分\",{\"1\":{\"140\":1,\"141\":1}}],[\"计算第一部分\",{\"1\":{\"140\":1,\"141\":1}}],[\"计算汉明权重\",{\"1\":{\"133\":1}}],[\"缩小规模递归求解\",{\"1\":{\"140\":1,\"141\":1}}],[\"递归代码好写\",{\"1\":{\"212\":1}}],[\"递归反转整个链表\",{\"0\":{\"190\":1}}],[\"递归虽然简洁且运算速度快\",{\"1\":{\"142\":1}}],[\"递归快速幂\",{\"1\":{\"142\":3}}],[\"递归终止条件\",{\"1\":{\"140\":1,\"141\":1}}],[\"递归\",{\"1\":{\"140\":1,\"141\":1,\"203\":1}}],[\"由于计算机的编码方式\",{\"1\":{\"141\":1}}],[\"由于res的值为1\",{\"1\":{\"140\":1,\"141\":1,\"142\":2}}],[\"由于异或运算满足交换律和结合律\",{\"1\":{\"134\":1}}],[\"问题三\",{\"1\":{\"227\":1}}],[\"问题二\",{\"1\":{\"227\":1}}],[\"问题一\",{\"1\":{\"227\":1}}],[\"问题的本质就是让你在一幅图中找到从起点到终点的最近距离\",{\"1\":{\"211\":1}}],[\"问题规模缩小\",{\"1\":{\"140\":1}}],[\"问题转化为\",{\"1\":{\"136\":2}}],[\"结论\",{\"1\":{\"217\":1}}],[\"结合指数运算的法则\",{\"1\":{\"140\":1}}],[\"结果为\",{\"1\":{\"137\":1}}],[\"三种情况都需要考虑取模\",{\"1\":{\"142\":1}}],[\"三是如何高效进行幂运算\",{\"1\":{\"139\":1}}],[\"三大特性\",{\"0\":{\"66\":1}}],[\"早都溢出报错了\",{\"1\":{\"139\":1}}],[\"先遍历一遍链表\",{\"1\":{\"218\":1}}],[\"先把一个指针重新指向head\",{\"1\":{\"217\":1}}],[\"先把幂运算结果算出来\",{\"1\":{\"139\":1}}],[\"先刷二叉树\",{\"1\":{\"204\":1}}],[\"先算7\",{\"1\":{\"142\":1}}],[\"先算7的5次方\",{\"1\":{\"142\":1}}],[\"先不考虑取模的情况\",{\"1\":{\"140\":1}}],[\"先按年龄进行升序\",{\"1\":{\"99\":1}}],[\"二分查找算法\",{\"1\":{\"221\":1}}],[\"二分搜索框架\",{\"0\":{\"226\":1},\"1\":{\"226\":1}}],[\"二分搜索并不简单\",{\"1\":{\"225\":1}}],[\"二分搜索算法\",{\"0\":{\"225\":1}}],[\"二分搜索\",{\"0\":{\"221\":1}}],[\"二维数组某个节点扩散到其上下左右四个子节点\",{\"1\":{\"212\":1}}],[\"二维数组等数据结构分别是\",{\"1\":{\"212\":1}}],[\"二维数组等就是图的具体化\",{\"1\":{\"212\":1}}],[\"二叉树某个节点扩散到其左右子节点\",{\"1\":{\"212\":1}}],[\"二叉树的锯齿形层序遍历\",{\"1\":{\"212\":1}}],[\"二叉树的层序遍历2\",{\"1\":{\"212\":1}}],[\"二叉树的层序遍历\",{\"1\":{\"212\":1}}],[\"二叉树的最大深度\",{\"1\":{\"212\":1}}],[\"二叉树的最小深度\",{\"1\":{\"212\":1}}],[\"二叉树的最小高度\",{\"0\":{\"212\":1},\"1\":{\"212\":1}}],[\"二叉树的最近公共祖先\",{\"0\":{\"175\":1}}],[\"二叉树节点\",{\"1\":{\"212\":1}}],[\"二叉树遍历框架\",{\"1\":{\"203\":1}}],[\"二叉树具有前序遍历\",{\"1\":{\"203\":1}}],[\"二叉树搜索树操作集锦\",{\"0\":{\"160\":1}}],[\"二是如何得到求模之后的结果\",{\"1\":{\"139\":1}}],[\"二进制\",{\"1\":{\"131\":1}}],[\"二进制结果为\",{\"1\":{\"130\":4,\"131\":2}}],[\"没有这些加加减减\",{\"1\":{\"227\":1}}],[\"没有对deadends进行处理\",{\"1\":{\"213\":1}}],[\"没有终止条件\",{\"1\":{\"213\":1}}],[\"没有子节点到父节点的指针\",{\"1\":{\"211\":1}}],[\"没有超过最大容量就是max\",{\"1\":{\"75\":1}}],[\"没办法直接转成整型\",{\"1\":{\"139\":1}}],[\"超级次方\",{\"1\":{\"139\":1}}],[\"此优化效率提升明显\",{\"1\":{\"137\":1}}],[\"此时slow所在的节点就是倒数第k个节点\",{\"1\":{\"219\":1}}],[\"此时应当注意\",{\"1\":{\"142\":1}}],[\"此时执行next方法的时候\",{\"1\":{\"76\":1}}],[\"此时执行到hasnext方法\",{\"1\":{\"76\":1}}],[\"此时cursor的值为1\",{\"1\":{\"76\":1}}],[\"此时next方法会通过checkforcomodification进行检查\",{\"1\":{\"76\":1}}],[\"此时要保证新数组的长度最低也要和mincapacity相等\",{\"1\":{\"75\":1}}],[\"规律和优化\",{\"1\":{\"137\":1}}],[\"规则是输出位与输入位相反\",{\"1\":{\"130\":1}}],[\"复杂度分析\",{\"0\":{\"167\":1},\"1\":{\"142\":1,\"143\":1}}],[\"复杂度\",{\"1\":{\"137\":1}}],[\"函数签名如下\",{\"1\":{\"242\":1}}],[\"函数返回区间\",{\"1\":{\"242\":1}}],[\"函数返回的是pow\",{\"1\":{\"141\":2}}],[\"函数\",{\"1\":{\"137\":1}}],[\"函数是单调函数\",{\"1\":{\"137\":1}}],[\"从头开始\",{\"1\":{\"245\":2}}],[\"从此\",{\"1\":{\"225\":1}}],[\"从big\",{\"1\":{\"213\":1}}],[\"从\",{\"1\":{\"213\":1}}],[\"从起点开始启动⼴度优先搜索\",{\"1\":{\"213\":1}}],[\"从一个点开始\",{\"1\":{\"210\":1}}],[\"从数值上来说\",{\"1\":{\"137\":1}}],[\"从类的定义来看\",{\"1\":{\"108\":1}}],[\"全排列问题\",{\"0\":{\"207\":1}}],[\"全都改成long类型\",{\"1\":{\"137\":2}}],[\"全参数构造器方法\",{\"1\":{\"30\":2}}],[\"搜索\",{\"1\":{\"137\":2}}],[\"搜索有多少个\",{\"1\":{\"137\":1}}],[\"主要解决数组\",{\"1\":{\"214\":1}}],[\"主要解决链表中的问题\",{\"1\":{\"214\":1}}],[\"主要关注3个点\",{\"1\":{\"76\":1}}],[\"主函数\",{\"1\":{\"137\":1,\"142\":2}}],[\"远超\",{\"1\":{\"137\":1}}],[\"算出链表的长度n\",{\"1\":{\"218\":1}}],[\"算出来真实结果也没办法表示\",{\"1\":{\"139\":1}}],[\"算一下\",{\"1\":{\"137\":1}}],[\"算法思维\",{\"0\":{\"238\":1}}],[\"算法框架\",{\"0\":{\"211\":1}}],[\"算法是通过合适的工具解决特定问题的方法\",{\"1\":{\"204\":1}}],[\"算法刷题指南\",{\"0\":{\"204\":1}}],[\"算法复杂度分析\",{\"0\":{\"184\":1}}],[\"算法描述\",{\"0\":{\"156\":1}}],[\"算法返回\",{\"1\":{\"136\":1,\"137\":1}}],[\"算法\",{\"2\":{\"125\":1,\"126\":1,\"148\":1,\"149\":1,\"198\":1,\"199\":1,\"236\":1,\"237\":1,\"239\":1,\"240\":1,\"264\":1,\"265\":1}}],[\"算法小抄\",{\"0\":{\"121\":1}}],[\"算法和数据结构\",{\"0\":{\"9\":1,\"25\":1}}],[\"小总结\",{\"1\":{\"212\":1}}],[\"小一些\",{\"1\":{\"137\":1}}],[\"小傅哥的idea插件开发手册\",{\"1\":{\"115\":1}}],[\"作为搜索区间的上界\",{\"1\":{\"137\":1}}],[\"作用是消除数字\",{\"1\":{\"133\":1}}],[\"大佬\",{\"1\":{\"225\":1}}],[\"大部分时候都是必需的\",{\"1\":{\"211\":1}}],[\"大\",{\"1\":{\"137\":1}}],[\"大到这个值一定不会被取到\",{\"1\":{\"137\":1}}],[\"时间内计算出幂的算法\",{\"1\":{\"142\":1}}],[\"时间复杂度都是⼀样的\",{\"1\":{\"213\":1}}],[\"时间复杂度也是o\",{\"1\":{\"212\":1}}],[\"时间复杂度\",{\"1\":{\"142\":2,\"143\":2,\"213\":1}}],[\"时间复杂度为o\",{\"1\":{\"141\":1,\"202\":5}}],[\"时间复杂度可以达到o\",{\"1\":{\"141\":1}}],[\"时间复杂度主要是二分搜索\",{\"1\":{\"137\":1}}],[\"时间复杂度是底数为\",{\"1\":{\"136\":1}}],[\"时间复杂度o\",{\"1\":{\"134\":2}}],[\"时间复杂度对元素进行随机访问\",{\"1\":{\"100\":1}}],[\"时\",{\"1\":{\"137\":1}}],[\"区间内的整数\",{\"1\":{\"137\":1}}],[\"区别无序集合\",{\"1\":{\"99\":1}}],[\"区别在于lambda表达式的返回值\",{\"1\":{\"47\":1}}],[\"区别在于返回值\",{\"1\":{\"47\":1}}],[\"区别在于传入的默认值\",{\"1\":{\"47\":1}}],[\"区别在于mapper函数的返回值不同\",{\"1\":{\"39\":1}}],[\"区别在于flatmap中的mapper返回值必须是optional对象\",{\"1\":{\"39\":1,\"48\":1}}],[\"看看题目给的数据范围有多大\",{\"1\":{\"137\":1}}],[\"上的应用\",{\"1\":{\"224\":1}}],[\"上述的过程仍然是可以进行优化的\",{\"1\":{\"245\":1}}],[\"上述代码就会陷入死循环\",{\"1\":{\"216\":1}}],[\"上述伪码中\",{\"1\":{\"137\":1}}],[\"上面的代码类似于hascycle函数\",{\"1\":{\"217\":1}}],[\"上面的代码可以穷举所有的密码组合\",{\"1\":{\"213\":1}}],[\"上面的代码保证了代码的第三行\",{\"1\":{\"30\":1}}],[\"上面代码中如果不手动赋null值\",{\"1\":{\"79\":1}}],[\"寻找右侧边界的二分搜索\",{\"0\":{\"229\":1}}],[\"寻找左侧边界的二分搜索\",{\"0\":{\"228\":1}}],[\"寻找一个数\",{\"0\":{\"227\":1}}],[\"寻找单链表的倒数第k个元素\",{\"0\":{\"219\":1}}],[\"寻找链表中点的一个重要作用是对链表进行归并排序\",{\"1\":{\"218\":1}}],[\"寻找链表中点作用\",{\"1\":{\"218\":1}}],[\"寻找无环单链表的中点\",{\"0\":{\"218\":1}}],[\"寻找重复的元素\",{\"1\":{\"143\":1}}],[\"寻找上界和下界\",{\"1\":{\"137\":1}}],[\"寻找缺失的元素\",{\"1\":{\"134\":1,\"143\":1}}],[\"伪码逻辑如下\",{\"1\":{\"137\":1}}],[\"伪泛型\",{\"1\":{\"58\":1}}],[\"肯定要把二叉树中的所有树杈都走完\",{\"1\":{\"212\":1}}],[\"肯定也是递增的\",{\"1\":{\"137\":1}}],[\"肯定是递增的\",{\"1\":{\"137\":1}}],[\"肯定比因子\",{\"1\":{\"136\":1}}],[\"阶乘函数后k个零\",{\"1\":{\"137\":1}}],[\"阶乘后的零\",{\"1\":{\"136\":1}}],[\"像\",{\"1\":{\"136\":2}}],[\"首先记录每一个元素出现的次数\",{\"1\":{\"143\":1}}],[\"首先明确问题\",{\"1\":{\"140\":1,\"141\":1}}],[\"首先\",{\"1\":{\"136\":1,\"137\":1}}],[\"首先得了解arraylist的迭代器\",{\"1\":{\"76\":1}}],[\"难点在于像\",{\"1\":{\"136\":1}}],[\"总共有\",{\"1\":{\"136\":1,\"213\":1}}],[\"总结一下\",{\"1\":{\"99\":1,\"212\":1}}],[\"总结\",{\"1\":{\"99\":1,\"142\":1}}],[\"中素数的个数\",{\"1\":{\"242\":1}}],[\"中序遍历\",{\"1\":{\"203\":2}}],[\"中序遍历解法\",{\"0\":{\"172\":1}}],[\"中间的临界点就是sqrt\",{\"1\":{\"244\":1}}],[\"中间位置\",{\"1\":{\"202\":2}}],[\"中间\",{\"1\":{\"202\":2}}],[\"中不存在重复元素和缺失元素\",{\"1\":{\"143\":1}}],[\"中的问题\",{\"1\":{\"214\":1}}],[\"中的元素就越多\",{\"1\":{\"213\":1}}],[\"中的元素越多\",{\"1\":{\"213\":1}}],[\"中的元素变为\",{\"1\":{\"143\":1}}],[\"中的所有节点向周围扩散\",{\"1\":{\"213\":2}}],[\"中的一个元素出现了重复\",{\"1\":{\"143\":1}}],[\"中寻找满足\",{\"1\":{\"137\":1}}],[\"中有\",{\"1\":{\"136\":2}}],[\"中\",{\"1\":{\"136\":1}}],[\"中查询\",{\"1\":{\"134\":1}}],[\"多得多\",{\"1\":{\"136\":1}}],[\"多态机制\",{\"1\":{\"59\":1}}],[\"请返回这两个数的索引\",{\"1\":{\"222\":1}}],[\"请你计算有多少个\",{\"1\":{\"137\":1}}],[\"请你计算阶乘\",{\"1\":{\"136\":1}}],[\"请找出这个缺失的元素\",{\"1\":{\"134\":1}}],[\"题目链接\",{\"1\":{\"213\":1}}],[\"题目变形\",{\"0\":{\"179\":1}}],[\"题目描述\",{\"0\":{\"169\":1}}],[\"题目常常会要求对一个大数取模\",{\"1\":{\"142\":1}}],[\"题目的意思可以这样理解\",{\"1\":{\"134\":1}}],[\"题二\",{\"0\":{\"137\":1}}],[\"题一\",{\"0\":{\"136\":1}}],[\"本思路直接将题目演变成了leetcode的第136题目\",{\"1\":{\"134\":1}}],[\"左右指针初始化\",{\"1\":{\"222\":1}}],[\"左右指针一般运用在数组问题中\",{\"1\":{\"220\":1}}],[\"左右指针的常用算法\",{\"0\":{\"220\":1}}],[\"左右指针\",{\"1\":{\"214\":1}}],[\"左右都包括\",{\"1\":{\"134\":1}}],[\"左边界和右边界之差\",{\"1\":{\"137\":1}}],[\"左移3位\",{\"1\":{\"131\":1}}],[\"左移4位\",{\"1\":{\"131\":1}}],[\"左移1位\",{\"1\":{\"131\":1}}],[\"左移n位就相当于乘以2的n次方\",{\"1\":{\"131\":1}}],[\"左移一位都相当于乘以2的1次方\",{\"1\":{\"131\":1}}],[\"左移之后\",{\"1\":{\"131\":1}}],[\"左移位操作符\",{\"1\":{\"131\":1}}],[\"范围是\",{\"1\":{\"134\":1}}],[\"空间复杂度无非就是递归堆栈\",{\"1\":{\"212\":1}}],[\"空间复杂度要求的不是太高的话\",{\"1\":{\"142\":1}}],[\"空间复杂度\",{\"1\":{\"142\":2,\"143\":2}}],[\"空间复杂度o\",{\"1\":{\"134\":2}}],[\"空elementdata\",{\"1\":{\"73\":1}}],[\"成对儿的数字都会消为\",{\"1\":{\"134\":1}}],[\"成对儿的数字就会变成\",{\"1\":{\"134\":1}}],[\"假设k不会超过链表长度\",{\"1\":{\"219\":1}}],[\"假设有一棵树是满二叉树\",{\"1\":{\"212\":1}}],[\"假设有如下的类层次结构\",{\"1\":{\"47\":1}}],[\"假设元素是\",{\"1\":{\"143\":1}}],[\"假设\",{\"1\":{\"136\":1}}],[\"假设先把索引补一位\",{\"1\":{\"134\":1}}],[\"去\",{\"1\":{\"134\":1}}],[\"思路很简单\",{\"1\":{\"225\":1}}],[\"思路分析\",{\"0\":{\"157\":1,\"166\":1,\"176\":1},\"1\":{\"143\":2}}],[\"思路四\",{\"1\":{\"134\":1}}],[\"思路三\",{\"1\":{\"134\":1}}],[\"思路二\",{\"1\":{\"134\":1}}],[\"思路一\",{\"1\":{\"134\":1}}],[\"然后快慢指针开始以相同速率前进\",{\"1\":{\"219\":1}}],[\"然后再一次遍历链表\",{\"1\":{\"218\":1}}],[\"然后才能对比得到最短路径\",{\"1\":{\"212\":1}}],[\"然后让两个指针以相同的速度前进\",{\"1\":{\"217\":1}}],[\"然后让这个下标对应的元素置为负的\",{\"1\":{\"143\":1}}],[\"然后让每个元素和自己相等的索引相对应\",{\"1\":{\"134\":1}}],[\"然后在找缺失的元素\",{\"1\":{\"143\":1}}],[\"然后每次都对乘法结果\",{\"1\":{\"141\":1}}],[\"然后对因子相乘的结果再求模\",{\"1\":{\"141\":1}}],[\"然后做\",{\"1\":{\"139\":1}}],[\"然后我们可以反推\",{\"1\":{\"137\":1}}],[\"然后\",{\"1\":{\"136\":1,\"213\":1}}],[\"然后遍历一遍\",{\"1\":{\"134\":1}}],[\"然后完成插入操作\",{\"1\":{\"76\":1}}],[\"把所有n范围内的素数的倍数都标记为false\",{\"1\":{\"245\":2}}],[\"把所有数字进行异或\",{\"1\":{\"134\":1}}],[\"把一些问题抽象成图\",{\"1\":{\"210\":1}}],[\"把握问题的共性和本质\",{\"1\":{\"201\":1}}],[\"把10写成二进制的形式\",{\"1\":{\"142\":1}}],[\"把nums中的值全都加入list\",{\"1\":{\"134\":1}}],[\"把nums中的值全都异或一遍\",{\"1\":{\"134\":1}}],[\"把索引全都加入list\",{\"1\":{\"134\":1}}],[\"把索引全都异或一遍\",{\"1\":{\"134\":1}}],[\"把数组里出现的数字都储存下来\",{\"1\":{\"134\":1}}],[\"把这个数组排个序\",{\"1\":{\"134\":1}}],[\"给一个长度为\",{\"1\":{\"134\":1,\"143\":1}}],[\"给定initialcapacity\",{\"1\":{\"73\":1}}],[\"丢失的数字\",{\"1\":{\"134\":1}}],[\"落单的数字和\",{\"1\":{\"134\":1}}],[\"留下缺失的那个元素\",{\"1\":{\"134\":1}}],[\"做到举一反三\",{\"1\":{\"201\":1}}],[\"做异或运算还是它本身的性质\",{\"1\":{\"134\":1}}],[\"做异或运算的结果为它本身\",{\"1\":{\"134\":1}}],[\"做异或还是它本身\",{\"1\":{\"134\":1}}],[\"做一次\",{\"1\":{\"133\":1}}],[\"括号不可以省略\",{\"1\":{\"133\":1}}],[\"直到\",{\"1\":{\"133\":1}}],[\"直接将遍历过的元素加到deads集合中\",{\"1\":{\"213\":1}}],[\"直接将类初始化时加载的value为null的optional对象给用户\",{\"1\":{\"33\":1}}],[\"直接跳过\",{\"1\":{\"213\":1}}],[\"直接对数组的指定位置赋值即可\",{\"1\":{\"77\":1}}],[\"直接报错\",{\"1\":{\"59\":1}}],[\"了\",{\"1\":{\"133\":1,\"137\":1}}],[\"运算\",{\"1\":{\"133\":1}}],[\"运行结果\",{\"1\":{\"35\":1,\"36\":1,\"47\":1}}],[\"网址\",{\"1\":{\"132\":1}}],[\"减一\",{\"1\":{\"132\":1}}],[\"利用一个数和它本身做异或运算结果为\",{\"1\":{\"134\":1}}],[\"利用等差数列求和公式\",{\"1\":{\"134\":1}}],[\"利用数据结构的特性\",{\"1\":{\"134\":1}}],[\"利用异或操作\",{\"1\":{\"132\":1}}],[\"利用与操作\",{\"1\":{\"132\":1}}],[\"利用或操作\",{\"1\":{\"132\":1}}],[\"后续会有二分搜索的细节描述\",{\"1\":{\"221\":1}}],[\"后续依次对list中的数据进行异或操作\",{\"1\":{\"134\":1}}],[\"后面的二分搜索的变形都是基于该框架\",{\"1\":{\"226\":1}}],[\"后面的几个leetcode题目也建议通过画图的方式加深对bfs思想的理解\",{\"1\":{\"212\":1}}],[\"后面会用到这个默认容量\",{\"1\":{\"73\":1}}],[\"后序遍历\",{\"1\":{\"203\":2}}],[\"后序遍历head\",{\"1\":{\"203\":1}}],[\"后序遍历解法\",{\"0\":{\"171\":1}}],[\"后的结果\",{\"1\":{\"139\":1}}],[\"后一个是一元运算符\",{\"1\":{\"131\":1}}],[\"逻辑统一\",{\"0\":{\"230\":1}}],[\"逻辑或\",{\"1\":{\"131\":1}}],[\"逻辑运算符包括逻辑与\",{\"1\":{\"131\":1}}],[\"相遇点不可能在环外部\",{\"1\":{\"217\":1}}],[\"相乘\",{\"1\":{\"136\":1}}],[\"相当于\",{\"1\":{\"213\":1}}],[\"相当于把它标记为已访问过的元素\",{\"1\":{\"143\":1}}],[\"相当于是递归的结束条件\",{\"1\":{\"142\":2}}],[\"相当于除2的3次方\",{\"1\":{\"131\":1}}],[\"相当于除2的1次方\",{\"1\":{\"131\":1}}],[\"相当于乘2的4次方\",{\"1\":{\"131\":1}}],[\"相当于乘2的1次方\",{\"1\":{\"131\":1}}],[\"相等\",{\"1\":{\"129\":1}}],[\"再以这\",{\"1\":{\"213\":1}}],[\"再把数据全部复制进去\",{\"1\":{\"202\":1}}],[\"再次相遇时所在的节点位置就是环的起点位置\",{\"1\":{\"217\":1}}],[\"再次遍历数组寻找唯一没有置为负的那个元素\",{\"1\":{\"143\":1}}],[\"再次通过checkforcomodification进行检查\",{\"1\":{\"76\":1}}],[\"再算它的平方\",{\"1\":{\"142\":2}}],[\"再遍历\",{\"1\":{\"134\":1}}],[\"再将得到的结果赋给左边的变量\",{\"1\":{\"131\":1}}],[\"向下转动\",{\"1\":{\"213\":1}}],[\"向下拨动⼀次\",{\"1\":{\"213\":2}}],[\"向上转动\",{\"1\":{\"213\":1}}],[\"向上拨动⼀次\",{\"1\":{\"213\":2}}],[\"向四周扩散\",{\"1\":{\"210\":1}}],[\"向左边移动两位\",{\"1\":{\"131\":1}}],[\"向右边移动两位\",{\"1\":{\"131\":1}}],[\"零扩展\",{\"1\":{\"131\":1}}],[\"符号扩展\",{\"1\":{\"131\":1}}],[\"符号位除外\",{\"1\":{\"130\":1}}],[\"该算法的时间复杂度为o\",{\"1\":{\"243\":1,\"245\":1}}],[\"该算法有什么缺陷\",{\"1\":{\"227\":1}}],[\"该部分比前面稍微复杂\",{\"1\":{\"224\":1}}],[\"该函数返回的是a^4取模之后的结果\",{\"1\":{\"141\":1}}],[\"该操作符使用\",{\"1\":{\"131\":2}}],[\"该方法与orelse方法类似\",{\"1\":{\"36\":1}}],[\"低位补0\",{\"1\":{\"131\":1}}],[\"低位补零\",{\"1\":{\"131\":1}}],[\"右移1位\",{\"1\":{\"131\":1}}],[\"右移n位相当于除以2的n次方\",{\"1\":{\"131\":1}}],[\"右移一位相当于除2\",{\"1\":{\"131\":1}}],[\"右移之后\",{\"1\":{\"131\":2}}],[\"右移位操作符\",{\"1\":{\"131\":2}}],[\"右移\",{\"1\":{\"131\":1}}],[\"移位操作符的运算对象也是二进制的\",{\"1\":{\"131\":1}}],[\"移位运算符可以与等号组合使用\",{\"1\":{\"131\":1}}],[\"移位运算符包括左移\",{\"1\":{\"131\":1}}],[\"移动元素\",{\"1\":{\"76\":1}}],[\"求解true的个数\",{\"1\":{\"245\":2}}],[\"求模\",{\"1\":{\"141\":2}}],[\"求该二进制数的反码\",{\"1\":{\"130\":1}}],[\"求\",{\"1\":{\"130\":1}}],[\"个相邻的节点\",{\"1\":{\"213\":1}}],[\"个位置\",{\"1\":{\"213\":1}}],[\"个阶乘的结果最后只有一个\",{\"1\":{\"137\":1}}],[\"个\",{\"1\":{\"136\":4,\"137\":3}}],[\"个因子\",{\"1\":{\"136\":3}}],[\"个元素\",{\"1\":{\"134\":1,\"143\":1}}],[\"个字节是\",{\"1\":{\"130\":1}}],[\"个字节\",{\"1\":{\"130\":1}}],[\"个数\",{\"1\":{\"59\":1}}],[\"负数的二进制算法\",{\"1\":{\"130\":1}}],[\"负数的补码在其反码末位加\",{\"1\":{\"130\":1}}],[\"负数的反码对原码逐位取反\",{\"1\":{\"130\":1}}],[\"补码\",{\"1\":{\"130\":1}}],[\"补充\",{\"1\":{\"130\":1}}],[\"反转数组\",{\"0\":{\"223\":1}}],[\"反转链表的一部分\",{\"0\":{\"192\":1}}],[\"反转链表前n个节点\",{\"0\":{\"191\":1}}],[\"反码\",{\"1\":{\"130\":1}}],[\"反之为1\",{\"1\":{\"130\":1}}],[\"转化成\",{\"1\":{\"141\":1}}],[\"转化为二进制\",{\"1\":{\"130\":2}}],[\"转成数组并且将其拷贝到数组a中\",{\"1\":{\"83\":1}}],[\"转成数组\",{\"1\":{\"83\":1}}],[\"输入一个正整数n\",{\"1\":{\"242\":1}}],[\"输入一个已按照升序排列的有序数组nums和一个目标值target\",{\"1\":{\"222\":1}}],[\"输入一个非负整数\",{\"1\":{\"136\":1,\"137\":1}}],[\"输入一棵二叉树\",{\"1\":{\"212\":1}}],[\"输入0\",{\"1\":{\"130\":1}}],[\"输入1\",{\"1\":{\"130\":1}}],[\"输出位才是\",{\"1\":{\"130\":1}}],[\"输出的结果不保证有序\",{\"1\":{\"99\":1}}],[\"或\",{\"1\":{\"131\":2}}],[\"或运算\",{\"1\":{\"130\":1}}],[\"或者字符串\",{\"1\":{\"214\":1}}],[\"或者\",{\"1\":{\"132\":1,\"133\":1}}],[\"或者都为\",{\"1\":{\"130\":1}}],[\"或者根据实际需求\",{\"1\":{\"75\":1}}],[\"或操作符\",{\"1\":{\"130\":1}}],[\"^=\",{\"1\":{\"132\":6,\"134\":4}}],[\"^\",{\"1\":{\"130\":3,\"132\":7,\"134\":25}}],[\"按照传统bfs算法的策略\",{\"1\":{\"213\":1}}],[\"按照题目要求找到target就应该返回步数\",{\"1\":{\"213\":1}}],[\"按照操作符右侧指定的位数将操作符左边的操作数向右移动\",{\"1\":{\"131\":1}}],[\"按照操作符右侧指定的位数将操作符左边的操作数向左移动\",{\"1\":{\"131\":1}}],[\"按照自动排序的方式或者我们自定义的方式\",{\"1\":{\"99\":1}}],[\"按位或\",{\"1\":{\"130\":1}}],[\"按位与\",{\"1\":{\"130\":1}}],[\"~seander\",{\"1\":{\"132\":1}}],[\"~n\",{\"1\":{\"132\":1}}],[\"~num1\",{\"1\":{\"130\":2}}],[\"~\",{\"1\":{\"130\":2,\"132\":1}}],[\"位1的个数\",{\"1\":{\"133\":1}}],[\"位操作的黑科技玩法\",{\"1\":{\"132\":1}}],[\"位逻辑运算符用来操作整数的二进制位\",{\"1\":{\"130\":1}}],[\"位逻辑运算符包括按位取反\",{\"1\":{\"130\":1}}],[\"位\",{\"1\":{\"130\":1,\"131\":1}}],[\"位运算符的优先级极小\",{\"1\":{\"129\":1}}],[\"动态规划解题套路框架\",{\"0\":{\"205\":1}}],[\"动态规划\",{\"0\":{\"124\":1}}],[\"音乐\",{\"2\":{\"119\":1,\"120\":1}}],[\"影视\",{\"2\":{\"119\":1,\"120\":1}}],[\"影音资源\",{\"0\":{\"118\":1}}],[\"书籍\",{\"2\":{\"116\":1,\"117\":1}}],[\"书籍资源\",{\"0\":{\"115\":1}}],[\"knuth\",{\"1\":{\"225\":1}}],[\"k个一组反转链表\",{\"0\":{\"194\":1}}],[\"k\",{\"1\":{\"137\":18,\"141\":4,\"219\":3}}],[\"kxkqp4rqyud\",{\"1\":{\"115\":1}}],[\"key和多个null\",{\"1\":{\"108\":1}}],[\"keyset\",{\"1\":{\"104\":1,\"108\":4,\"143\":1}}],[\"key\",{\"1\":{\"103\":1,\"108\":2}}],[\"李航\",{\"1\":{\"115\":1}}],[\"统计学习方法\",{\"1\":{\"115\":1}}],[\"司守奎\",{\"1\":{\"115\":1}}],[\"非递归快速幂\",{\"1\":{\"142\":3}}],[\"非法情况\",{\"1\":{\"140\":2,\"141\":2,\"142\":5}}],[\"非运算\",{\"1\":{\"130\":2}}],[\"非运算符\",{\"1\":{\"130\":1}}],[\"非高清\",{\"1\":{\"115\":1}}],[\"非常相似\",{\"1\":{\"47\":1}}],[\"高频面试\",{\"0\":{\"241\":1}}],[\"高效实现\",{\"0\":{\"245\":1}}],[\"高效进行模幂运算\",{\"0\":{\"139\":1}}],[\"高效寻找素数\",{\"0\":{\"138\":1}}],[\"高位进行零扩展\",{\"1\":{\"131\":1}}],[\"高位进行符号扩展\",{\"1\":{\"131\":1}}],[\"高清\",{\"1\":{\"115\":1}}],[\"高级特性\",{\"1\":{\"115\":1}}],[\"鸟哥的linux私房菜\",{\"1\":{\"115\":2}}],[\"卷2\",{\"1\":{\"115\":1}}],[\"卷1\",{\"1\":{\"115\":1}}],[\"y\",{\"1\":{\"132\":4}}],[\"yd2l8xtgwua\",{\"1\":{\"115\":1}}],[\"ystong\",{\"1\":{\"37\":2}}],[\"疯狂java讲义第四版\",{\"1\":{\"115\":1}}],[\"资源名称\",{\"1\":{\"115\":1}}],[\"资源目录页\",{\"0\":{\"15\":1}}],[\"||\",{\"1\":{\"131\":1}}],[\"|\",{\"1\":{\"108\":20,\"130\":3,\"132\":5}}],[\"排序的区别\",{\"1\":{\"108\":1}}],[\"来避免对栈空间的大量占用\",{\"1\":{\"142\":1}}],[\"来举例\",{\"1\":{\"140\":1}}],[\"来算一算\",{\"1\":{\"136\":1}}],[\"来支持线程安全\",{\"1\":{\"107\":1}}],[\"来实现\",{\"1\":{\"75\":1}}],[\"现在slow在fast后面\",{\"1\":{\"217\":1}}],[\"现在fast=slow\",{\"1\":{\"217\":1}}],[\"现在有个等差数列\",{\"1\":{\"134\":1}}],[\"现在\",{\"1\":{\"132\":3,\"139\":1,\"140\":1}}],[\"现在可以使用\",{\"1\":{\"107\":1}}],[\"现在还有另一个线程在修改数据\",{\"1\":{\"76\":1}}],[\"值\",{\"1\":{\"104\":2,\"108\":20}}],[\"值可以重复\",{\"1\":{\"103\":1}}],[\"键\",{\"1\":{\"104\":2,\"108\":20}}],[\"q2\",{\"1\":{\"213\":17}}],[\"q1\",{\"1\":{\"213\":18}}],[\"q就是核心的队列数据结构\",{\"1\":{\"211\":1}}],[\"q\",{\"1\":{\"211\":6,\"212\":7,\"213\":14}}],[\"queue<string>\",{\"1\":{\"213\":2}}],[\"queue<treenode>\",{\"1\":{\"212\":1}}],[\"queue<node>\",{\"1\":{\"211\":1}}],[\"queue\",{\"0\":{\"101\":1}}],[\"qq\",{\"1\":{\"99\":2}}],[\"业务中如果想要快速的进行插入和删除\",{\"1\":{\"100\":1}}],[\"还是原值\",{\"1\":{\"142\":1}}],[\"还是7的10次方\",{\"1\":{\"142\":1}}],[\"还应当使用long类型进行定义\",{\"1\":{\"142\":1}}],[\"还不够的话就\",{\"1\":{\"137\":1}}],[\"还存储了两个引用\",{\"1\":{\"100\":1}}],[\"还可以用作栈\",{\"1\":{\"100\":1}}],[\"还没有实际分配默认容量长度的数组\",{\"1\":{\"73\":1}}],[\"使得\",{\"1\":{\"137\":1}}],[\"使其有序\",{\"1\":{\"99\":1}}],[\"使用\",{\"1\":{\"245\":1}}],[\"使用isprime函数一个一个的进行判断不是高效的做法\",{\"1\":{\"243\":1}}],[\"使用快慢指针\",{\"1\":{\"219\":1}}],[\"使用双指针\",{\"1\":{\"218\":1}}],[\"使用双向bfs进行优化\",{\"1\":{\"213\":1}}],[\"使用双向bfs可以进一步提高算法的效率\",{\"1\":{\"213\":1}}],[\"使用双向链表来维护元素的顺序\",{\"1\":{\"108\":1}}],[\"使用bfs的思想进行求解\",{\"1\":{\"211\":1}}],[\"使用布尔数组visited做标记就可以了\",{\"1\":{\"203\":1}}],[\"使用下面的代码会出现问题\",{\"1\":{\"142\":1}}],[\"使用非递归快速幂\",{\"1\":{\"142\":1}}],[\"使用递归\",{\"1\":{\"140\":1}}],[\"使用按位操作符时要注意\",{\"1\":{\"129\":1}}],[\"使用的是更加底层\",{\"1\":{\"76\":1}}],[\"使用父类对象接收\",{\"1\":{\"59\":2}}],[\"使用子类对象接收\",{\"1\":{\"59\":2}}],[\"使用optional工具类判断一个对象的npe问题\",{\"1\":{\"48\":1}}],[\"使用总结\",{\"0\":{\"48\":1}}],[\"使用例子\",{\"0\":{\"47\":1}}],[\"使用readme\",{\"0\":{\"18\":1}}],[\"降序就是第二个减去第一个\",{\"1\":{\"99\":1}}],[\"升序就是第一个减去第二个\",{\"1\":{\"99\":1}}],[\"zhihu\",{\"1\":{\"109\":1,\"142\":1}}],[\"zhuanlan\",{\"1\":{\"109\":1,\"142\":1}}],[\"zero\",{\"1\":{\"99\":1}}],[\"zuochengsi\",{\"1\":{\"76\":1,\"90\":1}}],[\"年龄相等\",{\"1\":{\"99\":1}}],[\"年龄相同的按照学号降序\",{\"1\":{\"99\":1}}],[\"最长无重复子串\",{\"0\":{\"235\":1}}],[\"最终\",{\"1\":{\"225\":1}}],[\"最直接的思路\",{\"1\":{\"218\":1}}],[\"最小覆盖子串\",{\"0\":{\"232\":1}}],[\"最小值是\",{\"1\":{\"142\":1}}],[\"最小是多少\",{\"1\":{\"137\":1}}],[\"最朴素的想法\",{\"1\":{\"142\":1}}],[\"最大值和最小值一减\",{\"1\":{\"137\":1}}],[\"最大是多少\",{\"1\":{\"137\":1}}],[\"最大容量就是integer\",{\"1\":{\"75\":1}}],[\"最后结果去掉两个\",{\"1\":{\"245\":2}}],[\"最后找到target\",{\"1\":{\"213\":1}}],[\"最后位置\",{\"1\":{\"202\":2}}],[\"最后位置的增删改查分析如下\",{\"1\":{\"202\":2}}],[\"最后总结\",{\"0\":{\"188\":1,\"193\":1,\"197\":1,\"209\":1}}],[\"最后\",{\"1\":{\"136\":1}}],[\"最后取出的元素又是否有序\",{\"1\":{\"99\":1}}],[\"最多可以分解出\",{\"1\":{\"136\":1}}],[\"最多可以分解出几个\",{\"1\":{\"136\":1}}],[\"最多可以分解出多少个因子\",{\"1\":{\"136\":2}}],[\"最高位为符号位\",{\"1\":{\"130\":1}}],[\"最好加上括号\",{\"1\":{\"129\":1}}],[\"且内部使用双向链表维护元素的插入顺序\",{\"1\":{\"99\":1}}],[\"且很容易出现java\",{\"1\":{\"59\":1}}],[\"具有ai功能加持的终端工具warp使用总结\",{\"1\":{\"115\":1}}],[\"具有\",{\"1\":{\"99\":1}}],[\"得到的结果是不确定的\",{\"1\":{\"99\":1}}],[\"得到元素后需要进行类型转换\",{\"1\":{\"78\":1}}],[\"遍历范围可以设置为\",{\"1\":{\"245\":1}}],[\"遍历\",{\"1\":{\"99\":1}}],[\"遍历操作是集合最基本的操作\",{\"1\":{\"98\":1}}],[\"支持随机访问\",{\"1\":{\"100\":1}}],[\"支持快速查找\",{\"1\":{\"99\":1}}],[\"支持有序性操作\",{\"1\":{\"99\":1}}],[\"基本的二分搜索\",{\"0\":{\"227\":1}}],[\"基本使用\",{\"1\":{\"47\":1}}],[\"基础框架如下所示\",{\"1\":{\"226\":1}}],[\"基础知识\",{\"1\":{\"115\":1}}],[\"基于堆结构实现\",{\"1\":{\"101\":1}}],[\"基于双向链表实现\",{\"1\":{\"100\":1}}],[\"基于动态数组实现\",{\"1\":{\"100\":1}}],[\"基于哈希表实现\",{\"1\":{\"99\":1,\"106\":1}}],[\"基于红黑树实现\",{\"1\":{\"99\":1,\"105\":1}}],[\"顶层的collection接口提供一个通用高级的遍历方式\",{\"1\":{\"98\":1}}],[\"存储扩散结果\",{\"1\":{\"213\":2}}],[\"存储每一个元素出现的此次数\",{\"1\":{\"143\":1}}],[\"存储和取出元素的顺序有可能不一致\",{\"1\":{\"99\":1}}],[\"存储着键值对\",{\"1\":{\"95\":1}}],[\"存储着对象的集合\",{\"1\":{\"95\":1}}],[\"存储需要判断null的对象\",{\"1\":{\"31\":1}}],[\"和dfs\",{\"1\":{\"210\":1}}],[\"和非线性\",{\"1\":{\"203\":1}}],[\"和链表\",{\"1\":{\"202\":1}}],[\"和空格进行英文字符大小写互换\",{\"1\":{\"132\":1}}],[\"和空格将英文字符转换为小写\",{\"1\":{\"132\":1}}],[\"和下划线将英文字符转换为大写\",{\"1\":{\"132\":1}}],[\"和逻辑非\",{\"1\":{\"131\":1}}],[\"和无符号右移\",{\"1\":{\"131\":1}}],[\"和按位异或\",{\"1\":{\"130\":1}}],[\"和字符型数据\",{\"1\":{\"129\":1}}],[\"和\",{\"1\":{\"95\":1,\"100\":1,\"107\":1,\"136\":3,\"213\":3}}],[\"才能放到容器里\",{\"1\":{\"95\":1}}],[\"j每次都从2开始存在冗余计算\",{\"1\":{\"245\":1}}],[\"j++\",{\"1\":{\"213\":4}}],[\"j\",{\"1\":{\"213\":36,\"245\":8}}],[\"j3\",{\"1\":{\"132\":2}}],[\"j2\",{\"1\":{\"132\":2}}],[\"j1\",{\"1\":{\"132\":2}}],[\"jdk官方默认是升序\",{\"1\":{\"99\":1}}],[\"jcf\",{\"1\":{\"95\":1}}],[\"java中int类型的范围是\",{\"1\":{\"142\":1}}],[\"java中位操作符一共有7个\",{\"1\":{\"129\":1}}],[\"java中位操作符的操作数只能是整型\",{\"1\":{\"129\":1}}],[\"java中的位操作符\",{\"0\":{\"129\":1}}],[\"java容器里只能放对象\",{\"1\":{\"95\":1}}],[\"java注解机制\",{\"0\":{\"62\":1}}],[\"java泛型只是编译器提供的语法糖\",{\"1\":{\"70\":1}}],[\"java泛型的实现采取了\",{\"1\":{\"58\":1}}],[\"java泛型这个特性是从jdk\",{\"1\":{\"58\":1}}],[\"java泛型机制\",{\"0\":{\"57\":1}}],[\"java异常机制\",{\"0\":{\"54\":1}}],[\"java反射机制\",{\"0\":{\"51\":1}}],[\"java\",{\"1\":{\"30\":1,\"37\":3,\"76\":2,\"90\":2,\"95\":1,\"109\":2,\"143\":1},\"2\":{\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"55\":1,\"56\":1,\"60\":1,\"61\":1,\"63\":1,\"64\":1,\"67\":1,\"68\":1,\"91\":1,\"92\":1,\"110\":1,\"111\":1}}],[\"java8新特性\",{\"0\":{\"28\":1}}],[\"java虚拟机\",{\"0\":{\"6\":1}}],[\"java核心技术\",{\"1\":{\"115\":2}}],[\"java核心\",{\"0\":{\"5\":1,\"112\":1}}],[\"简单介绍\",{\"0\":{\"95\":1}}],[\"404\",{\"1\":{\"266\":1}}],[\"49\",{\"1\":{\"142\":2}}],[\"4种\",{\"1\":{\"130\":1}}],[\"4个位逻辑运算符\",{\"0\":{\"130\":1}}],[\"43541242\",{\"1\":{\"99\":1}}],[\"4\",{\"1\":{\"88\":1,\"99\":4,\"104\":1,\"108\":17,\"130\":1,\"131\":1,\"133\":1,\"134\":9,\"140\":1,\"213\":5}}],[\"测试和空格进行按位异或操作进行大小写转换\",{\"1\":{\"132\":1}}],[\"测试和空格进行按位或操作转为小写字母\",{\"1\":{\"132\":1}}],[\"测试和下划线进行按位与操作转为大写字母\",{\"1\":{\"132\":1}}],[\"测试dddd\",{\"1\":{\"88\":2}}],[\"测试ccc\",{\"1\":{\"88\":2}}],[\"测试bb\",{\"1\":{\"88\":2}}],[\"测试\",{\"1\":{\"88\":2}}],[\"测试第二种\",{\"1\":{\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1}}],[\"测试第一种\",{\"1\":{\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1}}],[\"声明\",{\"1\":{\"88\":4}}],[\"如何调度考生的座位\",{\"0\":{\"257\":1}}],[\"如何判定括号合法性\",{\"0\":{\"256\":1}}],[\"如何判断回文链表\",{\"0\":{\"185\":1}}],[\"如何运用贪心算法做时间管理\",{\"0\":{\"255\":1}}],[\"如何运用贪心思想玩跳跃游戏\",{\"0\":{\"254\":1}}],[\"如何运用二分搜索算法\",{\"0\":{\"250\":1}}],[\"如何寻找最长回文子串\",{\"0\":{\"253\":1}}],[\"如何去除有序数组的重复元素\",{\"0\":{\"252\":1}}],[\"如何高效解决接雨水问题\",{\"0\":{\"251\":1}}],[\"如何高效进行模幂运算\",{\"0\":{\"246\":1}}],[\"如何高效寻找素数\",{\"0\":{\"242\":1}}],[\"如何高效求幂\",{\"0\":{\"142\":1,\"249\":1}}],[\"如何处理循环数组\",{\"0\":{\"180\":1}}],[\"如何处理mod运算\",{\"0\":{\"141\":1,\"248\":1}}],[\"如何处理数组指数\",{\"0\":{\"140\":1,\"247\":1}}],[\"如何遍历\",{\"0\":{\"98\":1,\"104\":1}}],[\"如何学习\",{\"0\":{\"97\":1,\"103\":1}}],[\"如何使用\",{\"1\":{\"88\":1}}],[\"如果i为素数\",{\"1\":{\"245\":2}}],[\"如果一个数只能被1和它本身整除\",{\"1\":{\"242\":1}}],[\"如果找不到就返回\",{\"1\":{\"227\":1}}],[\"如果找到就返回其索引\",{\"1\":{\"227\":1}}],[\"如果含有环\",{\"1\":{\"216\":1}}],[\"如果链表中含有环\",{\"1\":{\"216\":1}}],[\"如果链表中不含环\",{\"1\":{\"216\":1}}],[\"如果我们每次都选择⼀个较⼩的集合进⾏扩散\",{\"1\":{\"213\":1}}],[\"如果穷举完都没找到⽬标密码\",{\"1\":{\"213\":1}}],[\"如果让你设计⼀个算法\",{\"1\":{\"213\":1}}],[\"如果要找到最短路径\",{\"1\":{\"212\":1}}],[\"如果在后序遍历的位置打印head\",{\"1\":{\"203\":1}}],[\"如果在前序遍历的位置打印head\",{\"1\":{\"203\":1}}],[\"如果知道某一元素的前驱和后继\",{\"1\":{\"202\":1}}],[\"如果某个元素做下标时对应的元素值为负\",{\"1\":{\"143\":1}}],[\"如果说\",{\"1\":{\"143\":1}}],[\"如果n的当前末位为1\",{\"1\":{\"142\":2}}],[\"如果取模的base较大\",{\"1\":{\"142\":1}}],[\"如果写成recursionpow\",{\"1\":{\"142\":2}}],[\"如果存在环\",{\"1\":{\"216\":1}}],[\"如果存在\",{\"1\":{\"137\":1}}],[\"如果使用\",{\"1\":{\"133\":1}}],[\"如果两个输入位都为\",{\"1\":{\"130\":1}}],[\"如果两个输入位都是\",{\"1\":{\"130\":1}}],[\"如果两个输入位有一个是\",{\"1\":{\"130\":1}}],[\"如果想要插入和删除比较高效\",{\"1\":{\"202\":1}}],[\"如果想要查询和修改比较高效\",{\"1\":{\"202\":1}}],[\"如果想要执行父类的sayhello方法\",{\"1\":{\"59\":1}}],[\"如果想快速获取元素或者降低空间消耗\",{\"1\":{\"100\":1}}],[\"如果有序\",{\"1\":{\"99\":1}}],[\"如果有值则将其返回\",{\"1\":{\"48\":2}}],[\"如果有值orelse方法会返回optional实例\",{\"1\":{\"47\":1}}],[\"如果有值并且满足断言条件返回包含该值的optional对象\",{\"1\":{\"40\":1,\"48\":1}}],[\"如果有值\",{\"1\":{\"38\":1,\"39\":1,\"48\":2}}],[\"如果从指定位置插入\",{\"1\":{\"76\":1}}],[\"如果需要则自动扩容\",{\"1\":{\"76\":2}}],[\"如果需要多个线程并发访问\",{\"1\":{\"70\":1}}],[\"如果超出\",{\"1\":{\"75\":1}}],[\"如果等于0\",{\"1\":{\"73\":1}}],[\"如果大于0\",{\"1\":{\"73\":1}}],[\"如果容量不足\",{\"1\":{\"70\":1}}],[\"如果没有泛型\",{\"1\":{\"59\":1}}],[\"如果值不为null\",{\"1\":{\"48\":1}}],[\"如果指定的值为null\",{\"1\":{\"48\":1}}],[\"如果满足返回optional实例值\",{\"1\":{\"47\":1}}],[\"如果optional对象有值\",{\"1\":{\"48\":1}}],[\"如果optional对象的值并不为空则将其返回\",{\"1\":{\"48\":1}}],[\"如果optional值不为空\",{\"1\":{\"47\":1}}],[\"如果obj不是optional类型的\",{\"1\":{\"44\":1}}],[\"如果value值为null\",{\"1\":{\"37\":1}}],[\"如果value值不为null\",{\"1\":{\"37\":1}}],[\"如果为null\",{\"1\":{\"35\":1}}],[\"如果为null值\",{\"1\":{\"34\":1}}],[\"如果为不为null\",{\"1\":{\"35\":1}}],[\"如果不含有环\",{\"1\":{\"216\":1}}],[\"如果不存在\",{\"1\":{\"137\":1}}],[\"如果不为null值\",{\"1\":{\"34\":1}}],[\"如果不使用optional类\",{\"1\":{\"30\":1}}],[\"如果传入的value为null值\",{\"1\":{\"32\":1}}],[\"截取一段成为子list\",{\"1\":{\"85\":1}}],[\"有的代码是right\",{\"1\":{\"227\":1}}],[\"有一天阿东到图书馆借了n本书\",{\"1\":{\"225\":1}}],[\"有一个元素重复了\",{\"1\":{\"143\":1}}],[\"有一个叫做bit\",{\"1\":{\"132\":1}}],[\"有符号\",{\"1\":{\"131\":1}}],[\"有符号的二进制补码\",{\"1\":{\"130\":1}}],[\"有序操作三者的区别很重要\",{\"1\":{\"99\":1}}],[\"有序集合\",{\"1\":{\"99\":2}}],[\"有效元素清空\",{\"1\":{\"84\":1}}],[\"有参数的构造函数提供一个value一定不能为null的optional对象\",{\"1\":{\"31\":1}}],[\"有参构造函数\",{\"1\":{\"31\":1}}],[\"元素第一次出现的index\",{\"1\":{\"82\":1}}],[\"元素个数增加\",{\"1\":{\"76\":1}}],[\"列表是否为空\",{\"1\":{\"81\":1}}],[\"批量删除\",{\"1\":{\"79\":1}}],[\"私有方法\",{\"1\":{\"79\":1}}],[\"保安成功地找到了那本引起警报的书\",{\"1\":{\"225\":1}}],[\"保留\",{\"1\":{\"79\":1}}],[\"保证size\",{\"1\":{\"76\":1}}],[\"保证newcapacity不会超出最大限制integer\",{\"1\":{\"75\":1}}],[\"保证mincapacity的容量\",{\"1\":{\"75\":1}}],[\"保证有mincapacity的容量\",{\"1\":{\"75\":1}}],[\"保证最小容量mincapacity\",{\"1\":{\"75\":1}}],[\"保证容量\",{\"1\":{\"75\":1}}],[\"必须显式的为最后一个位置赋null值\",{\"1\":{\"79\":1}}],[\"必须相同\",{\"1\":{\"59\":1}}],[\"删除最后一个元素比较高效\",{\"1\":{\"140\":1}}],[\"删除第一个满足条件o\",{\"1\":{\"79\":1}}],[\"删除第一个满足o\",{\"1\":{\"79\":1}}],[\"删除操作是add\",{\"1\":{\"79\":1}}],[\"删除指定位置的元素\",{\"1\":{\"79\":2}}],[\"唯一要注意的是由于底层数组是object\",{\"1\":{\"78\":1}}],[\"74等等\",{\"1\":{\"142\":1}}],[\"72\",{\"1\":{\"142\":1}}],[\"71\",{\"1\":{\"142\":1}}],[\"70b100\",{\"1\":{\"142\":1}}],[\"70b1000\",{\"1\":{\"142\":1}}],[\"70b10\",{\"1\":{\"142\":1}}],[\"70b1010\",{\"1\":{\"142\":1}}],[\"7050351\",{\"1\":{\"76\":1,\"90\":1}}],[\"7得49\",{\"1\":{\"142\":1}}],[\"7=343\",{\"1\":{\"142\":1}}],[\"7=49\",{\"1\":{\"142\":1}}],[\"7的10次方\",{\"1\":{\"142\":1}}],[\"7\",{\"1\":{\"137\":1,\"142\":6}}],[\"75\",{\"1\":{\"136\":1}}],[\"79\",{\"1\":{\"37\":1}}],[\"9000\",{\"1\":{\"213\":1}}],[\"95902286\",{\"1\":{\"142\":1}}],[\"9\",{\"1\":{\"76\":1,\"90\":1,\"130\":1,\"137\":1,\"213\":4}}],[\"它俩的最坏复杂度都是\",{\"1\":{\"213\":1}}],[\"它的下标就是缺失的元素值\",{\"1\":{\"143\":1}}],[\"它能够以o\",{\"1\":{\"142\":1}}],[\"它还可以额外再提供一个因子\",{\"1\":{\"136\":1}}],[\"它们每人可以额外再提供一个因子\",{\"1\":{\"136\":1}}],[\"它们一定可以提供一个因子\",{\"1\":{\"136\":1}}],[\"它是快慢指针在数组\",{\"1\":{\"224\":1}}],[\"它是遗留类\",{\"1\":{\"107\":1}}],[\"它是arraylist中的一个内部类\",{\"1\":{\"76\":1}}],[\"它可以通过trimtosize方法来实现\",{\"1\":{\"86\":1}}],[\"它将提供类型的约束\",{\"1\":{\"59\":1}}],[\"获取队列长度\",{\"1\":{\"211\":1}}],[\"获取元素的最后一次出现的index\",{\"1\":{\"87\":1}}],[\"获取元素的第一次出现的index\",{\"1\":{\"87\":1}}],[\"获取arraylist的迭代器\",{\"1\":{\"76\":1}}],[\"获得optional对象\",{\"1\":{\"48\":1}}],[\"答案是\",{\"1\":{\"76\":1}}],[\"继承于abstractlist\",{\"1\":{\"76\":1}}],[\"跟add\",{\"1\":{\"76\":1}}],[\"跟c++的vector不同\",{\"1\":{\"76\":1}}],[\"分析\",{\"1\":{\"212\":1}}],[\"分析问题\",{\"0\":{\"195\":1},\"1\":{\"243\":1}}],[\"分析原因\",{\"1\":{\"76\":1}}],[\"分享链接\",{\"1\":{\"115\":1}}],[\"分配新数组的最大容量\",{\"1\":{\"75\":1}}],[\"分别被称为泛型类\",{\"1\":{\"59\":1}}],[\"与运算\",{\"1\":{\"130\":1}}],[\"与操作符\",{\"1\":{\"130\":1}}],[\"与不相等\",{\"1\":{\"129\":1}}],[\"与原来的数组不同\",{\"1\":{\"75\":1}}],[\"与of的区别\",{\"1\":{\"34\":1}}],[\"weight\",{\"1\":{\"133\":1}}],[\"w++\",{\"1\":{\"79\":1}}],[\"w\",{\"1\":{\"79\":7}}],[\"words\",{\"1\":{\"79\":1}}],[\"work\",{\"1\":{\"79\":2,\"84\":1}}],[\"write\",{\"1\":{\"76\":1}}],[\"while里面到底是<=还是<\",{\"1\":{\"225\":1}}],[\"while迭代\",{\"1\":{\"203\":1}}],[\"while\",{\"1\":{\"76\":2,\"99\":4,\"104\":1,\"133\":1,\"136\":1,\"137\":5,\"142\":3,\"211\":1,\"212\":1,\"213\":6,\"216\":2,\"217\":2,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"223\":1,\"226\":1,\"227\":1}}],[\"www\",{\"1\":{\"75\":1,\"76\":1,\"90\":4,\"109\":2,\"115\":12,\"131\":1}}],[\"with\",{\"1\":{\"73\":1,\"79\":1}}],[\"wintershii\",{\"1\":{\"59\":1}}],[\"新数组的长度如果超过了限制max\",{\"1\":{\"75\":1}}],[\"新数组的长度有可能还是无法满足mincapacity\",{\"1\":{\"75\":1}}],[\"新数组的长度是旧数组的1\",{\"1\":{\"75\":1}}],[\"新建一个父类对象\",{\"1\":{\"59\":2}}],[\"真正在做扩容的方法\",{\"1\":{\"75\":1}}],[\"真正在做扩容的是grow\",{\"1\":{\"75\":1}}],[\"git原理之二叉树最近公共祖先\",{\"0\":{\"174\":1}}],[\"gae5a3tjazn\",{\"1\":{\"115\":1}}],[\"graphics\",{\"1\":{\"132\":1}}],[\"greater\",{\"1\":{\"99\":1}}],[\"grow\",{\"1\":{\"75\":2}}],[\"gc这里需要特别说明一下\",{\"1\":{\"79\":1}}],[\"gc\",{\"1\":{\"79\":2,\"84\":1}}],[\"getmidnodefromlist\",{\"1\":{\"218\":1}}],[\"getmessage\",{\"1\":{\"47\":2}}],[\"getvalue\",{\"1\":{\"104\":1}}],[\"getkey\",{\"1\":{\"104\":1}}],[\"getter\",{\"1\":{\"99\":1}}],[\"getter方法\",{\"1\":{\"30\":2}}],[\"getidnumber\",{\"1\":{\"99\":2}}],[\"getinner\",{\"1\":{\"47\":2}}],[\"getage\",{\"1\":{\"99\":2}}],[\"getaddress\",{\"1\":{\"30\":2}}],[\"getcomponenttype\",{\"1\":{\"74\":1}}],[\"getclass\",{\"1\":{\"73\":1,\"74\":1,\"83\":1}}],[\"getfoo\",{\"1\":{\"47\":2}}],[\"getnested\",{\"1\":{\"47\":2}}],[\"get\",{\"0\":{\"43\":1,\"78\":1},\"1\":{\"36\":3,\"37\":5,\"43\":1,\"47\":2,\"48\":1,\"70\":1,\"78\":2,\"104\":1,\"108\":4,\"143\":2}}],[\"getusername\",{\"1\":{\"35\":2,\"36\":2,\"37\":1,\"38\":2,\"39\":2}}],[\"getprovince\",{\"1\":{\"30\":2}}],[\"显示的进行扩容操作\",{\"1\":{\"75\":1}}],[\"修正应该保证的最小容量\",{\"1\":{\"75\":1}}],[\"注意运算符优先级\",{\"1\":{\"133\":1}}],[\"注意\",{\"1\":{\"129\":1,\"131\":1,\"142\":2,\"218\":1,\"226\":1,\"227\":4}}],[\"注意顶层接口中还定义了一个内部的接口entry\",{\"1\":{\"103\":1}}],[\"注意并不是底层数组的长度\",{\"1\":{\"80\":1}}],[\"注意这是一个公开的自动扩容方法\",{\"1\":{\"75\":1}}],[\"注意此时的elementdata还是空数组\",{\"1\":{\"73\":1}}],[\"要检查哪本书没有登记出借\",{\"1\":{\"225\":1}}],[\"要把现实问题的场景抽象成一幅图\",{\"1\":{\"211\":1}}],[\"要计算\",{\"1\":{\"142\":1}}],[\"要求你的算法返回幂运算\",{\"1\":{\"139\":1}}],[\"要在构造arraylist实例时\",{\"1\":{\"75\":1}}],[\"要实现不同类型的加法\",{\"1\":{\"59\":1}}],[\"50\",{\"1\":{\"136\":2}}],[\"50452411\",{\"1\":{\"90\":1}}],[\"5\",{\"1\":{\"99\":6,\"130\":1,\"131\":1,\"136\":52,\"137\":10,\"140\":1}}],[\"5倍的底层也是用的这个数组方法\",{\"1\":{\"76\":1}}],[\"5倍之后\",{\"1\":{\"75\":1}}],[\"5倍\",{\"1\":{\"75\":2}}],[\"5才开始加入的\",{\"1\":{\"58\":1}}],[\"会把整棵树的节点都搜索⼀遍\",{\"1\":{\"213\":1}}],[\"会走回头路\",{\"1\":{\"213\":1}}],[\"会导致有两个元素对应到了同一个索引\",{\"1\":{\"143\":1}}],[\"会对两个参数中对应的位执行布尔代数运算\",{\"1\":{\"130\":1}}],[\"会继续向下走\",{\"1\":{\"76\":2}}],[\"会将老数组中的元素重新拷贝一份到新的数组中\",{\"1\":{\"75\":1}}],[\"会首先判断调用它的optional对象中的value值\",{\"1\":{\"35\":1}}],[\"数值的整数次方\",{\"1\":{\"142\":1}}],[\"数字的二进制表示法\",{\"1\":{\"130\":1}}],[\"数字的二进制表现形式为\",{\"1\":{\"130\":1}}],[\"数学上的正无穷肯定是无法编程表示出来的\",{\"1\":{\"137\":1}}],[\"数学运算\",{\"0\":{\"127\":1}}],[\"数学建模算法与应用\",{\"1\":{\"115\":1}}],[\"数据结构是工具\",{\"1\":{\"204\":1}}],[\"数据结构和算法\",{\"1\":{\"204\":1}}],[\"数据结构的基本操作\",{\"0\":{\"203\":1}}],[\"数据结构的底层存储方式只有两种\",{\"1\":{\"202\":1}}],[\"数据结构的存储方式\",{\"0\":{\"202\":1}}],[\"数据结构\",{\"0\":{\"150\":1},\"2\":{\"125\":1,\"126\":1,\"148\":1,\"149\":1,\"198\":1,\"199\":1,\"236\":1,\"237\":1,\"239\":1,\"240\":1,\"264\":1,\"265\":1}}],[\"数据库\",{\"0\":{\"10\":1}}],[\"数组遍历框架\",{\"1\":{\"203\":1}}],[\"数组在开始\",{\"1\":{\"202\":1}}],[\"数组由于是紧凑连续存储\",{\"1\":{\"202\":1}}],[\"数组\",{\"1\":{\"202\":2}}],[\"数组中重复的数据\",{\"1\":{\"143\":1}}],[\"数组的拷贝\",{\"1\":{\"76\":1}}],[\"数组扩容的最大长度限制\",{\"1\":{\"75\":1}}],[\"数组扩容通过一个公开\",{\"1\":{\"75\":1}}],[\"数组进行扩容时\",{\"1\":{\"75\":1}}],[\"数组将会进行扩容\",{\"1\":{\"75\":1}}],[\"都是在数组或者链表上的特殊操作\",{\"1\":{\"202\":1}}],[\"都可以把它拆成若干个\",{\"1\":{\"142\":1}}],[\"都可以使用lambda表达式优化代码的书写\",{\"1\":{\"88\":1}}],[\"都变成\",{\"1\":{\"133\":1}}],[\"都在高位插入\",{\"1\":{\"131\":1}}],[\"都需要进行剩余空间检查\",{\"1\":{\"76\":1}}],[\"都要去检查添加后元素的个数\",{\"1\":{\"75\":1}}],[\"都替换为具体的类型\",{\"1\":{\"58\":1}}],[\"自动扩容1\",{\"1\":{\"76\":1}}],[\"自动扩容\",{\"0\":{\"75\":1}}],[\"速度快\",{\"1\":{\"74\":1}}],[\"是反转临界点\",{\"1\":{\"244\":1}}],[\"是这么评价二分搜索的\",{\"1\":{\"225\":1}}],[\"是可以使⽤双向bfs算法来提⾼效率\",{\"1\":{\"213\":1}}],[\"是可以在还没遍历完整的一棵树的时候就可以找到最短距离\",{\"1\":{\"212\":1}}],[\"是两种特别常用的算法\",{\"1\":{\"210\":1}}],[\"是典型的非线性递归遍历结构\",{\"1\":{\"203\":1}}],[\"是典型的线形结构\",{\"1\":{\"203\":1}}],[\"是一种简单而有效的小算法\",{\"1\":{\"142\":1}}],[\"是一个数组\",{\"1\":{\"139\":1,\"140\":1}}],[\"是一个非常大的正整数且会以数组形式给出\",{\"1\":{\"139\":1}}],[\"是一个常数\",{\"1\":{\"137\":1}}],[\"是一个native方法\",{\"1\":{\"74\":1}}],[\"是\",{\"1\":{\"137\":1}}],[\"是在\",{\"1\":{\"137\":1}}],[\"是算法中常见的位操作\",{\"1\":{\"133\":1}}],[\"是不是支持有序操作已没有意义\",{\"1\":{\"99\":1}}],[\"是有序集合\",{\"1\":{\"99\":1}}],[\"是无序集合\",{\"1\":{\"99\":2}}],[\"是否可以在\",{\"1\":{\"143\":1}}],[\"是否能使其有序\",{\"1\":{\"99\":1}}],[\"是否会超出当前数组的长度\",{\"1\":{\"75\":1}}],[\"是顺序容器\",{\"1\":{\"70\":1}}],[\"两堆\",{\"1\":{\"225\":1}}],[\"两数之和\",{\"0\":{\"222\":1},\"1\":{\"222\":1}}],[\"两道常考的阶乘算法题\",{\"0\":{\"135\":1}}],[\"两个指针再次相遇的那个单链表节点就是环的起点\",{\"1\":{\"217\":1}}],[\"两个指针再次相遇\",{\"1\":{\"217\":1}}],[\"两个指针以相同的速度向前跑\",{\"1\":{\"217\":1}}],[\"两个问题\",{\"1\":{\"212\":1}}],[\"两个数相乘结果末尾有\",{\"1\":{\"136\":1}}],[\"两个对象\",{\"1\":{\"95\":1}}],[\"两个常用数组拷贝方法\",{\"0\":{\"74\":1}}],[\"两种\",{\"1\":{\"95\":1}}],[\"两者在以相同的速度跑\",{\"1\":{\"217\":1}}],[\"两者相遇\",{\"1\":{\"217\":1}}],[\"两者都不是线程安全的\",{\"1\":{\"108\":1}}],[\"两者都不允许duplicate\",{\"1\":{\"108\":1}}],[\"两者都是无序map\",{\"1\":{\"108\":1}}],[\"两者不相等\",{\"1\":{\"76\":1}}],[\"两者指向的内存地址相同\",{\"1\":{\"44\":1}}],[\"02\",{\"1\":{\"219\":1}}],[\"0900\",{\"1\":{\"213\":1}}],[\"0100\",{\"1\":{\"213\":1}}],[\"0101\",{\"1\":{\"130\":1}}],[\"0b1010\",{\"1\":{\"142\":1}}],[\"0b0100\",{\"1\":{\"133\":1}}],[\"0b0010\",{\"1\":{\"133\":1}}],[\"0b0001\",{\"1\":{\"133\":1}}],[\"0即可\",{\"1\":{\"137\":1}}],[\"0的值是否存在即可\",{\"1\":{\"137\":1}}],[\"0090\",{\"1\":{\"213\":1}}],[\"0010\",{\"1\":{\"213\":1}}],[\"0011\",{\"1\":{\"131\":1}}],[\"0009\",{\"1\":{\"213\":1}}],[\"0000\",{\"1\":{\"213\":5}}],[\"00000110\",{\"1\":{\"130\":1}}],[\"00000000\",{\"1\":{\"130\":2}}],[\"0001\",{\"1\":{\"130\":1,\"213\":1}}],[\"0\",{\"1\":{\"73\":3,\"74\":2,\"75\":5,\"76\":6,\"79\":5,\"81\":1,\"82\":1,\"83\":2,\"84\":2,\"85\":1,\"86\":1,\"87\":4,\"99\":1,\"130\":6,\"131\":2,\"132\":2,\"133\":9,\"134\":36,\"136\":10,\"137\":13,\"140\":5,\"141\":5,\"142\":20,\"143\":8,\"203\":1,\"211\":2,\"212\":2,\"213\":13,\"219\":1,\"221\":1,\"222\":1,\"223\":1,\"226\":1,\"227\":1,\"243\":2,\"244\":1,\"245\":4}}],[\"的内部的某个节点\",{\"1\":{\"217\":1}}],[\"的内容\",{\"1\":{\"213\":1}}],[\"的逻辑\",{\"1\":{\"213\":1}}],[\"的限制\",{\"1\":{\"213\":1}}],[\"的空间复杂度之下找到重复和缺失的元素\",{\"1\":{\"143\":1}}],[\"的空数组\",{\"1\":{\"73\":1}}],[\"的形式相乘\",{\"1\":{\"142\":1}}],[\"的\",{\"1\":{\"141\":1}}],[\"的计算结果与\",{\"1\":{\"139\":1}}],[\"的右侧边界\",{\"1\":{\"137\":1}}],[\"的左侧边界\",{\"1\":{\"137\":1}}],[\"的左侧边界和右侧边界\",{\"1\":{\"137\":1}}],[\"的结果\",{\"1\":{\"137\":1}}],[\"的结果最多可以达到\",{\"1\":{\"137\":1}}],[\"的结果末尾恰好有\",{\"1\":{\"137\":1}}],[\"的结果末尾就有\",{\"1\":{\"136\":1}}],[\"的结果末尾有几个\",{\"1\":{\"136\":2}}],[\"的下界显然是\",{\"1\":{\"137\":1}}],[\"的增加\",{\"1\":{\"137\":1}}],[\"的对数\",{\"1\":{\"136\":1}}],[\"的倍数\",{\"1\":{\"136\":5}}],[\"的数组\",{\"1\":{\"134\":1,\"143\":1}}],[\"的数组拷贝方法\",{\"1\":{\"76\":1}}],[\"的技巧就很简单了\",{\"1\":{\"133\":1}}],[\"的指数\",{\"1\":{\"133\":2}}],[\"的二进制表示中有几个\",{\"1\":{\"133\":1}}],[\"的二进制表示中的最后一个\",{\"1\":{\"133\":1}}],[\"的运用\",{\"0\":{\"133\":1}}],[\"的原码\",{\"1\":{\"130\":1}}],[\"的优先级在按位操作符之上\",{\"1\":{\"129\":1}}],[\"的效率会更高\",{\"1\":{\"107\":1}}],[\"的意思是说对存储进集合的元素是否会自动排序或者按照我们自定义的方式进行排序\",{\"1\":{\"99\":1}}],[\"的查找效率\",{\"1\":{\"99\":1}}],[\"的映射表\",{\"1\":{\"95\":1}}],[\"的元素\",{\"1\":{\"79\":2}}],[\"的时间复杂度遍历数组是无法避免的\",{\"1\":{\"143\":1}}],[\"的时间复杂度\",{\"1\":{\"142\":2}}],[\"的时间复杂度进行幂运算\",{\"1\":{\"142\":1}}],[\"的时间复杂度不仅跟插入元素的多少有关\",{\"1\":{\"76\":1}}],[\"的时候返回的是一个itr对象\",{\"1\":{\"76\":1}}],[\"的方法ensurecapacity\",{\"1\":{\"75\":1}}],[\"的elementdata\",{\"1\":{\"73\":1}}],[\"的策略\",{\"1\":{\"58\":1}}],[\"默认nums数组升序\",{\"1\":{\"221\":1}}],[\"默认值为0\",{\"1\":{\"76\":1}}],[\"默认容量\",{\"1\":{\"73\":1}}],[\"默认的初始容量\",{\"1\":{\"73\":1}}],[\"构造函数3\",{\"1\":{\"73\":1}}],[\"构造函数2\",{\"1\":{\"73\":2}}],[\"构造函数1\",{\"1\":{\"73\":2}}],[\"构造函数\",{\"0\":{\"73\":1}}],[\"底层的数据结构负责实现自己的迭代器\",{\"1\":{\"98\":1}}],[\"底层的数组拷贝\",{\"1\":{\"74\":1}}],[\"底层用的就是数组\",{\"1\":{\"83\":1}}],[\"底层维护的数据结构\",{\"1\":{\"72\":1}}],[\"底层数据结构就是object类型的数组\",{\"1\":{\"72\":1}}],[\"底层数据结构\",{\"0\":{\"72\":1}}],[\"底层通过数组实现\",{\"1\":{\"70\":1}}],[\"用各种遍历框架序列化和反序列化二叉树\",{\"0\":{\"168\":1}}],[\"用数组元素的绝对值做下标\",{\"1\":{\"143\":1}}],[\"用\",{\"1\":{\"137\":1}}],[\"用一个\",{\"1\":{\"134\":1}}],[\"用户可以手动同步\",{\"1\":{\"70\":1}}],[\"用处\",{\"1\":{\"48\":1}}],[\"以找出引发警报的书\",{\"1\":{\"225\":1}}],[\"以此类推\",{\"1\":{\"213\":1}}],[\"以上面的八个数为基础进行第二次数据的更新\",{\"1\":{\"213\":1}}],[\"以上操作能够产生奇特效果的原因在于\",{\"1\":{\"132\":1}}],[\"以a^4为例\",{\"1\":{\"141\":1}}],[\"以\",{\"1\":{\"130\":1,\"134\":1,\"140\":1}}],[\"以避免数组扩容的发生\",{\"1\":{\"75\":1}}],[\"以减少递增式再分配的数量\",{\"1\":{\"75\":1}}],[\"以满足添加数据的需求\",{\"1\":{\"75\":1}}],[\"以便能够容纳任何类型的对象\",{\"1\":{\"70\":1}}],[\"以用户类和地址类举例说明其用法\",{\"1\":{\"30\":1}}],[\"前进时快指针fast在前\",{\"1\":{\"215\":1}}],[\"前序遍历\",{\"1\":{\"203\":1}}],[\"前序遍历head\",{\"1\":{\"203\":1}}],[\"前序遍历解法\",{\"0\":{\"170\":1}}],[\"前两个是二元运算符\",{\"1\":{\"131\":1}}],[\"前面已经提过\",{\"1\":{\"70\":1}}],[\"前言\",{\"0\":{\"58\":1}}],[\"容器主要包括\",{\"1\":{\"95\":1}}],[\"容器就是可以容纳其他java对象的对象\",{\"1\":{\"95\":1}}],[\"容器会自动增大底层数组的大小\",{\"1\":{\"70\":1}}],[\"容器内存储元素的个数不能多于当前容量\",{\"1\":{\"70\":1}}],[\"每个节点有\",{\"1\":{\"213\":1}}],[\"每个位置可以向上转\",{\"1\":{\"213\":1}}],[\"每个元素和数组索引有一定的对应关系\",{\"1\":{\"143\":1}}],[\"每个arraylist都有一个容量\",{\"1\":{\"70\":1}}],[\"每次进行扩散的方式不是并行扩散的\",{\"1\":{\"213\":1}}],[\"每次都是将一个节点周围的所有节点加入队列\",{\"1\":{\"210\":1}}],[\"每次必须移动后面的所有数据以保持连续\",{\"1\":{\"202\":1}}],[\"每次二分的时候都会调用一次\",{\"1\":{\"137\":1}}],[\"每次数组容量的增长大约是其原容量的1\",{\"1\":{\"75\":1}}],[\"每当向数组中添加元素时\",{\"1\":{\"75\":1}}],[\"每种类型都需要重载一个add方法\",{\"1\":{\"59\":1}}],[\"除非对应的位置被其他元素覆盖\",{\"1\":{\"79\":1}}],[\"除该类未实现同步外\",{\"1\":{\"70\":1}}],[\"除了子类中方法的返回类型是父类中返回类型的子类\",{\"1\":{\"59\":1}}],[\"允许放入null元素\",{\"1\":{\"70\":1}}],[\"允许value为null\",{\"1\":{\"34\":1}}],[\"概述\",{\"0\":{\"70\":1}}],[\"提供编译前的检查\",{\"1\":{\"59\":1}}],[\"无法判断当前链表含有环\",{\"1\":{\"216\":1}}],[\"无法约束其中的类型\",{\"1\":{\"59\":1}}],[\"无序\",{\"1\":{\"143\":1}}],[\"无序集合\",{\"1\":{\"99\":2}}],[\"无论正负\",{\"1\":{\"131\":1}}],[\"无论是否需要扩容\",{\"1\":{\"75\":1}}],[\"无符号\",{\"1\":{\"131\":1}}],[\"无参数的构造函数提供一个value=null的optional对象\",{\"1\":{\"31\":1}}],[\"无参构造函数\",{\"1\":{\"31\":1}}],[\"无参\",{\"1\":{\"30\":2}}],[\"编译器会检查类型\",{\"1\":{\"59\":1}}],[\"参考\",{\"0\":{\"90\":1,\"109\":1},\"1\":{\"59\":1,\"76\":1,\"131\":1,\"142\":1}}],[\"参数说明\",{\"1\":{\"74\":2}}],[\"参数个数不同甚至是参数顺序不同\",{\"1\":{\"59\":1}}],[\"参数类型不同\",{\"1\":{\"59\":1}}],[\"参数列表\",{\"1\":{\"59\":2}}],[\"顺序存储\",{\"1\":{\"202\":1}}],[\"顺序为插入顺序或者最近最少使用\",{\"1\":{\"108\":1}}],[\"顺序\",{\"1\":{\"59\":1,\"108\":1}}],[\"满足\",{\"1\":{\"137\":2}}],[\"满足结合律和交换律\",{\"1\":{\"134\":2}}],[\"满足一个类中\",{\"1\":{\"59\":1}}],[\"满足条件的\",{\"1\":{\"137\":1}}],[\"满足条件\",{\"1\":{\"40\":1,\"137\":2}}],[\"同时查询和修改效率也比较高\",{\"1\":{\"202\":1}}],[\"同时导致一个元素缺失了\",{\"1\":{\"143\":1}}],[\"同时寻找缺失和重复的元素\",{\"0\":{\"143\":1}}],[\"同时结果也是正确的\",{\"1\":{\"141\":1}}],[\"同时计数\",{\"1\":{\"133\":1}}],[\"同时把其后的\",{\"1\":{\"133\":1}}],[\"同时\",{\"1\":{\"59\":1}}],[\"同时提供了两个私有的构造函数\",{\"1\":{\"31\":1}}],[\"同名的方法如果有不同的参数列表\",{\"1\":{\"59\":1}}],[\"访问修饰符的限制一定要大于被重写方法的访问修饰符\",{\"1\":{\"59\":1}}],[\"方法也有两个版本\",{\"1\":{\"79\":1}}],[\"方法也就变得非常简单\",{\"1\":{\"77\":1}}],[\"方法同样很简单\",{\"1\":{\"78\":1}}],[\"方法类似\",{\"1\":{\"76\":1}}],[\"方法能够一次添加多个元素\",{\"1\":{\"76\":1}}],[\"方法完成的\",{\"1\":{\"76\":1}}],[\"方法\",{\"1\":{\"76\":4}}],[\"方法的时间开销跟添加元素的个数成正比\",{\"1\":{\"70\":1}}],[\"方法的时间开销跟插入位置有关\",{\"1\":{\"70\":1}}],[\"方法均能在常数时间内完成\",{\"1\":{\"70\":1}}],[\"方法名相同且参数不同\",{\"1\":{\"59\":1}}],[\"方法名\",{\"1\":{\"59\":1}}],[\"方法生成异常\",{\"1\":{\"47\":1}}],[\"子父类中多态性的表现\",{\"1\":{\"59\":1}}],[\"子类继承了父类原有的方法\",{\"1\":{\"59\":1}}],[\"但代价是空间复杂度要比dfs大很多\",{\"1\":{\"210\":1}}],[\"但正因为连续存储\",{\"1\":{\"202\":1}}],[\"但题目要求是\",{\"1\":{\"143\":1}}],[\"但int类型最大值才是2147483647\",{\"1\":{\"142\":1}}],[\"但这次\",{\"1\":{\"142\":1}}],[\"但会产生额外的空间开销\",{\"1\":{\"142\":1}}],[\"但指数运算的真实结果肯定会大得吓人\",{\"1\":{\"139\":1}}],[\"但上界是\",{\"1\":{\"137\":1}}],[\"但它是线程安全的\",{\"1\":{\"100\":1,\"107\":1}}],[\"但不支持有序性操作\",{\"1\":{\"99\":1}}],[\"但不能通过返回类型是否相同来判断重载\",{\"1\":{\"59\":1}}],[\"但不能说动物是老虎\",{\"1\":{\"59\":1}}],[\"但简化了设计和编程\",{\"1\":{\"95\":1}}],[\"但有时子类并不想原封不动的继承父类中的某个方法\",{\"1\":{\"59\":1}}],[\"但是保安露出不屑的眼神\",{\"1\":{\"225\":1}}],[\"但是仍然要懂得其原理\",{\"1\":{\"223\":1}}],[\"但是跑不出环\",{\"1\":{\"217\":1}}],[\"但是第⼆个密码锁的问题\",{\"1\":{\"213\":1}}],[\"但是还存在如下问题\",{\"1\":{\"213\":1}}],[\"但是树结构一般不用visited来防止走回头路\",{\"1\":{\"212\":1}}],[\"但是在二叉树等数据结构中却频繁用到该算法\",{\"1\":{\"212\":1}}],[\"但是在编译阶段会进行所谓的\",{\"1\":{\"58\":1}}],[\"但是对于bfs算法来说\",{\"1\":{\"212\":1}}],[\"但是对于linkedhashset\",{\"1\":{\"99\":1}}],[\"但是其空间复杂度高\",{\"1\":{\"212\":1}}],[\"但是bfs借助队列可以做到一步一步\",{\"1\":{\"212\":1}}],[\"但是实际上双向bfs\",{\"1\":{\"213\":1}}],[\"但是实际上比bfs低效很多\",{\"1\":{\"212\":1}}],[\"但是实际中很多题目的描述都是这个本质场景的各种变体\",{\"1\":{\"211\":1}}],[\"但是像一般的二叉树结构\",{\"1\":{\"211\":1}}],[\"但是图有可能出现环\",{\"1\":{\"203\":1}}],[\"但是正因为存储空间不连续\",{\"1\":{\"202\":1}}],[\"但是查询和修改就比较高效\",{\"1\":{\"202\":2}}],[\"但是现在出现了一些错误\",{\"1\":{\"143\":1}}],[\"但是现在你要装进去\",{\"1\":{\"134\":1}}],[\"但是二分搜索是对数级的复杂度\",{\"1\":{\"137\":1}}],[\"但是只能用来处理整数类型\",{\"1\":{\"131\":1}}],[\"但是可以允许多个null\",{\"1\":{\"108\":1}}],[\"但是可以快速地在链表中间插入和删除元素\",{\"1\":{\"100\":1}}],[\"但是底层一个是随机访问\",{\"1\":{\"100\":1}}],[\"但是支持有序操作\",{\"1\":{\"99\":1}}],[\"但是无序集合\",{\"1\":{\"99\":1}}],[\"但是modcount的值已经变为了2\",{\"1\":{\"76\":1}}],[\"但是arraylist不是线程安全的\",{\"1\":{\"76\":1}}],[\"但是该抛什么异常才能说明该问题呢\",{\"1\":{\"76\":1}}],[\"但是使用的时候没有指定\",{\"1\":{\"59\":1}}],[\"但是flatmap方法的lambda返回值总是optional类型\",{\"1\":{\"47\":1}}],[\"但是返回值会包装成optional实例\",{\"1\":{\"47\":1}}],[\"但是不得不承认\",{\"1\":{\"34\":1}}],[\"但是这个代码真的是非常的冗长和丑陋\",{\"1\":{\"30\":1}}],[\"重新优化后的代码\",{\"1\":{\"245\":1}}],[\"重新修正一下添加元素的时候应该保证的最小的容量mincapacity\",{\"1\":{\"75\":1}}],[\"重点掌握\",{\"1\":{\"142\":2}}],[\"重载\",{\"1\":{\"59\":1}}],[\"重载对返回类型没有要求\",{\"1\":{\"59\":1}}],[\"重载和重写的区别\",{\"1\":{\"59\":1}}],[\"重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常\",{\"1\":{\"59\":1}}],[\"重写\",{\"1\":{\"59\":1}}],[\"重写其实就是在子类中把父类本身有的方法重新写一遍\",{\"1\":{\"59\":1}}],[\"通过sum的大小来调节left和right的移动\",{\"1\":{\"222\":1}}],[\"通过对上述代码进行修改\",{\"1\":{\"213\":1}}],[\"通过上面的代码可以看到二叉树的遍历与链表的遍历方式非常相似\",{\"1\":{\"203\":1}}],[\"通过上图可以发现\",{\"1\":{\"134\":1}}],[\"通过索引快速找到对应的元素\",{\"1\":{\"202\":1}}],[\"通过entryset集合遍历\",{\"1\":{\"104\":2}}],[\"通过keyset集合遍历\",{\"1\":{\"104\":2}}],[\"通过记录modcount参数来实现\",{\"1\":{\"89\":1}}],[\"通过iterator方法获得迭代器之后\",{\"1\":{\"76\":1}}],[\"通过调用ensurecapacity方法来手动增加arraylist实例的容量\",{\"1\":{\"75\":1}}],[\"通过泛型\",{\"1\":{\"59\":1}}],[\"通过一组实现了function接口的lambda表达式传入操作\",{\"1\":{\"38\":1}}],[\"dfs是单打独斗\",{\"1\":{\"212\":1}}],[\"dfs是线\",{\"1\":{\"212\":1}}],[\"dfs也是可以找到最短路径的\",{\"1\":{\"212\":1}}],[\"dfs不行吗\",{\"1\":{\"212\":1}}],[\"d>n的时候退出循环\",{\"1\":{\"136\":1}}],[\"d有可能越界\",{\"1\":{\"136\":1}}],[\"d\",{\"1\":{\"132\":4,\"136\":9,\"137\":8}}],[\"dddd测试\",{\"1\":{\"88\":1}}],[\"dddd\",{\"1\":{\"88\":2}}],[\"down\",{\"1\":{\"213\":12}}],[\"do\",{\"1\":{\"79\":2,\"84\":1}}],[\"double等\",{\"1\":{\"95\":2}}],[\"doublevalue\",{\"1\":{\"59\":4}}],[\"double\",{\"1\":{\"59\":4,\"142\":7}}],[\"data\",{\"1\":{\"74\":1}}],[\"detectcycle\",{\"1\":{\"217\":1}}],[\"details\",{\"1\":{\"59\":1,\"90\":1,\"99\":2,\"225\":1}}],[\"deads集合和visited集合都是记录不合法访问的集合\",{\"1\":{\"213\":1}}],[\"deads\",{\"1\":{\"213\":9}}],[\"deadends\",{\"1\":{\"213\":7}}],[\"description\",{\"1\":{\"212\":2,\"221\":1,\"222\":1,\"223\":1,\"226\":1,\"243\":2,\"244\":1,\"245\":2}}],[\"destpos\",{\"1\":{\"74\":2}}],[\"destination\",{\"1\":{\"74\":2}}],[\"dest\",{\"1\":{\"74\":2}}],[\"depth++\",{\"1\":{\"212\":1}}],[\"depth\",{\"1\":{\"210\":1,\"212\":3}}],[\"debug\",{\"1\":{\"132\":3}}],[\"defaultcapacity\",{\"1\":{\"73\":2,\"75\":2}}],[\"default\",{\"1\":{\"47\":3,\"73\":1,\"75\":6}}],[\"binary\",{\"1\":{\"225\":1}}],[\"binarysearch\",{\"1\":{\"221\":1,\"226\":1,\"227\":1}}],[\"big\",{\"1\":{\"213\":1}}],[\"bithacks\",{\"1\":{\"132\":1}}],[\"broad\",{\"1\":{\"210\":1}}],[\"break\",{\"1\":{\"137\":1,\"143\":1,\"217\":1}}],[\"bfs算法还有一种稍微高级的优化思路\",{\"1\":{\"213\":1}}],[\"bfs算法套路框架\",{\"0\":{\"210\":1}}],[\"bfs还是有代价的\",{\"1\":{\"212\":1}}],[\"bfs是广度优先搜索\",{\"1\":{\"212\":1}}],[\"bfs是可以找到最短路径\",{\"1\":{\"212\":1}}],[\"bfs是集体行动\",{\"1\":{\"212\":1}}],[\"bfs是面\",{\"1\":{\"212\":1}}],[\"bfs的时间复杂度最坏情况是o\",{\"1\":{\"212\":1}}],[\"bfs的逻辑是depth每增加一次\",{\"1\":{\"212\":1}}],[\"bfs出现的场景\",{\"1\":{\"211\":1}}],[\"bfs找到的路径一定是最短的\",{\"1\":{\"210\":1}}],[\"bfs和dfs的区别\",{\"1\":{\"210\":1}}],[\"bfs都是用队列这种数据结构\",{\"1\":{\"210\":1}}],[\"bfs核心思想\",{\"1\":{\"210\":1}}],[\"bfs\",{\"1\":{\"210\":1,\"211\":1,\"213\":4}}],[\"by\",{\"1\":{\"142\":1}}],[\"byte\",{\"1\":{\"129\":1}}],[\"bound\",{\"1\":{\"137\":4}}],[\"boolean\",{\"1\":{\"40\":2,\"41\":1,\"44\":1,\"76\":4,\"79\":6,\"81\":1,\"82\":1,\"88\":2,\"132\":2,\"133\":2,\"216\":2,\"243\":1,\"244\":1,\"245\":4}}],[\"blknemo\",{\"1\":{\"131\":1}}],[\"blog\",{\"1\":{\"59\":1,\"90\":1,\"99\":2}}],[\"bd9peqcf82n\",{\"1\":{\"115\":1}}],[\"bb测试\",{\"1\":{\"88\":1}}],[\"bb\",{\"1\":{\"88\":2}}],[\"but\",{\"1\":{\"83\":1}}],[\"basic\",{\"1\":{\"225\":1}}],[\"base规模缩小的问题\",{\"1\":{\"141\":1}}],[\"base是\",{\"1\":{\"141\":1}}],[\"base\",{\"1\":{\"141\":14,\"142\":6}}],[\"batchremove\",{\"1\":{\"79\":3}}],[\"back\",{\"1\":{\"76\":1}}],[\"behavioral\",{\"1\":{\"79\":1}}],[\"be\",{\"1\":{\"74\":3,\"75\":1}}],[\"b\",{\"1\":{\"59\":16,\"132\":12,\"139\":3,\"140\":19,\"141\":22,\"142\":22}}],[\"代码框架\",{\"0\":{\"158\":1}}],[\"代码实现\",{\"0\":{\"154\":1,\"196\":1}}],[\"代码演示\",{\"1\":{\"104\":1}}],[\"代码如下\",{\"1\":{\"86\":1,\"212\":1}}],[\"代码复用\",{\"1\":{\"59\":1}}],[\"代表value值是可为空的\",{\"1\":{\"34\":1}}],[\"适用于多种数据类型执行相同的代码\",{\"1\":{\"59\":1}}],[\"接口和方法中\",{\"1\":{\"59\":1}}],[\"也是存在计算冗余的\",{\"1\":{\"243\":1}}],[\"也不支持有序操作\",{\"1\":{\"99\":1}}],[\"也跟插入的位置相关\",{\"1\":{\"76\":1}}],[\"也会存在移动元素的情况\",{\"1\":{\"76\":1}}],[\"也就⽆法使⽤双向bfs\",{\"1\":{\"213\":1}}],[\"也就同时导致了另一个元素的缺失\",{\"1\":{\"143\":1}}],[\"也就一定不会造成溢出\",{\"1\":{\"141\":1}}],[\"也就是找到了最短距离\",{\"1\":{\"213\":1}}],[\"也就是有\",{\"1\":{\"213\":1}}],[\"也就是n\",{\"1\":{\"212\":1}}],[\"也就是o\",{\"1\":{\"212\":1}}],[\"也就是根节点到叶子节点的最短距离\",{\"1\":{\"212\":1}}],[\"也就是非递归快速幂\",{\"1\":{\"142\":1}}],[\"也就是快速幂\",{\"1\":{\"142\":1}}],[\"也就是余数\",{\"1\":{\"139\":1}}],[\"也就是上界和下界\",{\"1\":{\"137\":1}}],[\"也就是\",{\"1\":{\"136\":1,\"142\":1}}],[\"也就是说\",{\"1\":{\"137\":1,\"139\":2}}],[\"也就是说阶乘结果的末尾有\",{\"1\":{\"136\":1}}],[\"也就是说hashset不会对存储的元素进行排序\",{\"1\":{\"99\":1}}],[\"也就是说使用\",{\"1\":{\"99\":1}}],[\"也就是说有一个线程在读数据\",{\"1\":{\"76\":1}}],[\"也就是说在泛型使用过程中\",{\"1\":{\"59\":1}}],[\"也就每次add或者remove它的值都会加1\",{\"1\":{\"76\":1}}],[\"也就意味着该方法有着线性的时间复杂度\",{\"1\":{\"76\":1}}],[\"也可以向下转\",{\"1\":{\"213\":1}}],[\"也可以很容易查出那个缺失的元素\",{\"1\":{\"134\":1}}],[\"也可以使用ensurecapacity来手动增加arraylist实例的容量\",{\"1\":{\"75\":1}}],[\"也可以通过方法返回值得到\",{\"1\":{\"47\":1}}],[\"也可使用vector替代\",{\"1\":{\"70\":1}}],[\"就应该想到使用双指针技巧\",{\"1\":{\"222\":1}}],[\"就相当于轮流扩散\",{\"1\":{\"213\":1}}],[\"就思考⼀个问题\",{\"1\":{\"213\":1}}],[\"就找到了那个缺失的元素\",{\"1\":{\"143\":1}}],[\"就找到了那个重复的元素\",{\"1\":{\"143\":1}}],[\"就可以把\",{\"1\":{\"137\":1}}],[\"就可以算出来有多少个\",{\"1\":{\"137\":1}}],[\"就可以很容易的找到缺失的那个元素\",{\"1\":{\"134\":1}}],[\"就可以仅仅把最后一个\",{\"1\":{\"133\":1}}],[\"就使用arraylist\",{\"1\":{\"100\":1}}],[\"就用linkedlist\",{\"1\":{\"100\":1}}],[\"就是每次将少的那个集合进行扩散\",{\"1\":{\"213\":1}}],[\"就是扩散\",{\"1\":{\"213\":1}}],[\"就是答案\",{\"1\":{\"137\":1}}],[\"就是让你返回\",{\"1\":{\"133\":1}}],[\"就是说存储的顺序和读取的顺序有可能不一致\",{\"1\":{\"108\":1}}],[\"就是说对于treeset和hashset\",{\"1\":{\"99\":1}}],[\"就是当前迭代的位置不是数组的最大容量值就返回true\",{\"1\":{\"76\":1}}],[\"就指定其容量\",{\"1\":{\"75\":1}}],[\"就会直接报异常\",{\"1\":{\"76\":1}}],[\"就会给一个默认容量\",{\"1\":{\"73\":1}}],[\"就会把一个空数组给elementdata\",{\"1\":{\"73\":1}}],[\"就创建一个长度为initialcapacity的object数组\",{\"1\":{\"73\":1}}],[\"就像完全没有泛型一样\",{\"1\":{\"58\":1}}],[\"就返回传入的other对象\",{\"1\":{\"35\":1}}],[\"其细节在于到底要给mid加1还是减1\",{\"1\":{\"225\":1}}],[\"其抽象是以图的概念进行说明\",{\"1\":{\"212\":1}}],[\"其他情况用的还是dfs多一些\",{\"1\":{\"212\":1}}],[\"其他的数据结构\",{\"1\":{\"202\":1}}],[\"其实链表也有前序遍历和后序遍历\",{\"1\":{\"203\":1}}],[\"其实就是在问\",{\"1\":{\"137\":1}}],[\"其中dfs可被认为就是前面的回溯算法\",{\"1\":{\"210\":1}}],[\"其中本来装着\",{\"1\":{\"143\":1}}],[\"其中\",{\"1\":{\"141\":1}}],[\"其中少了某一个数字\",{\"1\":{\"134\":1}}],[\"其中4个是位逻辑运算符\",{\"1\":{\"129\":1}}],[\"其索引应该在\",{\"1\":{\"134\":1}}],[\"其核心逻辑就是\",{\"1\":{\"133\":1}}],[\"其方法声明\",{\"1\":{\"103\":1}}],[\"其存储和取出元素的顺序是一致的\",{\"1\":{\"99\":1}}],[\"其查找效率不如\",{\"1\":{\"99\":1}}],[\"其始于jdk\",{\"1\":{\"95\":1}}],[\"其余方法大都是线性时间\",{\"1\":{\"70\":1}}],[\"其余跟vector大致相同\",{\"1\":{\"70\":1}}],[\"其对应的原生态类型\",{\"1\":{\"58\":1}}],[\"其本质是内部有一个泛型容器存储外部需要判断null值的对象\",{\"1\":{\"31\":1}}],[\"尖括号中的内容\",{\"1\":{\"58\":1}}],[\"将最小的那个给q1\",{\"1\":{\"213\":1}}],[\"将⼀个节点的未遍历相邻节点加⼊集合\",{\"1\":{\"213\":2}}],[\"将⼀个节点的未遍历相邻节点加⼊队列\",{\"1\":{\"213\":1}}],[\"将⼀个节点的相邻节点加⼊队列\",{\"1\":{\"213\":1}}],[\"将\",{\"1\":{\"213\":6}}],[\"将当前队列中的所有节点向周围扩散\",{\"1\":{\"213\":2}}],[\"将当前队列中的所有节点向四周扩散\",{\"1\":{\"211\":1}}],[\"将当前节点相邻的所有节点放入队列\",{\"1\":{\"212\":1}}],[\"将cur的相邻节点加入队列\",{\"1\":{\"211\":1}}],[\"将cursor的值执行++操作\",{\"1\":{\"76\":1}}],[\"将起点加入队列中\",{\"1\":{\"211\":1}}],[\"将原问题化简\",{\"1\":{\"140\":1,\"141\":1}}],[\"将modcount的值变为2\",{\"1\":{\"76\":1}}],[\"将所有的泛型表示\",{\"1\":{\"58\":1}}],[\"将创建包含mapper返回值的optional对象作为map方法返回值\",{\"1\":{\"38\":1}}],[\"类似\",{\"1\":{\"100\":1,\"107\":1}}],[\"类关系图\",{\"0\":{\"94\":1}}],[\"类型的最大值\",{\"1\":{\"137\":2}}],[\"类型安全\",{\"1\":{\"59\":1}}],[\"类型\",{\"1\":{\"59\":1}}],[\"类型擦除\",{\"1\":{\"58\":1}}],[\"类加载的时候就已经初始化完成该optional对象\",{\"1\":{\"31\":1}}],[\"即可\",{\"1\":{\"244\":1}}],[\"即o\",{\"1\":{\"212\":1}}],[\"即队列的头元素\",{\"1\":{\"211\":1}}],[\"即最大值是231\",{\"1\":{\"142\":1}}],[\"即为对\",{\"1\":{\"142\":1}}],[\"即为递归的层数\",{\"1\":{\"142\":2}}],[\"即7\",{\"1\":{\"142\":1}}],[\"即有\",{\"1\":{\"137\":1}}],[\"即只出现一次的数字\",{\"1\":{\"134\":1}}],[\"即n个数\",{\"1\":{\"134\":1}}],[\"即n+1个数\",{\"1\":{\"134\":1}}],[\"即\",{\"1\":{\"130\":3,\"134\":2,\"141\":1}}],[\"即是一个无序集合\",{\"1\":{\"99\":1}}],[\"即并发修改异常\",{\"1\":{\"76\":1}}],[\"即在此过程进行new\",{\"1\":{\"75\":1}}],[\"即元素存放的数据与放进去的顺序相同\",{\"1\":{\"70\":1}}],[\"即java在语法上支持泛型\",{\"1\":{\"58\":1}}],[\"即空指针问题\",{\"1\":{\"30\":1}}],[\"因子\",{\"1\":{\"136\":1}}],[\"因此会消耗相对更多的存储空间\",{\"1\":{\"202\":1}}],[\"因此可以随机访问\",{\"1\":{\"202\":1}}],[\"因此在添加元素之前\",{\"1\":{\"76\":1}}],[\"因此在实际使用时\",{\"1\":{\"75\":1}}],[\"因此为了兼容之前的版本\",{\"1\":{\"58\":1}}],[\"因为乘法因子的对称性\",{\"1\":{\"245\":1}}],[\"因为0和1也都是true\",{\"1\":{\"245\":2}}],[\"因为是后半部分是前半部分的因子交换所得\",{\"1\":{\"244\":1}}],[\"因为fast虽然跑得快\",{\"1\":{\"217\":1}}],[\"因为环形链表中没有空指针null\",{\"1\":{\"216\":1}}],[\"因为双向bfs的代码只是更换了返回结果的方式\",{\"1\":{\"213\":1}}],[\"因为按照\",{\"1\":{\"213\":1}}],[\"因为必须要知道终点在哪⾥\",{\"1\":{\"213\":1}}],[\"因为根本就没有子节点到父节点的指针存在\",{\"1\":{\"212\":1}}],[\"因为二叉树是最容易培养框架思维的\",{\"1\":{\"204\":1}}],[\"因为二分查找需要给一个搜索区间\",{\"1\":{\"137\":1}}],[\"因为图就是好几个n叉树的结合体\",{\"1\":{\"203\":1}}],[\"因为随着\",{\"1\":{\"137\":1}}],[\"因为每个偶数都能分解出因子\",{\"1\":{\"136\":1}}],[\"因为\",{\"1\":{\"107\":1,\"133\":1,\"136\":2,\"137\":1}}],[\"因为linkedlist的节点除了存储数据\",{\"1\":{\"100\":1}}],[\"因为当元素被添加到linkedlist任意位置的时候\",{\"1\":{\"100\":1}}],[\"因为arraylist被设计成非同步的\",{\"1\":{\"76\":1}}],[\"因为所有的对象都继承了obejct\",{\"1\":{\"72\":1}}],[\"因为有参数的构造方法底层调用了objects的requirenonnull方法\",{\"1\":{\"32\":1}}],[\"因为它调用了objects类的requirenonnull方法\",{\"1\":{\"31\":1}}],[\"并最终生成一个结果\",{\"1\":{\"130\":1}}],[\"并且相遇点肯定是在环内部\",{\"1\":{\"217\":1}}],[\"并且\",{\"1\":{\"107\":1}}],[\"并且不会导致数据不一致\",{\"1\":{\"107\":1}}],[\"并且失去了元素的插入顺序信息\",{\"1\":{\"99\":1}}],[\"并且将创建包含mapper返回值的optional对象作为map方法返回值\",{\"1\":{\"48\":1}}],[\"并不等于size的值为0\",{\"1\":{\"76\":1}}],[\"并不等于size=1\",{\"1\":{\"76\":1}}],[\"并不是在原来的数组上面增大length\",{\"1\":{\"75\":1}}],[\"并自动将每个function的结果包装成一个optional对象\",{\"1\":{\"47\":1}}],[\"否则会遗漏b=0的情况\",{\"1\":{\"140\":1,\"141\":1,\"142\":2}}],[\"否则可能溢出\",{\"1\":{\"139\":1}}],[\"否则输出位是\",{\"1\":{\"130\":1}}],[\"否则输入位是\",{\"1\":{\"130\":1}}],[\"否则原来的对象就一直不会被回收\",{\"1\":{\"79\":1}}],[\"否则抛出supplier接口创建的异常\",{\"1\":{\"48\":1}}],[\"否则抛出nosuchelementexception\",{\"1\":{\"48\":1}}],[\"否则不做处理\",{\"1\":{\"48\":1}}],[\"否则返回指定的其它值\",{\"1\":{\"48\":1}}],[\"否则返回false\",{\"1\":{\"48\":1}}],[\"否则返回空optional\",{\"1\":{\"47\":1}}],[\"否则返回空optional对象\",{\"1\":{\"38\":1,\"39\":1,\"40\":1,\"48\":3}}],[\"否则返回传入的错误信息\",{\"1\":{\"47\":1}}],[\"则是从起点和终点同时开始扩散\",{\"1\":{\"213\":1}}],[\"则这个数是重复值\",{\"1\":{\"143\":1}}],[\"则计算机会计算两次\",{\"1\":{\"142\":2}}],[\"则7的5次方为49\",{\"1\":{\"142\":1}}],[\"则b=4\",{\"1\":{\"141\":1}}],[\"则直接return\",{\"1\":{\"137\":1}}],[\"则高位插入\",{\"1\":{\"131\":2}}],[\"则输出1\",{\"1\":{\"130\":1}}],[\"则输出0\",{\"1\":{\"130\":1}}],[\"则为0\",{\"1\":{\"130\":1}}],[\"则为1\",{\"1\":{\"130\":2}}],[\"则为\",{\"1\":{\"99\":1}}],[\"则为其调用consumer\",{\"1\":{\"48\":1}}],[\"则视为重载\",{\"1\":{\"59\":1}}],[\"则返回true\",{\"1\":{\"48\":1}}],[\"则返回一个空的optional对象\",{\"1\":{\"48\":1}}],[\"则对其执行调用mapper函数得到返回值\",{\"1\":{\"38\":1,\"48\":1}}],[\"一行代码就能解决的算法题\",{\"0\":{\"260\":1}}],[\"一行代码解决的算法题\",{\"0\":{\"146\":1}}],[\"一般实现\",{\"0\":{\"243\":1}}],[\"一般初始化规则如下\",{\"1\":{\"220\":1}}],[\"一般来说在找最短路径的时候用的是bfs\",{\"1\":{\"212\":1}}],[\"一般来说\",{\"1\":{\"210\":1}}],[\"一类事\",{\"1\":{\"214\":1}}],[\"一类是\",{\"1\":{\"214\":1}}],[\"一是如何处理用数组表示的指数\",{\"1\":{\"139\":1}}],[\"一句代码解决问题\",{\"1\":{\"133\":1}}],[\"一定是因为两个数中有因子\",{\"1\":{\"136\":1}}],[\"一定可以消除最后一个\",{\"1\":{\"133\":1}}],[\"一定要先通过其静态方法\",{\"1\":{\"48\":1}}],[\"一元操作符\",{\"1\":{\"130\":1}}],[\"一个笑话\",{\"1\":{\"225\":1}}],[\"一个跑得慢\",{\"1\":{\"216\":1}}],[\"一个跑得快\",{\"1\":{\"216\":1}}],[\"一个直观地暴力解法就是穷举\",{\"1\":{\"137\":1}}],[\"一个数等于两个数相乘\",{\"1\":{\"244\":1}}],[\"一个数和\",{\"1\":{\"134\":2}}],[\"一个数和它本身做异或运算结果为\",{\"1\":{\"134\":1}}],[\"一个数如果是\",{\"1\":{\"133\":1}}],[\"一个指向后一个元素\",{\"1\":{\"100\":1}}],[\"一个指向前一个元素\",{\"1\":{\"100\":1}}],[\"一个是顺序访问\",{\"1\":{\"100\":1}}],[\"一个是remove\",{\"1\":{\"79\":1}}],[\"一个是从指定位置开始插入的addall\",{\"1\":{\"76\":1}}],[\"一个是在末尾添加的addall\",{\"1\":{\"76\":1}}],[\"一个类中多态性的表现\",{\"1\":{\"59\":1}}],[\"一个东西存在那么自然有存在的价值\",{\"1\":{\"34\":1}}],[\"操作指针即可删除该元素或者插入新元素\",{\"1\":{\"202\":1}}],[\"操作的逆过程\",{\"1\":{\"79\":1}}],[\"操作的数据类型被指定为一个参数\",{\"1\":{\"59\":1}}],[\"操作\",{\"1\":{\"47\":1}}],[\"60\",{\"1\":{\"131\":1}}],[\"6347425\",{\"1\":{\"90\":1}}],[\"6\",{\"1\":{\"47\":5,\"99\":5,\"130\":3,\"136\":2,\"137\":1,\"140\":1}}],[\"抛出nosuchelementexception\",{\"1\":{\"47\":1}}],[\"例如值为\",{\"1\":{\"47\":1}}],[\"创建了新数组\",{\"1\":{\"75\":1}}],[\"创建一个子类对象\",{\"1\":{\"59\":2}}],[\"创建没有值的optional实例\",{\"1\":{\"47\":1}}],[\"创建optional实例\",{\"1\":{\"47\":1}}],[\"head\",{\"1\":{\"203\":4,\"216\":6,\"217\":3,\"218\":2,\"219\":2}}],[\"heap\",{\"1\":{\"76\":1}}],[\"hi\",{\"1\":{\"137\":16}}],[\"hammingweight\",{\"1\":{\"133\":1}}],[\"hamming\",{\"1\":{\"133\":1}}],[\"hacks的外国网站收集了几乎所有位操作的黑科技玩法\",{\"1\":{\"132\":1}}],[\"hascycle\",{\"1\":{\"216\":2}}],[\"hashtable<>\",{\"1\":{\"143\":1}}],[\"hashtable<integer\",{\"1\":{\"143\":1}}],[\"hashtable\",{\"0\":{\"107\":1},\"1\":{\"107\":1,\"143\":7}}],[\"hashmap<string\",{\"1\":{\"108\":1}}],[\"hashmap<>\",{\"1\":{\"104\":1,\"108\":1}}],[\"hashmap是无序map\",{\"1\":{\"108\":1}}],[\"hashmap可以允许一个null\",{\"1\":{\"108\":1}}],[\"hashmap和treemap都继承自abstractmap\",{\"1\":{\"108\":1}}],[\"hashmap\",{\"0\":{\"106\":1},\"1\":{\"107\":1,\"109\":1}}],[\"hashset<>\",{\"1\":{\"99\":1,\"134\":1,\"213\":12}}],[\"hashset<integer>\",{\"1\":{\"99\":2,\"134\":1}}],[\"hashset不支持有序性操作的理解\",{\"1\":{\"99\":1}}],[\"hashset\",{\"1\":{\"99\":6,\"134\":2,\"213\":1}}],[\"hashcode\",{\"0\":{\"45\":1},\"1\":{\"45\":2}}],[\"hasnext的判断条件为cursor\",{\"1\":{\"76\":1}}],[\"hasnext\",{\"1\":{\"76\":2,\"99\":4,\"104\":1}}],[\"http\",{\"1\":{\"132\":1}}],[\"https\",{\"1\":{\"19\":1,\"59\":1,\"75\":1,\"76\":1,\"90\":5,\"99\":2,\"109\":3,\"115\":12,\"131\":1,\"142\":2}}],[\"ht5rqde6q1k\",{\"1\":{\"115\":1}}],[\"html\",{\"1\":{\"75\":1,\"76\":1,\"90\":4,\"109\":2,\"131\":1,\"132\":1}}],[\"hugecapacity\",{\"1\":{\"75\":2}}],[\"比\",{\"1\":{\"137\":2}}],[\"比如二分搜索\",{\"1\":{\"214\":1}}],[\"比如典型的判定链表中是否包含环\",{\"1\":{\"214\":1}}],[\"比如从0000转到1000之后\",{\"1\":{\"213\":1}}],[\"比如在二维数组中\",{\"1\":{\"211\":1}}],[\"比如在二分查找中\",{\"1\":{\"141\":1}}],[\"比如哈希表\",{\"1\":{\"202\":1}}],[\"比如说输入\",{\"1\":{\"136\":1,\"137\":1}}],[\"比如说\",{\"1\":{\"134\":1,\"136\":1,\"137\":1}}],[\"比如大家可能都有这样的经历\",{\"1\":{\"30\":1}}],[\"比较两个optional的value值是不是相同\",{\"1\":{\"44\":1}}],[\"返回倒数第k个节点\",{\"1\":{\"219\":1}}],[\"返回这个环的起始位置\",{\"0\":{\"217\":1}}],[\"返回步数\",{\"1\":{\"213\":1}}],[\"返回的是取模之后的结果\",{\"1\":{\"142\":2}}],[\"返回的是value值一定不为null的optional对象\",{\"1\":{\"32\":1}}],[\"返回元素的个数\",{\"1\":{\"80\":1}}],[\"返回类型\",{\"1\":{\"59\":1}}],[\"返回类型都相同的情况下\",{\"1\":{\"59\":1}}],[\"返回optional值\",{\"1\":{\"47\":1}}],[\"返回值为空的optional对象\",{\"1\":{\"40\":1}}],[\"返回包含该值的option对象\",{\"1\":{\"40\":1}}],[\"8ouajxfvgux\",{\"1\":{\"115\":1}}],[\"80089609\",{\"1\":{\"99\":1}}],[\"80558739\",{\"1\":{\"59\":1}}],[\"8\",{\"1\":{\"40\":1,\"47\":1,\"75\":1,\"99\":4,\"130\":1,\"137\":1,\"213\":3}}],[\"82\",{\"1\":{\"37\":1}}],[\"lfu核心逻辑\",{\"0\":{\"159\":1}}],[\"l\",{\"1\":{\"141\":1}}],[\"l+\",{\"1\":{\"141\":1}}],[\"l+r\",{\"1\":{\"141\":1}}],[\"lru算法设计\",{\"0\":{\"153\":1}}],[\"lru算法描述\",{\"0\":{\"152\":1}}],[\"lru\",{\"1\":{\"108\":1}}],[\"linux命令速查手册\",{\"1\":{\"115\":1}}],[\"linkedtreemap\",{\"1\":{\"108\":6}}],[\"linkedhashmap<>\",{\"1\":{\"108\":1}}],[\"linkedhashmap<string\",{\"1\":{\"108\":1}}],[\"linkedhashmap是有序map\",{\"1\":{\"108\":1}}],[\"linkedhashmap\",{\"0\":{\"108\":1},\"1\":{\"108\":6}}],[\"linkedhashset<>\",{\"1\":{\"99\":1}}],[\"linkedhashset\",{\"1\":{\"99\":2}}],[\"linkedlist<>\",{\"1\":{\"212\":1,\"213\":2}}],[\"linkedlist比arraylist更占内存\",{\"1\":{\"100\":1}}],[\"linkedlist优于arraylist\",{\"1\":{\"100\":1}}],[\"linkedlist的实现是基于双向链表\",{\"1\":{\"100\":1}}],[\"linkedlist\",{\"1\":{\"100\":2,\"101\":1}}],[\"listnode\",{\"1\":{\"203\":5,\"216\":3,\"217\":3,\"218\":3,\"219\":3}}],[\"list放置索引和nums中的所有值\",{\"1\":{\"134\":1}}],[\"list<e>\",{\"1\":{\"85\":1}}],[\"list<string>\",{\"1\":{\"59\":1,\"76\":1}}],[\"list中只能放string\",{\"1\":{\"59\":1}}],[\"list中的元素都是object类型\",{\"1\":{\"59\":1}}],[\"list\",{\"0\":{\"100\":1},\"1\":{\"59\":6,\"76\":4,\"79\":3,\"88\":12,\"134\":4}}],[\"lo\",{\"1\":{\"137\":18}}],[\"log⁡n\",{\"1\":{\"142\":5}}],[\"logk\",{\"1\":{\"137\":2}}],[\"log\",{\"1\":{\"132\":3,\"137\":1}}],[\"logn\",{\"1\":{\"99\":1,\"136\":1,\"141\":1,\"212\":1}}],[\"long\",{\"1\":{\"95\":2,\"129\":1,\"136\":1,\"137\":26,\"142\":2}}],[\"longname\",{\"1\":{\"47\":2}}],[\"lzh\",{\"1\":{\"75\":1,\"90\":1}}],[\"leetcode\",{\"1\":{\"142\":2}}],[\"leetcode相关题目\",{\"1\":{\"133\":2,\"134\":2,\"136\":1,\"137\":1,\"139\":1,\"142\":1,\"143\":2,\"212\":1,\"213\":1,\"219\":1}}],[\"left++\",{\"1\":{\"222\":1,\"223\":1}}],[\"left=0\",{\"1\":{\"220\":1}}],[\"left\",{\"1\":{\"137\":2,\"203\":2,\"212\":5,\"221\":4,\"222\":4,\"223\":4,\"226\":6,\"227\":5}}],[\"let\",{\"1\":{\"79\":2,\"84\":1}}],[\"less\",{\"1\":{\"47\":3,\"99\":1}}],[\"length=capacity\",{\"1\":{\"72\":1}}],[\"length\",{\"1\":{\"40\":2,\"47\":5,\"73\":1,\"74\":4,\"75\":3,\"76\":4,\"83\":2,\"86\":1,\"88\":2,\"134\":7,\"140\":3,\"141\":3,\"143\":5,\"203\":1,\"221\":1,\"222\":1,\"223\":1,\"227\":1,\"245\":2}}],[\"labuladong的算法小抄\",{\"1\":{\"115\":1}}],[\"lastindexof\",{\"0\":{\"87\":1},\"1\":{\"87\":1}}],[\"last\",{\"1\":{\"76\":1}}],[\"lastret\",{\"1\":{\"76\":7}}],[\"larger\",{\"1\":{\"75\":1}}],[\"lambda表达式返回值会包装为optional实例\",{\"1\":{\"47\":1}}],[\"lambda表达式会处理并在其上执行操作\",{\"1\":{\"47\":1}}],[\"lang\",{\"1\":{\"37\":1,\"59\":1}}],[\"而dfs的空间复杂度较低\",{\"1\":{\"212\":1}}],[\"而不是<\",{\"1\":{\"227\":1}}],[\"而不是冒着在将来某个不确定时间发生任意不确定行为的风险\",{\"1\":{\"89\":1}}],[\"而不要纠结于细节\",{\"1\":{\"204\":1}}],[\"而这些70b100\",{\"1\":{\"142\":1}}],[\"而且就算是使用isprime函数\",{\"1\":{\"243\":1}}],[\"而且大部分的常考算法本质上都是树的遍历问题\",{\"1\":{\"204\":1}}],[\"而且由于每个元素必须存储指向前后元素位置的指针\",{\"1\":{\"202\":1}}],[\"而且如果想在数组中间和开始位置进行插入和删除操作\",{\"1\":{\"202\":1}}],[\"而且相对节约存储空间\",{\"1\":{\"202\":1}}],[\"而且会有一个索引没有元素对应过去\",{\"1\":{\"143\":1}}],[\"而且后续很多算法也都会用到快速幂\",{\"1\":{\"142\":1}}],[\"而且数组的特点是随机访问\",{\"1\":{\"140\":1}}],[\"而treemap不允许null\",{\"1\":{\"108\":1}}],[\"而treemap实现的是navigablemap接口\",{\"1\":{\"108\":1}}],[\"而linkedlist的每一个元素都依靠地址指针和它后一个元素连接在一起\",{\"1\":{\"100\":1}}],[\"而linkedhashset是属于有序的集合\",{\"1\":{\"99\":1}}],[\"而hashset是没有的\",{\"1\":{\"99\":1}}],[\"而hashset不支持有序性操作\",{\"1\":{\"99\":1}}],[\"而\",{\"1\":{\"95\":1}}],[\"而是使用else\",{\"1\":{\"226\":1}}],[\"而是轮流进行扩散\",{\"1\":{\"213\":1}}],[\"而是数组中有效数据的个数\",{\"1\":{\"80\":1}}],[\"而是要立即报告\",{\"1\":{\"34\":1}}],[\"而flatmap方法的mapper函数必须是optional对象\",{\"1\":{\"39\":1}}],[\"为了简化\",{\"1\":{\"219\":1}}],[\"为了方便对代码的理解\",{\"1\":{\"36\":1}}],[\"为什么left\",{\"1\":{\"227\":1}}],[\"为什么while循环的条件中是<=\",{\"1\":{\"227\":1}}],[\"为什么bfs可以找到最短距离\",{\"1\":{\"212\":1}}],[\"为什么会引入泛型\",{\"0\":{\"59\":1}}],[\"为多少\",{\"1\":{\"137\":1}}],[\"为止\",{\"1\":{\"133\":1}}],[\"为例\",{\"1\":{\"130\":1,\"134\":1}}],[\"为负\",{\"1\":{\"130\":1}}],[\"为正\",{\"1\":{\"130\":1}}],[\"为java开发者提供了通用的容器\",{\"1\":{\"95\":1}}],[\"为追求效率\",{\"1\":{\"70\":1}}],[\"为其执行mapper函数返回optional类型返回值\",{\"1\":{\"48\":1}}],[\"为其执行mapper函数返回optional对象类型返回值\",{\"1\":{\"39\":1}}],[\"为指定的值创建一个optional对象\",{\"1\":{\"48\":1}}],[\"为null的值创建一个optional对象\",{\"1\":{\"48\":1}}],[\"为非null的值创建一个optional对象\",{\"1\":{\"48\":1}}],[\"+inf\",{\"1\":{\"137\":2}}],[\"+=\",{\"1\":{\"76\":2,\"79\":2,\"134\":1,\"136\":3,\"137\":2,\"213\":2,\"245\":2}}],[\"+\",{\"1\":{\"38\":2,\"39\":2,\"47\":1,\"59\":29,\"73\":1,\"75\":1,\"76\":8,\"88\":2,\"99\":3,\"104\":6,\"108\":16,\"134\":2,\"136\":2,\"137\":9,\"143\":2,\"221\":2,\"222\":3,\"226\":2,\"227\":3}}],[\"i不需要遍历到n\",{\"1\":{\"244\":1}}],[\"import\",{\"1\":{\"143\":1}}],[\"implements\",{\"1\":{\"76\":1}}],[\"i3\",{\"1\":{\"132\":2}}],[\"i2\",{\"1\":{\"132\":2}}],[\"i1\",{\"1\":{\"132\":2}}],[\"idea\",{\"1\":{\"225\":1}}],[\"idea快捷键\",{\"1\":{\"59\":1}}],[\"idnumber\",{\"1\":{\"99\":1}}],[\"i++\",{\"1\":{\"76\":1,\"79\":1,\"84\":1,\"87\":2,\"134\":4,\"136\":1,\"140\":1,\"141\":1,\"143\":3,\"203\":1,\"211\":1,\"212\":1,\"213\":2,\"243\":2,\"244\":1,\"245\":4}}],[\"i\",{\"1\":{\"76\":11,\"79\":3,\"84\":3,\"87\":18,\"99\":3,\"131\":8,\"134\":15,\"136\":3,\"140\":2,\"141\":2,\"143\":11,\"203\":3,\"211\":2,\"212\":2,\"213\":4,\"243\":6,\"244\":4,\"245\":18}}],[\"item\",{\"1\":{\"104\":3}}],[\"iteration\",{\"1\":{\"76\":1}}],[\"iterator2\",{\"1\":{\"99\":3}}],[\"iterator1\",{\"1\":{\"99\":3}}],[\"iterator<map\",{\"1\":{\"104\":1}}],[\"iterator<student>\",{\"1\":{\"99\":1}}],[\"iterator<integer>\",{\"1\":{\"99\":3}}],[\"iterator<e>\",{\"1\":{\"76\":2}}],[\"iterator\",{\"1\":{\"76\":7,\"99\":11,\"104\":4}}],[\"its\",{\"1\":{\"79\":4,\"84\":1}}],[\"itr\",{\"1\":{\"76\":3}}],[\"it\",{\"1\":{\"75\":1}}],[\"illegalstateexception\",{\"1\":{\"76\":1}}],[\"illegal\",{\"1\":{\"73\":1}}],[\"illegalargumentexception\",{\"1\":{\"73\":1}}],[\"isprime函数是可以进行优化的\",{\"1\":{\"244\":1}}],[\"isprime\",{\"1\":{\"243\":2,\"244\":1,\"245\":12}}],[\"ispresent方法用来检查optional实例是否有值\",{\"1\":{\"47\":1}}],[\"ispresent\",{\"0\":{\"41\":1},\"1\":{\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"47\":1,\"48\":1}}],[\"ispoweroftwo\",{\"1\":{\"133\":2}}],[\"isempty\",{\"0\":{\"81\":1},\"1\":{\"70\":1,\"81\":1,\"212\":1,\"213\":6}}],[\"is\",{\"1\":{\"47\":8,\"99\":1,\"211\":1,\"225\":1}}],[\"increments\",{\"1\":{\"76\":4}}],[\"indexof\",{\"0\":{\"87\":1},\"1\":{\"82\":1,\"87\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"76\":1}}],[\"index++\",{\"1\":{\"79\":2}}],[\"index+1\",{\"1\":{\"79\":1,\"143\":1}}],[\"index\",{\"1\":{\"76\":17,\"77\":4,\"78\":3,\"79\":16,\"143\":3}}],[\"initialcapacity\",{\"1\":{\"73\":5}}],[\"inner\",{\"1\":{\"47\":6}}],[\"instance\",{\"1\":{\"47\":1}}],[\"instanceof\",{\"1\":{\"44\":1}}],[\"in\",{\"1\":{\"47\":1,\"74\":2,\"79\":5,\"211\":1}}],[\"int类型占\",{\"1\":{\"130\":1}}],[\"integer>\",{\"1\":{\"143\":1}}],[\"integers\",{\"1\":{\"99\":6}}],[\"integer\",{\"1\":{\"75\":2,\"95\":1,\"99\":2,\"108\":2,\"130\":1,\"134\":3,\"143\":4}}],[\"int\",{\"1\":{\"45\":1,\"59\":3,\"72\":1,\"73\":2,\"74\":5,\"75\":13,\"76\":14,\"77\":1,\"78\":1,\"79\":7,\"80\":1,\"84\":1,\"85\":2,\"87\":6,\"88\":1,\"95\":1,\"99\":4,\"129\":1,\"130\":2,\"131\":2,\"132\":11,\"133\":5,\"134\":26,\"136\":11,\"137\":12,\"140\":13,\"141\":14,\"142\":18,\"143\":14,\"203\":5,\"211\":4,\"212\":5,\"213\":18,\"219\":1,\"221\":6,\"222\":8,\"223\":4,\"226\":7,\"227\":6,\"242\":2,\"243\":6,\"244\":2,\"245\":12}}],[\"if考虑到所有的情况\",{\"1\":{\"226\":1}}],[\"ifpresent方法接受lambda表达式参数\",{\"1\":{\"47\":1}}],[\"ifpresent\",{\"0\":{\"42\":1},\"1\":{\"42\":1,\"47\":2,\"48\":1}}],[\"if\",{\"1\":{\"30\":3,\"31\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":1,\"44\":2,\"47\":1,\"73\":4,\"75\":7,\"76\":8,\"79\":8,\"83\":2,\"86\":1,\"87\":6,\"99\":1,\"133\":1,\"134\":2,\"137\":9,\"140\":6,\"141\":6,\"142\":17,\"143\":5,\"211\":2,\"212\":4,\"213\":17,\"216\":1,\"217\":1,\"221\":3,\"222\":3,\"226\":3,\"227\":3,\"243\":2,\"244\":1,\"245\":4}}],[\"f\",{\"1\":{\"132\":2}}],[\"framework\",{\"1\":{\"95\":1}}],[\"fromindex\",{\"1\":{\"85\":3}}],[\"from\",{\"1\":{\"79\":2}}],[\"f2\",{\"1\":{\"59\":2}}],[\"f1\",{\"1\":{\"59\":2}}],[\"fast\",{\"1\":{\"216\":7,\"217\":10,\"218\":6,\"219\":7}}],[\"fast机制\",{\"0\":{\"89\":1}}],[\"fastremove\",{\"1\":{\"79\":2}}],[\"fail\",{\"0\":{\"89\":1}}],[\"father\",{\"1\":{\"59\":16}}],[\"false\",{\"1\":{\"44\":1,\"79\":3,\"132\":1,\"133\":1,\"216\":2,\"243\":1,\"244\":1,\"245\":2}}],[\"flydean\",{\"1\":{\"109\":1}}],[\"float\",{\"1\":{\"59\":3,\"95\":2}}],[\"flatmap与map\",{\"1\":{\"47\":1}}],[\"flatmap与map方法类似\",{\"1\":{\"39\":1,\"48\":1}}],[\"flatmap方法与map方法类似\",{\"1\":{\"39\":1}}],[\"flatmaptest\",{\"1\":{\"39\":1}}],[\"flatmap不会对结果用optional封装\",{\"1\":{\"39\":1,\"48\":1}}],[\"flatmap\",{\"0\":{\"39\":1},\"1\":{\"39\":3,\"47\":1,\"48\":1}}],[\"funtion\",{\"1\":{\"47\":1}}],[\"function<user\",{\"1\":{\"38\":2,\"39\":2}}],[\"function<\",{\"1\":{\"38\":1,\"39\":1}}],[\"foreach的使用\",{\"1\":{\"88\":1}}],[\"foreach\",{\"0\":{\"88\":1},\"1\":{\"88\":2,\"104\":2,\"108\":4}}],[\"foreachremaining\",{\"1\":{\"76\":1}}],[\"for\",{\"1\":{\"75\":1,\"79\":4,\"84\":1,\"87\":4,\"134\":10,\"136\":2,\"137\":2,\"140\":1,\"141\":1,\"143\":5,\"203\":4,\"211\":2,\"212\":1,\"213\":11,\"243\":2,\"244\":1,\"245\":6}}],[\"format\",{\"1\":{\"46\":1}}],[\"foo\",{\"1\":{\"47\":2}}],[\"found\",{\"1\":{\"47\":2,\"266\":1}}],[\"fill\",{\"1\":{\"245\":2}}],[\"filter方法检查optiona值是否满足给定条件\",{\"1\":{\"47\":1}}],[\"filtertest\",{\"1\":{\"40\":1}}],[\"filter\",{\"0\":{\"40\":1},\"1\":{\"40\":3,\"47\":2,\"48\":1,\"88\":1}}],[\"find算法应用\",{\"0\":{\"259\":1}}],[\"find算法详解\",{\"0\":{\"258\":1}}],[\"findknodefromlistend\",{\"1\":{\"219\":1}}],[\"finderrornums\",{\"1\":{\"143\":2}}],[\"finally\",{\"1\":{\"79\":1}}],[\"final\",{\"1\":{\"31\":4,\"73\":3,\"75\":1,\"76\":3,\"79\":1}}],[\"first\",{\"1\":{\"99\":1,\"210\":2}}],[\"mr\",{\"1\":{\"212\":2,\"221\":1,\"222\":1,\"223\":1,\"226\":1,\"243\":2,\"244\":1,\"245\":2}}],[\"mid或者left\",{\"1\":{\"227\":1}}],[\"mid\",{\"1\":{\"137\":17,\"221\":7,\"226\":5,\"227\":10}}],[\"missingnumber\",{\"1\":{\"134\":5}}],[\"minusone\",{\"1\":{\"213\":6}}],[\"mindepth\",{\"1\":{\"212\":1}}],[\"minexpand\",{\"1\":{\"75\":2}}],[\"mincapacity如果超过了max\",{\"1\":{\"75\":1}}],[\"mincapacity\",{\"1\":{\"75\":20}}],[\"min\",{\"1\":{\"74\":1}}],[\"mypow函数也可以通过递归方式进行优化\",{\"1\":{\"141\":1}}],[\"mypow函数先对因子\",{\"1\":{\"141\":1}}],[\"mypow\",{\"1\":{\"140\":5,\"141\":5,\"142\":2}}],[\"my\",{\"1\":{\"83\":1}}],[\"mod\",{\"1\":{\"139\":1}}],[\"modified\",{\"1\":{\"79\":3}}],[\"modcount的值为1\",{\"1\":{\"76\":1}}],[\"modcount\",{\"1\":{\"76\":8,\"79\":1}}],[\"modcount++\",{\"1\":{\"75\":1,\"79\":1,\"84\":1,\"86\":1}}],[\"matlab神经网络30个案例分析\",{\"1\":{\"115\":1}}],[\"math\",{\"1\":{\"74\":1,\"75\":1,\"136\":2,\"143\":1}}],[\"make\",{\"1\":{\"83\":1}}],[\"max\",{\"1\":{\"75\":9,\"137\":11}}],[\"main\",{\"1\":{\"47\":1,\"59\":2,\"88\":1,\"99\":4,\"104\":2}}],[\"map<integer\",{\"1\":{\"104\":1}}],[\"map遍历的两种方式\",{\"1\":{\"104\":1}}],[\"map顶层接口中定义了一个方法可以获取键值对的集合\",{\"1\":{\"103\":1}}],[\"map的键是唯一的\",{\"1\":{\"103\":1}}],[\"map方法接收一个function类型的lambda表达式\",{\"1\":{\"47\":1}}],[\"map方法的lambda表达式返回值可以是任何类型\",{\"1\":{\"47\":1}}],[\"map方法的mapper函数返回值可以是任何类型t\",{\"1\":{\"39\":1}}],[\"map方法通过传入的lambda表达式修改optonal实例默认值\",{\"1\":{\"47\":1}}],[\"map方法用来对optional实例的值执行一系列操作\",{\"1\":{\"38\":1}}],[\"maptest\",{\"1\":{\"38\":1}}],[\"mapper\",{\"1\":{\"38\":3,\"39\":3}}],[\"map\",{\"0\":{\"38\":1,\"102\":1},\"1\":{\"38\":3,\"47\":5,\"48\":1,\"95\":2,\"103\":1,\"104\":9,\"108\":10}}],[\"md做标题\",{\"0\":{\"22\":1}}],[\"md做左侧标题\",{\"0\":{\"18\":1}}],[\"md\",{\"1\":{\"1\":1,\"90\":1,\"109\":1}}],[\"md就可以定义这个页面的内容\",{\"1\":{\"1\":1}}],[\"执行结果\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1}}],[\"xxstring\",{\"1\":{\"59\":1}}],[\"xiaotong\",{\"1\":{\"59\":1}}],[\"xiaotongtong\",{\"1\":{\"38\":2,\"39\":2,\"40\":3}}],[\"x\",{\"1\":{\"37\":1,\"132\":4,\"136\":3,\"142\":7,\"211\":4}}],[\"x>\",{\"1\":{\"37\":1}}],[\"<=\",{\"1\":{\"133\":1,\"134\":3,\"136\":2,\"137\":2,\"140\":1,\"141\":1,\"143\":1,\"213\":1,\"221\":1,\"227\":1,\"244\":1,\"245\":1}}],[\"<<=\",{\"1\":{\"131\":1}}],[\"<<\",{\"1\":{\"131\":5}}],[\"<\",{\"1\":{\"75\":2,\"76\":1,\"79\":4,\"83\":1,\"84\":1,\"86\":1,\"87\":2,\"132\":2,\"134\":1,\"137\":8,\"140\":2,\"141\":2,\"142\":7,\"143\":2,\"203\":1,\"211\":1,\"212\":1,\"213\":6,\"221\":1,\"222\":2,\"223\":1,\"226\":1,\"227\":1,\"243\":2,\"245\":5}}],[\"<t\",{\"1\":{\"59\":1,\"74\":1}}],[\"<t>\",{\"1\":{\"31\":1,\"32\":1,\"34\":1,\"74\":1,\"83\":1}}],[\"<x\",{\"1\":{\"37\":1}}],[\"3的倍数就不再是素数了\",{\"1\":{\"245\":1}}],[\"3是素数\",{\"1\":{\"245\":1}}],[\"31\",{\"1\":{\"136\":2}}],[\"3种\",{\"1\":{\"131\":1}}],[\"3个移位运算符\",{\"0\":{\"131\":1}}],[\"3个是移位运算符\",{\"1\":{\"129\":1}}],[\"33141246\",{\"1\":{\"109\":1}}],[\"36437446\",{\"1\":{\"99\":1}}],[\"3\",{\"1\":{\"35\":2,\"36\":2,\"59\":2,\"76\":1,\"88\":1,\"99\":8,\"104\":1,\"108\":17,\"131\":2,\"132\":1,\"134\":5,\"136\":1}}],[\"2的倍数就不再是素数了\",{\"1\":{\"245\":1}}],[\"2的幂\",{\"1\":{\"133\":1}}],[\"2是素数\",{\"1\":{\"245\":1}}],[\"2是为了防止溢出\",{\"1\":{\"226\":1}}],[\"2步\",{\"1\":{\"218\":1}}],[\"231\",{\"1\":{\"142\":1}}],[\"238559\",{\"1\":{\"142\":1}}],[\"2147483647\",{\"1\":{\"142\":1}}],[\"2147483648时候\",{\"1\":{\"142\":1}}],[\"2147483648运行时\",{\"1\":{\"142\":1}}],[\"2147483648\",{\"1\":{\"142\":2}}],[\"250\",{\"1\":{\"136\":1}}],[\"25\",{\"1\":{\"136\":13}}],[\"2^63\",{\"1\":{\"137\":2}}],[\"2^31\",{\"1\":{\"137\":1}}],[\"2^2\",{\"1\":{\"133\":1}}],[\"2^1\",{\"1\":{\"133\":1}}],[\"2^0\",{\"1\":{\"133\":1}}],[\"20\",{\"1\":{\"131\":1,\"136\":2}}],[\"2\",{\"1\":{\"35\":2,\"36\":2,\"37\":1,\"38\":1,\"39\":1,\"59\":1,\"76\":1,\"88\":1,\"95\":1,\"99\":10,\"104\":6,\"108\":17,\"131\":2,\"132\":6,\"133\":4,\"134\":13,\"136\":6,\"137\":3,\"141\":2,\"142\":8,\"143\":2,\"212\":1,\"221\":1,\"226\":1,\"227\":1,\"242\":1,\"243\":3,\"244\":2,\"245\":6}}],[\"1和right\",{\"1\":{\"227\":1}}],[\"1本书\",{\"1\":{\"225\":1}}],[\"14141417\",{\"1\":{\"131\":1}}],[\"14840194\",{\"1\":{\"75\":1,\"90\":1}}],[\"160\",{\"1\":{\"131\":1}}],[\"125\",{\"1\":{\"136\":14}}],[\"120\",{\"1\":{\"136\":1}}],[\"12\",{\"1\":{\"130\":1}}],[\"1337\",{\"1\":{\"139\":2,\"141\":1}}],[\"13\",{\"1\":{\"130\":1}}],[\"1100\",{\"1\":{\"130\":1}}],[\"1101\",{\"1\":{\"130\":1}}],[\"111100\",{\"1\":{\"131\":1}}],[\"1111\",{\"1\":{\"131\":1}}],[\"11111001\",{\"1\":{\"130\":1}}],[\"11111010\",{\"1\":{\"130\":2}}],[\"11111111\",{\"1\":{\"130\":9}}],[\"111\",{\"1\":{\"22\":1}}],[\"1的容量\",{\"1\":{\"76\":1}}],[\"10^9\",{\"1\":{\"137\":6}}],[\"1000\",{\"1\":{\"213\":1}}],[\"10000000\",{\"1\":{\"130\":1}}],[\"1001\",{\"1\":{\"130\":1}}],[\"100d\",{\"1\":{\"59\":1}}],[\"108013680\",{\"1\":{\"99\":1}}],[\"10\",{\"1\":{\"73\":3,\"131\":1,\"136\":2,\"140\":1,\"141\":1}}],[\"15\",{\"1\":{\"40\":1,\"131\":1,\"136\":2}}],[\"1xiaotongtong\",{\"1\":{\"38\":1,\"39\":1}}],[\"1\",{\"0\":{\"133\":1},\"1\":{\"35\":3,\"36\":3,\"37\":3,\"38\":2,\"39\":2,\"58\":1,\"59\":1,\"75\":1,\"76\":9,\"79\":1,\"87\":4,\"88\":1,\"95\":1,\"99\":10,\"100\":1,\"104\":2,\"108\":17,\"130\":11,\"131\":4,\"132\":5,\"133\":17,\"134\":13,\"136\":4,\"137\":11,\"140\":12,\"141\":12,\"142\":32,\"143\":16,\"202\":1,\"212\":1,\"213\":7,\"220\":1,\"221\":5,\"222\":5,\"223\":1,\"227\":7}}],[\"visited的主要作用是防止走回头路\",{\"1\":{\"211\":1}}],[\"visited\",{\"1\":{\"211\":4,\"213\":15}}],[\"val\",{\"1\":{\"203\":8,\"212\":1}}],[\"valueabsentexception\",{\"1\":{\"47\":1}}],[\"value为null的optional对象\",{\"1\":{\"34\":1}}],[\"value为null的optinal对象\",{\"1\":{\"31\":1}}],[\"value\",{\"1\":{\"31\":5,\"32\":2,\"34\":3,\"35\":2,\"36\":2,\"37\":2,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":2,\"43\":3,\"44\":2,\"45\":1,\"46\":2,\"47\":22,\"75\":4,\"103\":1,\"108\":2,\"137\":3}}],[\"vs\",{\"1\":{\"109\":1}}],[\"v>>\",{\"1\":{\"103\":1}}],[\"vector\",{\"1\":{\"100\":1}}],[\"void\",{\"1\":{\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"47\":1,\"59\":5,\"74\":1,\"75\":4,\"76\":5,\"84\":1,\"86\":1,\"88\":5,\"99\":2,\"104\":1,\"108\":1,\"130\":1,\"131\":2,\"132\":1,\"203\":5,\"213\":1,\"223\":1}}],[\"当链表长度为偶数的时候\",{\"1\":{\"218\":1}}],[\"当链表长度为奇数的时候\",{\"1\":{\"218\":1}}],[\"当快指针到达链表尽头的时候\",{\"1\":{\"218\":1}}],[\"当快慢指针相遇时\",{\"1\":{\"217\":1}}],[\"当两边有交集的时候停⽌\",{\"1\":{\"213\":1}}],[\"当n=\",{\"1\":{\"142\":1}}],[\"当做正无穷\",{\"1\":{\"137\":1}}],[\"当\",{\"1\":{\"137\":1}}],[\"当执行到remove方法\",{\"1\":{\"76\":1}}],[\"当我们可预知要保存的元素的多少时\",{\"1\":{\"75\":1}}],[\"当我们在运行过程中\",{\"1\":{\"34\":1}}],[\"当向容器中添加元素时\",{\"1\":{\"70\":1}}],[\"当value值为null时\",{\"1\":{\"34\":1}}],[\"我们只需不断把底数平方就可以算出它们\",{\"1\":{\"142\":1}}],[\"我们得到一个在\",{\"1\":{\"142\":1}}],[\"我们求中点索引时用\",{\"1\":{\"141\":1}}],[\"我们希望找到一种技巧\",{\"1\":{\"141\":1}}],[\"我们一般的方法是用一个非常大的值\",{\"1\":{\"137\":1}}],[\"我们发现\",{\"1\":{\"136\":1}}],[\"我们应该尽量避免数组容量的扩张\",{\"1\":{\"75\":1}}],[\"我们在使用上述list中\",{\"1\":{\"59\":1}}],[\"我们在项目中只用ofnullable函数而不用of函数呢\",{\"1\":{\"34\":1}}],[\"我们可以发现这样的一个规律\",{\"1\":{\"140\":1}}],[\"我们可以复用为一个方法\",{\"1\":{\"59\":1}}],[\"我们可以通过利用optional类型来摆脱所有这些null检查\",{\"1\":{\"47\":1}}],[\"我们必须编写一堆null检查来确保不会导致一个\",{\"1\":{\"47\":1}}],[\"我们首先要判断这个返回值是否为null\",{\"1\":{\"30\":1}}],[\"那就是找不到了\",{\"1\":{\"213\":1}}],[\"那就使用链表的底层结构\",{\"1\":{\"202\":1}}],[\"那就使用数组的底层结构\",{\"1\":{\"202\":1}}],[\"那再用\",{\"1\":{\"137\":1}}],[\"那可以先算一下\",{\"1\":{\"137\":1}}],[\"那这个数字就是\",{\"1\":{\"134\":1}}],[\"那也是凑巧\",{\"1\":{\"99\":1}}],[\"那肯定是不相同的\",{\"1\":{\"44\":1}}],[\"那是不是意味着\",{\"1\":{\"34\":1}}],[\"那么在n的范围中\",{\"1\":{\"245\":2}}],[\"那么在最后一个位置的元素没有引用就会被gc回收掉\",{\"1\":{\"79\":1}}],[\"那么这个数就是素数\",{\"1\":{\"242\":1}}],[\"那么这个指针最终会遇到空指针null\",{\"1\":{\"216\":1}}],[\"那么占⽤的空间增⻓速度就会慢⼀些\",{\"1\":{\"213\":1}}],[\"那么为什么还需要dfs\",{\"1\":{\"212\":1}}],[\"那么就是倒序打印链表\",{\"1\":{\"203\":1}}],[\"那么就是正序打印链表\",{\"1\":{\"203\":1}}],[\"那么就返回该value值\",{\"1\":{\"35\":1}}],[\"那么每个元素就和唯一一个索引值对应\",{\"1\":{\"143\":1}}],[\"那么算法退化成o\",{\"1\":{\"142\":2}}],[\"那么d使用int类型有可能越界\",{\"1\":{\"136\":1}}],[\"那么我们直接return\",{\"1\":{\"137\":1}}],[\"那么我们还得再计算出\",{\"1\":{\"136\":1}}],[\"那么我们再计算出\",{\"1\":{\"136\":1}}],[\"那么\",{\"1\":{\"136\":1,\"244\":1}}],[\"那么肯定有一个元素装不下\",{\"1\":{\"134\":1}}],[\"那么它的二进制表示一定只含有一个\",{\"1\":{\"133\":1}}],[\"那么输出位是\",{\"1\":{\"130\":3}}],[\"那么optional对象肯定相同\",{\"1\":{\"44\":1}}],[\"那么直接返回\",{\"1\":{\"37\":1}}],[\"那么返回一个value不为null的option对象\",{\"1\":{\"34\":1}}],[\"那么返回一个value为null的optional对象\",{\"1\":{\"34\":1}}],[\"那么一定会报空指针异常\",{\"1\":{\"32\":1}}],[\"实现一个函数\",{\"1\":{\"242\":1}}],[\"实现单调队列数据结构\",{\"0\":{\"183\":1}}],[\"实现了对map中key的排序\",{\"1\":{\"108\":1}}],[\"实际标记过程\",{\"1\":{\"245\":2}}],[\"实际就是两个索引值\",{\"1\":{\"220\":1}}],[\"实际上\",{\"1\":{\"142\":1}}],[\"实际上走不到这\",{\"1\":{\"140\":1,\"141\":1}}],[\"实际上可以丢掉\",{\"1\":{\"140\":1,\"141\":1,\"142\":2}}],[\"实际开发中可以使用lambda表达式简化\",{\"1\":{\"36\":1}}],[\"实际开发中常用\",{\"1\":{\"34\":1}}],[\"实际开发中不常用\",{\"1\":{\"32\":1}}],[\"实战项目\",{\"2\":{\"23\":1,\"24\":1}}],[\"调用了indexof方法\",{\"1\":{\"82\":1}}],[\"调用更加通用的copyof方法\",{\"1\":{\"74\":1}}],[\"调用get\",{\"1\":{\"47\":1}}],[\"调用结束时\",{\"1\":{\"39\":1,\"48\":1}}],[\"调用有参数的构造函数\",{\"1\":{\"32\":1}}],[\"调用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法\",{\"1\":{\"30\":1}}],[\"源码中对其解释\",{\"1\":{\"103\":1}}],[\"源码\",{\"1\":{\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":1}}],[\"源码解读及各api的使用\",{\"0\":{\"31\":1}}],[\"只需要从i的平方开始标记即可\",{\"1\":{\"245\":1}}],[\"只需要遍历到sqrt\",{\"1\":{\"244\":1}}],[\"只要数组有序\",{\"1\":{\"222\":1}}],[\"只要把所有的元素和索引做异或运算\",{\"1\":{\"134\":1}}],[\"只是api特性不同而已\",{\"1\":{\"202\":1}}],[\"只出现一次的数字\",{\"1\":{\"134\":1}}],[\"只有这个落单的元素会剩下\",{\"1\":{\"134\":1}}],[\"只有两个输入位都是\",{\"1\":{\"130\":1}}],[\"只有在非空的前提下才能将其作为其他方法的参数\",{\"1\":{\"30\":1}}],[\"只能对一个数操作\",{\"1\":{\"130\":1}}],[\"只能顺序访问\",{\"1\":{\"100\":1}}],[\"只能由类内部的函数调用\",{\"1\":{\"31\":1}}],[\"只不过传入的other对象可以通过一个提供者函数式接口提供\",{\"1\":{\"36\":1}}],[\"不要出现else\",{\"1\":{\"226\":1}}],[\"不再使⽤队列\",{\"1\":{\"213\":1}}],[\"不管\",{\"1\":{\"213\":1}}],[\"不管所有的限制条件\",{\"1\":{\"213\":1}}],[\"不会走回头路就不需要visited\",{\"1\":{\"211\":1}}],[\"不应该纠结于问题的细节\",{\"1\":{\"201\":1}}],[\"不应该去使用它\",{\"1\":{\"107\":1}}],[\"不考虑取模的情况\",{\"1\":{\"142\":1}}],[\"不使用递归\",{\"1\":{\"140\":1}}],[\"不用临时变量交换两个数\",{\"1\":{\"132\":1}}],[\"不同的是hashmap实现的是map接口\",{\"1\":{\"108\":1}}],[\"不同于数组的长度elementdata\",{\"1\":{\"72\":1}}],[\"不需要像arraylist那样重新计算大小或者是更新索引\",{\"1\":{\"100\":1}}],[\"不需要强制类型转换\",{\"1\":{\"59\":1}}],[\"不仅如此\",{\"1\":{\"100\":1}}],[\"不给定initialcapacity\",{\"1\":{\"73\":1}}],[\"不能出现死亡密码\",{\"1\":{\"213\":2}}],[\"不能丢掉\",{\"1\":{\"140\":1,\"141\":1,\"142\":2}}],[\"不能表示成整型\",{\"1\":{\"140\":1}}],[\"不能使其有序\",{\"1\":{\"99\":1}}],[\"不能放其它类型的元素\",{\"1\":{\"59\":1}}],[\"不能被外部所调用\",{\"1\":{\"31\":1}}],[\"不为空\",{\"1\":{\"48\":1}}],[\"不满足条件\",{\"1\":{\"40\":1}}],[\"不影响后续业务逻辑的执行\",{\"1\":{\"37\":2}}],[\"不影响后续代码执行\",{\"1\":{\"37\":1}}],[\"不想隐藏nullpointerexception\",{\"1\":{\"34\":1}}],[\"不是的\",{\"1\":{\"34\":1}}],[\"不允许value为null\",{\"1\":{\"32\":1}}],[\"不实用readme\",{\"0\":{\"22\":1}}],[\"root本身就是一层\",{\"1\":{\"212\":1}}],[\"root\",{\"1\":{\"203\":5,\"212\":4}}],[\"right=length\",{\"1\":{\"220\":1}}],[\"right\",{\"1\":{\"137\":2,\"203\":2,\"212\":5,\"221\":4,\"222\":5,\"223\":5,\"226\":4,\"227\":4}}],[\"runtime\",{\"1\":{\"83\":1}}],[\"ruancang\",{\"1\":{\"19\":2}}],[\"r++\",{\"1\":{\"79\":1}}],[\"r\",{\"1\":{\"79\":8,\"141\":1}}],[\"rangecheck\",{\"1\":{\"77\":1,\"78\":1,\"79\":1}}],[\"rangecheckforadd\",{\"1\":{\"76\":2}}],[\"reverse\",{\"1\":{\"223\":1}}],[\"reverseparallel\",{\"1\":{\"132\":1}}],[\"recursionpow\",{\"1\":{\"142\":8}}],[\"res++\",{\"1\":{\"137\":1}}],[\"result\",{\"1\":{\"134\":7,\"136\":6,\"137\":6}}],[\"res\",{\"1\":{\"134\":3,\"136\":3,\"137\":2,\"140\":3,\"141\":6,\"142\":3,\"143\":8}}],[\"retain\",{\"1\":{\"79\":1}}],[\"retains\",{\"1\":{\"79\":1}}],[\"retainall\",{\"0\":{\"79\":1},\"1\":{\"79\":1}}],[\"returned\",{\"1\":{\"74\":1,\"76\":1}}],[\"return\",{\"1\":{\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":3,\"37\":3,\"38\":4,\"39\":4,\"40\":4,\"41\":1,\"43\":1,\"44\":3,\"45\":1,\"46\":1,\"47\":3,\"59\":5,\"74\":2,\"75\":3,\"76\":8,\"77\":1,\"78\":1,\"79\":7,\"80\":1,\"81\":1,\"82\":1,\"83\":3,\"85\":1,\"87\":6,\"88\":3,\"99\":2,\"133\":4,\"134\":8,\"136\":3,\"137\":8,\"140\":9,\"141\":9,\"142\":21,\"143\":2,\"211\":2,\"212\":3,\"213\":11,\"216\":3,\"217\":1,\"218\":1,\"219\":1,\"221\":2,\"222\":2,\"226\":1,\"227\":2,\"243\":3,\"244\":2,\"245\":2}}],[\"reduce\",{\"1\":{\"76\":1}}],[\"removeif的使用\",{\"1\":{\"88\":1}}],[\"removeif\",{\"0\":{\"88\":1},\"1\":{\"88\":2}}],[\"removes\",{\"1\":{\"79\":2}}],[\"removeall\",{\"0\":{\"79\":1},\"1\":{\"79\":1}}],[\"remove\",{\"0\":{\"79\":1},\"1\":{\"76\":3,\"79\":3}}],[\"replaceall的使用\",{\"1\":{\"88\":1}}],[\"replaceall\",{\"0\":{\"88\":1},\"1\":{\"88\":2}}],[\"replace\",{\"1\":{\"73\":1}}],[\"requirenonnull\",{\"1\":{\"31\":2,\"38\":1,\"39\":2,\"40\":1,\"76\":1,\"79\":2}}],[\"twosum\",{\"1\":{\"222\":1}}],[\"twiddling\",{\"1\":{\"132\":1}}],[\"tmp\",{\"1\":{\"142\":6,\"223\":2}}],[\"tmp变量是必要的\",{\"1\":{\"142\":2}}],[\"target\",{\"1\":{\"137\":6,\"211\":2,\"213\":8,\"221\":4,\"222\":4,\"226\":4,\"227\":4}}],[\"table\",{\"1\":{\"75\":2}}],[\"temp\",{\"1\":{\"213\":13}}],[\"tech\",{\"1\":{\"90\":1,\"109\":1}}],[\"testmap\",{\"1\":{\"108\":1}}],[\"testmain\",{\"1\":{\"37\":2}}],[\"testmain$4\",{\"1\":{\"37\":2}}],[\"testarraylist\",{\"1\":{\"76\":1}}],[\"test\",{\"1\":{\"35\":1,\"36\":1,\"37\":3,\"38\":1,\"39\":1,\"40\":4,\"76\":1,\"88\":1,\"108\":1,\"130\":2,\"131\":4,\"132\":2}}],[\"type\",{\"1\":{\"58\":1,\"83\":1}}],[\"tong\",{\"1\":{\"212\":2,\"221\":1,\"222\":1,\"223\":1,\"226\":1,\"243\":2,\"244\":1,\"245\":2}}],[\"tobinarystring\",{\"1\":{\"130\":1}}],[\"toindex\",{\"1\":{\"85\":3}}],[\"toarray\",{\"0\":{\"83\":1},\"1\":{\"73\":1,\"76\":2,\"83\":2}}],[\"to\",{\"1\":{\"72\":1,\"74\":3,\"75\":1,\"76\":2,\"79\":2,\"84\":1,\"99\":1}}],[\"touppercase\",{\"1\":{\"47\":2}}],[\"tostring\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"99\":1}}],[\"tochararray\",{\"1\":{\"40\":2,\"213\":4}}],[\"tricky\",{\"1\":{\"225\":1}}],[\"trimtosize\",{\"0\":{\"86\":1},\"1\":{\"86\":1}}],[\"treenode\",{\"1\":{\"203\":7,\"212\":4}}],[\"treemap使其有序\",{\"1\":{\"108\":1}}],[\"treemap<string\",{\"1\":{\"108\":2}}],[\"treemap<>\",{\"1\":{\"99\":1,\"108\":2}}],[\"treemap是无序map\",{\"1\":{\"108\":1}}],[\"treemap\",{\"0\":{\"105\":1},\"1\":{\"108\":6,\"109\":1}}],[\"treeset使其有序性操作\",{\"1\":{\"99\":1}}],[\"treeset构造函数\",{\"1\":{\"99\":1}}],[\"treeset的构造函数有一个含有comparator参数\",{\"1\":{\"99\":1}}],[\"treeset支持有序性操作\",{\"1\":{\"99\":1}}],[\"treeset支持有序性操作的理解\",{\"1\":{\"99\":1}}],[\"treeset<student>\",{\"1\":{\"99\":1}}],[\"treeset<>\",{\"1\":{\"99\":2}}],[\"treeset<integer>\",{\"1\":{\"99\":1}}],[\"treeset和hashset都是属于无序的集合\",{\"1\":{\"99\":1}}],[\"treeset\",{\"1\":{\"99\":4}}],[\"traverse2\",{\"1\":{\"203\":2}}],[\"traverse1\",{\"1\":{\"203\":1}}],[\"traverse\",{\"1\":{\"203\":6}}],[\"trailingzeroes\",{\"1\":{\"136\":3,\"137\":22}}],[\"traffic\",{\"1\":{\"76\":1}}],[\"transient\",{\"1\":{\"72\":1}}],[\"true\",{\"1\":{\"44\":1,\"76\":1,\"79\":4,\"132\":1,\"216\":1,\"243\":1,\"244\":1,\"245\":2}}],[\"try\",{\"1\":{\"37\":2,\"47\":2,\"76\":1,\"79\":1}}],[\"t>\",{\"1\":{\"36\":1,\"40\":1,\"42\":1}}],[\"that\",{\"1\":{\"79\":3}}],[\"than\",{\"1\":{\"47\":3,\"75\":1,\"99\":2}}],[\"there\",{\"1\":{\"47\":3}}],[\"the\",{\"1\":{\"47\":8,\"74\":8,\"79\":4,\"99\":2,\"225\":2}}],[\"throwable\",{\"1\":{\"37\":11,\"47\":1}}],[\"throwable>\",{\"1\":{\"37\":1}}],[\"throws\",{\"1\":{\"37\":1,\"79\":1}}],[\"throw\",{\"1\":{\"31\":1,\"37\":1,\"43\":1,\"73\":1,\"75\":1,\"76\":6}}],[\"this\",{\"1\":{\"31\":2,\"40\":2,\"44\":1,\"73\":3,\"76\":4,\"79\":4,\"85\":1,\"99\":1}}],[\"t\",{\"1\":{\"31\":4,\"32\":1,\"33\":2,\"34\":1,\"35\":2,\"36\":1,\"37\":1,\"38\":1,\"39\":1,\"43\":1,\"59\":2,\"74\":8,\"83\":3}}],[\"eratosthenes\",{\"1\":{\"245\":1}}],[\"erasure\",{\"1\":{\"58\":1}}],[\"edu\",{\"1\":{\"132\":1}}],[\"e9ag9zbwtcs\",{\"1\":{\"115\":1}}],[\"evibktrcfex\",{\"1\":{\"115\":1}}],[\"evpxjq55lxn\",{\"1\":{\"115\":1}}],[\"even\",{\"1\":{\"79\":1}}],[\"equal\",{\"1\":{\"99\":1}}],[\"equals\",{\"0\":{\"44\":1},\"1\":{\"44\":2,\"79\":3,\"87\":2,\"213\":1}}],[\"entry<integer\",{\"1\":{\"104\":2}}],[\"entry<k\",{\"1\":{\"103\":1}}],[\"entryset\",{\"1\":{\"103\":1,\"104\":1}}],[\"entry\",{\"1\":{\"103\":1}}],[\"end\",{\"1\":{\"76\":1}}],[\"ensureexplicitcapacity\",{\"1\":{\"75\":3}}],[\"ensurecapacityinternal\",{\"1\":{\"75\":1,\"76\":4}}],[\"ensurecapacity\",{\"1\":{\"75\":1}}],[\"e\",{\"1\":{\"76\":13,\"77\":3,\"78\":1,\"79\":2}}],[\"e>\",{\"1\":{\"73\":1,\"76\":5,\"88\":3,\"99\":1}}],[\"element\",{\"1\":{\"75\":1,\"76\":4,\"77\":2}}],[\"elements\",{\"1\":{\"74\":1,\"79\":3}}],[\"elementdata的修改次数+1\",{\"1\":{\"75\":1}}],[\"elementdata\",{\"1\":{\"72\":1,\"73\":11,\"75\":12,\"76\":16,\"77\":2,\"78\":1,\"79\":16,\"83\":3,\"84\":1,\"86\":4,\"87\":4}}],[\"else\",{\"1\":{\"30\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"73\":4,\"79\":1,\"87\":2,\"137\":6,\"142\":4,\"143\":3,\"213\":5,\"221\":2,\"222\":2,\"226\":2,\"227\":2}}],[\"expectedmodcount的值就是1\",{\"1\":{\"76\":1}}],[\"expectedmodcount的初值为modcount\",{\"1\":{\"76\":1}}],[\"expectedmodcount\",{\"1\":{\"76\":4}}],[\"ex\",{\"1\":{\"47\":4,\"76\":1}}],[\"extends\",{\"1\":{\"36\":1,\"37\":2,\"38\":1,\"59\":2,\"73\":1,\"74\":1,\"76\":4}}],[\"exceptionsupplier\",{\"1\":{\"37\":2}}],[\"exception\",{\"1\":{\"34\":1}}],[\"empty\",{\"0\":{\"33\":1},\"1\":{\"31\":1,\"33\":2,\"34\":1,\"38\":2,\"39\":2,\"40\":2,\"46\":1,\"47\":5,\"48\":2,\"73\":6,\"75\":3,\"86\":1,\"211\":1}}],[\">=\",{\"1\":{\"76\":4,\"82\":1,\"87\":2,\"143\":1}}],[\">>=\",{\"1\":{\"131\":1,\"142\":3}}],[\">>>=\",{\"1\":{\"131\":1}}],[\">>>\",{\"1\":{\"131\":2}}],[\">>\",{\"1\":{\"75\":1,\"131\":5}}],[\">\",{\"1\":{\"31\":1,\"40\":2,\"44\":2,\"47\":9,\"73\":1,\"74\":1,\"75\":4,\"76\":1,\"79\":4,\"83\":1,\"104\":1,\"108\":5,\"133\":1,\"136\":1,\"137\":4,\"143\":1,\"213\":2,\"221\":1,\"222\":1,\"226\":1,\"227\":1}}],[\"部分源码\",{\"1\":{\"31\":1}}],[\"部分参数\",{\"1\":{\"30\":2}}],[\"udtsplzfqz2\",{\"1\":{\"115\":1}}],[\"u012926924\",{\"1\":{\"90\":1}}],[\"union\",{\"0\":{\"258\":1,\"259\":1}}],[\"unrpow\",{\"1\":{\"142\":5}}],[\"unrecursionpow\",{\"1\":{\"142\":2}}],[\"unaryoperator<string>\",{\"1\":{\"88\":1}}],[\"unaryoperator<e>\",{\"1\":{\"88\":1}}],[\"unaryoperator\",{\"1\":{\"88\":1}}],[\"unchecked\",{\"1\":{\"33\":1,\"74\":1,\"76\":2}}],[\"up\",{\"1\":{\"213\":12}}],[\"update\",{\"1\":{\"76\":1}}],[\"uppername\",{\"1\":{\"47\":4}}],[\"util\",{\"1\":{\"76\":2,\"143\":1}}],[\"util包下面的optional类提供了一套api来处理一个对象是否为null值的问题\",{\"1\":{\"30\":1}}],[\"u\",{\"1\":{\"74\":1}}],[\"u>\",{\"1\":{\"38\":1,\"74\":1}}],[\"user4\",{\"1\":{\"35\":2,\"36\":2,\"37\":2}}],[\"user3\",{\"1\":{\"35\":2,\"36\":2,\"37\":3}}],[\"user2为null的业务逻辑功能说明\",{\"1\":{\"37\":2}}],[\"user2\",{\"1\":{\"35\":2,\"36\":2,\"37\":2,\"38\":2,\"39\":2}}],[\"user为null\",{\"1\":{\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1}}],[\"user1为null的业务逻辑功能说明\",{\"1\":{\"37\":1}}],[\"user1\",{\"1\":{\"35\":3,\"36\":3,\"37\":3,\"38\":3,\"39\":3}}],[\"user不为null\",{\"1\":{\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1}}],[\"username\",{\"1\":{\"30\":1}}],[\"user\",{\"1\":{\"30\":4,\"35\":7,\"36\":9,\"37\":5,\"38\":9,\"39\":9}}],[\"第二版\",{\"1\":{\"115\":1}}],[\"第二个参数是拷贝之后返回的新数组的长度\",{\"1\":{\"75\":1}}],[\"第一次更新数据\",{\"1\":{\"213\":1}}],[\"第一次cursor的值为0\",{\"1\":{\"76\":1}}],[\"第一个参数是被拷贝的数组\",{\"1\":{\"75\":1}}],[\"第七行肯定不会出现空指针\",{\"1\":{\"30\":1}}],[\"第五行\",{\"1\":{\"30\":1}}],[\"对每个密码再转⼀下\",{\"1\":{\"213\":1}}],[\"对数级别\",{\"1\":{\"141\":1}}],[\"对乘法的结果求模\",{\"1\":{\"141\":1}}],[\"对list中的所有值进行异或操作\",{\"1\":{\"134\":1}}],[\"对以上求得的二进制数加\",{\"1\":{\"130\":1}}],[\"对应位相同\",{\"1\":{\"130\":1}}],[\"对应位含有1\",{\"1\":{\"130\":1}}],[\"对应位全都为1\",{\"1\":{\"130\":1}}],[\"对应的方法是add\",{\"1\":{\"76\":2}}],[\"对于temp和q2来说\",{\"1\":{\"213\":1}}],[\"对于dfs算法来说\",{\"1\":{\"212\":1}}],[\"对于这种数组问题\",{\"1\":{\"143\":1}}],[\"对于这种具有单调性的函数\",{\"1\":{\"137\":1}}],[\"对于任意的整数\",{\"1\":{\"142\":1}}],[\"对于正数和负数\",{\"1\":{\"131\":1}}],[\"对于插入和删除操作\",{\"1\":{\"100\":1}}],[\"对于随机访问\",{\"1\":{\"100\":1}}],[\"对于comparator接口的使用总结\",{\"1\":{\"99\":1}}],[\"对于有序性操作具体可以看两者的构造函数\",{\"1\":{\"99\":1}}],[\"对于基本类型\",{\"1\":{\"95\":1}}],[\"对象能否被gc的依据是是否还有引用指向它\",{\"1\":{\"79\":1}}],[\"对方法体进行修改或重写\",{\"1\":{\"59\":1}}],[\"对province对象的null值判断\",{\"1\":{\"30\":1}}],[\"对address对象的null值判断\",{\"1\":{\"30\":1}}],[\"对user对象的null值判断\",{\"1\":{\"30\":1}}],[\"极其不优雅的处理方式\",{\"1\":{\"30\":1}}],[\"极其不优雅的处理方式如下\",{\"1\":{\"30\":1}}],[\"这⾥交换\",{\"1\":{\"213\":1}}],[\"这里判断是否达到终点\",{\"1\":{\"211\":1}}],[\"这里可以改成lambda表达式的形式\",{\"1\":{\"36\":1}}],[\"这其实很好解决\",{\"1\":{\"203\":1}}],[\"这句代码执行时两个因子都是小于\",{\"1\":{\"141\":1}}],[\"这是因为sqrt\",{\"1\":{\"244\":1}}],[\"这是因为二叉树\",{\"1\":{\"212\":1}}],[\"这是因为dfs是靠递归的堆栈记录走过的路径的\",{\"1\":{\"212\":1}}],[\"这是因为幂运算的计算结果可能会非常巨大\",{\"1\":{\"142\":1}}],[\"这是由于递归的函数调用会使用栈空间\",{\"1\":{\"142\":1}}],[\"这是递归的标志\",{\"1\":{\"140\":1}}],[\"这是一个实例方法\",{\"1\":{\"35\":1}}],[\"这是一个静态方法\",{\"1\":{\"32\":1,\"33\":1,\"34\":1}}],[\"这道题目实际上给了限制\",{\"1\":{\"137\":1}}],[\"这就叫做\",{\"1\":{\"244\":1}}],[\"这就是典型的\",{\"1\":{\"213\":1}}],[\"这就是二分查找中搜索左侧边界和搜索右侧边界\",{\"1\":{\"137\":1}}],[\"这就可以抽象成⼀幅图\",{\"1\":{\"213\":1}}],[\"这就需要认真读题\",{\"1\":{\"137\":1}}],[\"这\",{\"1\":{\"137\":1,\"143\":1}}],[\"这些死亡密码是不能出现的\",{\"1\":{\"213\":1}}],[\"这些\",{\"1\":{\"136\":3}}],[\"这一步就是计算有多少个像\",{\"1\":{\"136\":1}}],[\"这个哈希集合\",{\"1\":{\"213\":1}}],[\"这个逻辑保证了一旦找到一个终点\",{\"1\":{\"212\":1}}],[\"这个\",{\"1\":{\"139\":1}}],[\"这个题的答案其实不是0就是5\",{\"1\":{\"137\":1}}],[\"这个不需要你精确计算出来\",{\"1\":{\"137\":1}}],[\"这个正无穷应该如何表示出来呢\",{\"1\":{\"137\":1}}],[\"这个主要取决于能分解出几个因子\",{\"1\":{\"136\":1}}],[\"这个一元操作符\",{\"1\":{\"130\":1}}],[\"这意味着\",{\"1\":{\"129\":1}}],[\"这意味着同一时刻多个线程可以同时写入\",{\"1\":{\"107\":1}}],[\"这代表的是一个键值对\",{\"1\":{\"103\":1}}],[\"这虽然会导致额外的性能和空间开销\",{\"1\":{\"95\":1}}],[\"这可能会导致capacity不足\",{\"1\":{\"76\":1}}],[\"这两个方法都是向容器中添加新元素\",{\"1\":{\"76\":1}}],[\"这样当快指针到链表末尾的时候\",{\"1\":{\"219\":1}}],[\"这样就得到了链表的中点\",{\"1\":{\"218\":1}}],[\"这样就产生了死循环\",{\"1\":{\"213\":1}}],[\"这样在最坏情况下空间复杂度应该是树的最下层节点的数量\",{\"1\":{\"212\":1}}],[\"这样方便理解一些\",{\"1\":{\"143\":1}}],[\"这样每个元素就和一个数组索引完全对应了\",{\"1\":{\"143\":1}}],[\"这样可以保证\",{\"1\":{\"141\":1}}],[\"这样可以放置任何类型的对象\",{\"1\":{\"72\":1}}],[\"这样的算法有一个名字\",{\"1\":{\"245\":1}}],[\"这样的运算\",{\"1\":{\"141\":1}}],[\"这样的数\",{\"1\":{\"136\":1}}],[\"这样的场景真的很少\",{\"1\":{\"34\":1}}],[\"这样再和\",{\"1\":{\"133\":1}}],[\"这使我们能够在一行中进行多个\",{\"1\":{\"47\":1}}],[\"这种操作的代价是很高的\",{\"1\":{\"75\":1}}],[\"这种参数类型可以用在类\",{\"1\":{\"59\":1}}],[\"这种情况下就用of函数\",{\"1\":{\"34\":1}}],[\"这种代码可能会出现空指针问题\",{\"1\":{\"30\":1}}],[\"这行代码可能会出问题\",{\"1\":{\"30\":1}}],[\"o衡量标准来看\",{\"1\":{\"213\":1}}],[\"o2\",{\"1\":{\"88\":2,\"99\":3,\"108\":2}}],[\"o1\",{\"1\":{\"88\":2,\"99\":3,\"108\":2}}],[\"openlock\",{\"1\":{\"213\":3}}],[\"operator\",{\"1\":{\"88\":1}}],[\"ophximfvprb\",{\"1\":{\"115\":1}}],[\"optional值不满足给定条件\",{\"1\":{\"47\":1}}],[\"optionaldemo\",{\"1\":{\"47\":1}}],[\"optional\",{\"1\":{\"31\":2,\"35\":2,\"36\":2,\"37\":2,\"38\":5,\"39\":6,\"40\":4,\"44\":1,\"46\":2,\"47\":7}}],[\"optional<string>>\",{\"1\":{\"39\":2}}],[\"optional<string>\",{\"1\":{\"38\":2,\"39\":4,\"40\":2,\"47\":5}}],[\"optional<u>>\",{\"1\":{\"39\":1}}],[\"optional<u>\",{\"1\":{\"38\":1,\"39\":1}}],[\"optional<>\",{\"1\":{\"31\":1,\"32\":1}}],[\"optional<\",{\"1\":{\"31\":1,\"44\":2}}],[\"optional<t>\",{\"1\":{\"31\":1,\"32\":1,\"33\":3,\"34\":1,\"40\":1}}],[\"optional类就是用来优雅解决该问题的方案\",{\"1\":{\"30\":1}}],[\"optional类\",{\"0\":{\"29\":1}}],[\"only\",{\"1\":{\"79\":1}}],[\"once\",{\"1\":{\"76\":1}}],[\"o\",{\"1\":{\"79\":4,\"82\":2,\"87\":6,\"99\":2,\"136\":1,\"137\":2,\"142\":5,\"143\":6,\"213\":2}}],[\"oldvalue\",{\"1\":{\"77\":2,\"79\":2}}],[\"oldcapacity\",{\"1\":{\"75\":3}}],[\"obejct\",{\"1\":{\"75\":1}}],[\"object\",{\"1\":{\"44\":1,\"72\":1,\"73\":5,\"74\":6,\"75\":1,\"76\":4,\"79\":3,\"82\":1,\"83\":1,\"87\":2}}],[\"objects\",{\"1\":{\"31\":2,\"38\":1,\"39\":2,\"40\":1,\"44\":1,\"45\":1,\"76\":1,\"79\":2}}],[\"obj\",{\"1\":{\"31\":3,\"44\":4}}],[\"overflow\",{\"1\":{\"75\":3}}],[\"override\",{\"1\":{\"36\":2,\"37\":2,\"38\":2,\"39\":2,\"40\":2,\"44\":1,\"45\":1,\"46\":1,\"59\":1,\"76\":1,\"88\":4,\"99\":1}}],[\"or\",{\"1\":{\"99\":2}}],[\"original\",{\"1\":{\"74\":7}}],[\"orelsethrow抛出由传入的lambda表达式\",{\"1\":{\"47\":1}}],[\"orelsethrow与orelse方法类似\",{\"1\":{\"47\":1}}],[\"orelsethrowtest\",{\"1\":{\"37\":1}}],[\"orelsethrow\",{\"0\":{\"37\":1},\"1\":{\"37\":3,\"47\":1,\"48\":1}}],[\"orelsetest\",{\"1\":{\"35\":1}}],[\"orelseget方法可以接受supplier接口的实现用来生成默认值\",{\"1\":{\"48\":1}}],[\"orelseget接受lambda表达式生成默认值\",{\"1\":{\"47\":1}}],[\"orelseget与orelse类似\",{\"1\":{\"47\":1}}],[\"orelsegettest\",{\"1\":{\"36\":1}}],[\"orelseget\",{\"0\":{\"36\":1},\"1\":{\"36\":3,\"47\":2,\"48\":1}}],[\"orelse\",{\"0\":{\"35\":1},\"1\":{\"35\":3,\"47\":6,\"48\":1}}],[\"ouc\",{\"1\":{\"37\":2}}],[\"outofmemoryerror\",{\"1\":{\"75\":1}}],[\"outer\",{\"1\":{\"47\":3}}],[\"out\",{\"1\":{\"30\":3,\"35\":2,\"36\":2,\"37\":2,\"38\":2,\"39\":2,\"40\":2,\"47\":14,\"59\":8,\"88\":5,\"99\":6,\"104\":3,\"108\":7,\"130\":5,\"131\":6,\"213\":1}}],[\"other\",{\"1\":{\"35\":2,\"36\":2,\"44\":2,\"79\":1}}],[\"offer\",{\"1\":{\"211\":2,\"212\":3,\"213\":6}}],[\"of会报nullpointerexception异常\",{\"1\":{\"34\":1}}],[\"ofnullable直接返回一个empty对象\",{\"1\":{\"34\":1}}],[\"ofnullable不会throw\",{\"1\":{\"34\":1}}],[\"ofnullable\",{\"0\":{\"34\":1},\"1\":{\"34\":1,\"35\":2,\"36\":2,\"37\":2,\"38\":3,\"39\":4,\"47\":1,\"48\":2}}],[\"of\",{\"0\":{\"32\":1},\"1\":{\"32\":1,\"34\":1,\"40\":2,\"47\":6,\"48\":2,\"74\":2,\"76\":3,\"79\":2,\"83\":1,\"225\":1,\"245\":1}}],[\"=size\",{\"1\":{\"76\":1}}],[\"=======\",{\"1\":{\"104\":1}}],[\"==null\",{\"1\":{\"87\":2}}],[\"==\",{\"1\":{\"31\":1,\"34\":1,\"43\":1,\"44\":1,\"73\":2,\"74\":1,\"75\":1,\"76\":1,\"79\":3,\"81\":1,\"86\":1,\"87\":2,\"88\":1,\"99\":1,\"129\":1,\"133\":2,\"137\":5,\"140\":4,\"141\":4,\"142\":12,\"212\":5,\"213\":4,\"216\":1,\"217\":1,\"221\":1,\"222\":1,\"226\":1,\"227\":1,\"243\":1,\"244\":1}}],[\"=\",{\"1\":{\"30\":6,\"31\":3,\"33\":1,\"35\":5,\"36\":5,\"37\":7,\"38\":4,\"39\":4,\"40\":2,\"41\":1,\"42\":1,\"44\":1,\"46\":1,\"47\":7,\"59\":11,\"73\":12,\"74\":1,\"75\":8,\"76\":29,\"77\":2,\"79\":16,\"83\":1,\"84\":3,\"86\":1,\"87\":4,\"88\":1,\"99\":9,\"104\":3,\"108\":4,\"129\":1,\"130\":2,\"131\":2,\"132\":28,\"133\":10,\"134\":18,\"136\":18,\"137\":26,\"140\":6,\"141\":10,\"142\":18,\"143\":15,\"203\":4,\"211\":4,\"212\":7,\"213\":50,\"216\":8,\"217\":10,\"218\":6,\"219\":7,\"221\":5,\"222\":3,\"223\":5,\"226\":6,\"227\":9,\"243\":3,\"244\":1,\"245\":12}}],[\"author\",{\"1\":{\"212\":2,\"221\":1,\"222\":1,\"223\":1,\"226\":1,\"243\":2,\"244\":1,\"245\":2}}],[\"adj\",{\"1\":{\"211\":2}}],[\"add操作之后\",{\"1\":{\"76\":1}}],[\"add添加元素的时候会首先进入该方法\",{\"1\":{\"75\":1}}],[\"addall\",{\"0\":{\"76\":1},\"1\":{\"70\":1,\"76\":4}}],[\"add\",{\"0\":{\"76\":1},\"1\":{\"59\":7,\"70\":1,\"76\":4,\"88\":4,\"99\":20,\"134\":3,\"211\":2,\"213\":16}}],[\"address\",{\"1\":{\"30\":7}}],[\"abs\",{\"1\":{\"143\":1}}],[\"abstractcollection\",{\"1\":{\"79\":1}}],[\"a自乘\",{\"1\":{\"142\":2}}],[\"a^3\",{\"1\":{\"141\":3}}],[\"a^4\",{\"1\":{\"141\":2}}],[\"a^b\",{\"1\":{\"139\":1}}],[\"a^a=0的运用\",{\"0\":{\"134\":1}}],[\"ascii码\",{\"1\":{\"132\":1}}],[\"as\",{\"1\":{\"99\":1}}],[\"age\",{\"1\":{\"99\":1}}],[\"a测试\",{\"1\":{\"88\":1}}],[\"action\",{\"1\":{\"88\":1}}],[\"access\",{\"1\":{\"72\":1}}],[\"accept\",{\"1\":{\"42\":1,\"76\":1,\"88\":1}}],[\"although\",{\"1\":{\"225\":1}}],[\"aliyundrive\",{\"1\":{\"115\":12}}],[\"allargsconstructor\",{\"1\":{\"99\":1}}],[\"all\",{\"1\":{\"79\":2,\"109\":1}}],[\"already\",{\"1\":{\"75\":1}}],[\"and\",{\"1\":{\"212\":1}}],[\"ans乘上当前的a\",{\"1\":{\"142\":2}}],[\"ans\",{\"1\":{\"142\":7}}],[\"any\",{\"1\":{\"75\":1}}],[\"anothername\",{\"1\":{\"47\":2}}],[\"a\",{\"1\":{\"59\":16,\"73\":4,\"76\":7,\"83\":9,\"88\":2,\"99\":2,\"103\":1,\"132\":24,\"134\":4,\"140\":11,\"141\":25,\"142\":26}}],[\"api方法名称\",{\"1\":{\"48\":1}}],[\"apply\",{\"1\":{\"38\":3,\"39\":3,\"88\":1}}],[\"arr\",{\"1\":{\"203\":2}}],[\"arraycopy\",{\"1\":{\"74\":2,\"76\":4,\"79\":2,\"83\":1}}],[\"array\",{\"1\":{\"73\":1,\"74\":6,\"75\":7,\"83\":1,\"220\":1}}],[\"arrays类中的静态方法\",{\"1\":{\"74\":1}}],[\"arrays\",{\"1\":{\"73\":1,\"75\":2,\"83\":2,\"86\":1,\"134\":1,\"140\":1,\"141\":1,\"245\":2}}],[\"arraylist与linkedlist在api层面都可以通过index获取\",{\"1\":{\"100\":1}}],[\"arraylist与linkedlist的区别\",{\"1\":{\"100\":1}}],[\"arraylist可以根据下标以o\",{\"1\":{\"100\":1}}],[\"arraylist优于linkedlist\",{\"1\":{\"100\":1}}],[\"arraylist也采用了快速失败的机制\",{\"1\":{\"89\":1}}],[\"arraylist也没有insert\",{\"1\":{\"76\":1}}],[\"arraylist<integer>\",{\"1\":{\"134\":1}}],[\"arraylist<>\",{\"1\":{\"88\":1,\"134\":1}}],[\"arraylist<string>\",{\"1\":{\"59\":1,\"76\":1,\"88\":1}}],[\"arraylist还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能\",{\"1\":{\"86\":1}}],[\"arraylist没有push\",{\"1\":{\"76\":1}}],[\"arraylist没有实现同步\",{\"1\":{\"70\":1}}],[\"arraylist的实现是基于数组\",{\"1\":{\"100\":1}}],[\"arraylist的实现\",{\"0\":{\"71\":1}}],[\"arraylist实现了list接口\",{\"1\":{\"70\":1}}],[\"arraylist\",{\"0\":{\"69\":1},\"1\":{\"59\":1,\"73\":4,\"76\":4,\"90\":1,\"100\":2}}],[\"arraylist有泛型机制\",{\"1\":{\"59\":1}}],[\"argument\",{\"1\":{\"99\":1}}],[\"args\",{\"1\":{\"47\":1,\"59\":2,\"88\":1,\"99\":2,\"104\":1}}],[\"are\",{\"1\":{\"79\":3}}],[\"area\",{\"1\":{\"30\":1}}],[\"article\",{\"1\":{\"59\":1,\"90\":1,\"99\":2}}],[\"at\",{\"1\":{\"37\":2,\"75\":1,\"76\":1}}],[\"cur上下左右四面的位置就是相邻节点\",{\"1\":{\"211\":1}}],[\"cur就是当前节点\",{\"1\":{\"211\":1}}],[\"cur\",{\"1\":{\"211\":4,\"212\":9,\"213\":21}}],[\"cursor\",{\"1\":{\"76\":7}}],[\"cn\",{\"1\":{\"142\":1}}],[\"cnblogs\",{\"1\":{\"75\":1,\"76\":1,\"90\":3,\"109\":1,\"131\":1}}],[\"ccgjava\",{\"1\":{\"90\":1}}],[\"ccc测试\",{\"1\":{\"88\":1}}],[\"ccc\",{\"1\":{\"88\":2}}],[\"clear\",{\"0\":{\"84\":1},\"1\":{\"79\":2,\"84\":2}}],[\"class<\",{\"1\":{\"74\":1}}],[\"classcastexception异常\",{\"1\":{\"59\":1}}],[\"class\",{\"1\":{\"30\":2,\"31\":2,\"47\":4,\"59\":3,\"72\":1,\"73\":2,\"74\":1,\"76\":1,\"99\":3,\"104\":1,\"143\":1,\"203\":3,\"212\":1,\"213\":1}}],[\"ch\",{\"1\":{\"213\":20}}],[\"children\",{\"1\":{\"203\":2}}],[\"childrens\",{\"1\":{\"203\":2}}],[\"char\",{\"1\":{\"129\":1,\"132\":6,\"213\":4}}],[\"characters\",{\"1\":{\"47\":3}}],[\"checkforcomodification\",{\"1\":{\"76\":4}}],[\"csust\",{\"1\":{\"75\":1,\"90\":1}}],[\"csdn\",{\"1\":{\"59\":1,\"90\":1,\"99\":2}}],[\"c\",{\"1\":{\"73\":3,\"76\":6,\"79\":9,\"88\":1}}],[\"canbe\",{\"1\":{\"225\":1}}],[\"calculatecapacity\",{\"1\":{\"75\":3}}],[\"capacity\",{\"1\":{\"70\":1,\"73\":2,\"75\":2}}],[\"catch\",{\"1\":{\"37\":2,\"47\":2,\"76\":1}}],[\"ctrl+o\",{\"1\":{\"59\":1}}],[\"count++\",{\"1\":{\"243\":1,\"245\":2}}],[\"count\",{\"1\":{\"243\":2,\"245\":4}}],[\"countprimes\",{\"1\":{\"242\":1,\"243\":1,\"245\":2}}],[\"collection顶层接口负责定义获得迭代器的方法\",{\"1\":{\"98\":1}}],[\"collections\",{\"1\":{\"95\":1}}],[\"collection\",{\"0\":{\"96\":1},\"1\":{\"79\":3,\"90\":2,\"95\":2,\"109\":2}}],[\"collection<\",{\"1\":{\"73\":1,\"76\":4,\"79\":3}}],[\"concurrenthashmap\",{\"1\":{\"107\":3}}],[\"concurrentmodificationexception\",{\"1\":{\"76\":6}}],[\"continue\",{\"1\":{\"137\":1,\"143\":1,\"213\":3}}],[\"contents\",{\"1\":{\"83\":1}}],[\"containskey\",{\"1\":{\"143\":1}}],[\"contains\",{\"0\":{\"82\":1},\"1\":{\"79\":2,\"82\":1,\"134\":1,\"143\":1,\"213\":11}}],[\"contained\",{\"1\":{\"79\":3}}],[\"conscious\",{\"1\":{\"75\":2}}],[\"consumer\",{\"1\":{\"42\":2,\"76\":3,\"88\":1}}],[\"consumer<string>\",{\"1\":{\"88\":1}}],[\"consumer<\",{\"1\":{\"42\":1,\"76\":1,\"88\":1}}],[\"code\",{\"1\":{\"75\":3,\"90\":1}}],[\"copy\",{\"1\":{\"74\":4}}],[\"copyof方法返回的是一个新的数组\",{\"1\":{\"75\":1}}],[\"copyof\",{\"1\":{\"73\":1,\"74\":3,\"75\":1,\"83\":2,\"86\":1,\"140\":1,\"141\":1}}],[\"copied\",{\"1\":{\"74\":2}}],[\"comparatively\",{\"1\":{\"225\":1}}],[\"comparator\",{\"1\":{\"99\":2}}],[\"comparator都是函数式接口\",{\"1\":{\"88\":1}}],[\"comparator<student>\",{\"1\":{\"99\":1}}],[\"comparator<string>\",{\"1\":{\"88\":1}}],[\"comparator<\",{\"1\":{\"88\":1,\"99\":1}}],[\"compare\",{\"1\":{\"88\":1,\"99\":1}}],[\"compatibility\",{\"1\":{\"79\":1}}],[\"complement\",{\"1\":{\"79\":2}}],[\"com\",{\"1\":{\"37\":2,\"75\":1,\"76\":1,\"90\":3,\"109\":2,\"115\":12,\"131\":1,\"142\":1}}],[\"city\",{\"1\":{\"30\":1}}],[\"sqrt\",{\"1\":{\"244\":3,\"245\":1}}],[\"slow最终的位置是中间偏右\",{\"1\":{\"218\":1}}],[\"slow恰巧停留在中间位置\",{\"1\":{\"218\":1}}],[\"slow=fast的时候\",{\"1\":{\"217\":1}}],[\"slow\",{\"1\":{\"216\":5,\"217\":10,\"218\":5,\"219\":5}}],[\"sz\",{\"1\":{\"211\":2,\"213\":4}}],[\"short\",{\"1\":{\"129\":1}}],[\"shortname\",{\"1\":{\"47\":2}}],[\"search\",{\"1\":{\"210\":2,\"225\":1}}],[\"second\",{\"1\":{\"99\":1}}],[\"set<string>\",{\"1\":{\"213\":12}}],[\"set<node>\",{\"1\":{\"211\":1}}],[\"set<integer>\",{\"1\":{\"143\":1}}],[\"set<map\",{\"1\":{\"103\":1}}],[\"set1\",{\"1\":{\"99\":7}}],[\"set\",{\"0\":{\"77\":1,\"99\":1},\"1\":{\"70\":1,\"77\":1,\"99\":7,\"134\":3,\"143\":3}}],[\"setusername\",{\"1\":{\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1}}],[\"setter\",{\"1\":{\"30\":2,\"99\":1}}],[\"specified\",{\"1\":{\"79\":3}}],[\"surprisingly\",{\"1\":{\"225\":1}}],[\"sum2\",{\"1\":{\"134\":3}}],[\"sum1\",{\"1\":{\"134\":2}}],[\"sum++\",{\"1\":{\"133\":1}}],[\"sum\",{\"1\":{\"133\":2,\"134\":2,\"222\":4}}],[\"sublistrangecheck\",{\"1\":{\"85\":1}}],[\"sublist\",{\"0\":{\"85\":1},\"1\":{\"85\":2}}],[\"such\",{\"1\":{\"76\":1}}],[\"superpow\",{\"1\":{\"140\":2,\"141\":2}}],[\"super\",{\"1\":{\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"76\":1,\"88\":3,\"99\":1}}],[\"supposed\",{\"1\":{\"75\":1}}],[\"supplier<throwable>\",{\"1\":{\"37\":2}}],[\"supplier<user>\",{\"1\":{\"36\":2}}],[\"supplier<\",{\"1\":{\"36\":1,\"37\":1}}],[\"suppresswarnings\",{\"1\":{\"33\":1,\"74\":1,\"76\":2}}],[\"srcpos\",{\"1\":{\"74\":2}}],[\"src\",{\"1\":{\"74\":2}}],[\"singlenumber\",{\"1\":{\"134\":1}}],[\"simplify\",{\"1\":{\"72\":1}}],[\"size的值变为0\",{\"1\":{\"76\":1}}],[\"size++\",{\"1\":{\"76\":2}}],[\"size+1\",{\"1\":{\"75\":1}}],[\"size维护了数组中元素的数量\",{\"1\":{\"72\":1}}],[\"size\",{\"0\":{\"80\":1},\"1\":{\"70\":1,\"72\":1,\"73\":2,\"75\":9,\"76\":15,\"79\":12,\"80\":2,\"81\":1,\"83\":6,\"84\":2,\"85\":1,\"86\":3,\"87\":4,\"211\":1,\"212\":3,\"213\":4}}],[\"synchronized\",{\"1\":{\"70\":1}}],[\"system类中的静态本地方法\",{\"1\":{\"74\":1}}],[\"system\",{\"1\":{\"30\":3,\"35\":2,\"36\":2,\"37\":2,\"38\":2,\"39\":2,\"40\":2,\"47\":14,\"59\":8,\"74\":1,\"76\":4,\"79\":2,\"83\":1,\"88\":5,\"99\":6,\"104\":3,\"108\":7,\"130\":5,\"131\":6,\"213\":1}}],[\"s2\",{\"1\":{\"59\":2}}],[\"sayhello\",{\"1\":{\"59\":18}}],[\"sana\",{\"1\":{\"47\":1}}],[\"sanaulla\",{\"1\":{\"47\":7}}],[\"s1\",{\"1\":{\"59\":2}}],[\"solution\",{\"1\":{\"142\":1,\"143\":1,\"213\":1}}],[\"solutions\",{\"1\":{\"142\":1}}],[\"sort的使用\",{\"1\":{\"88\":1}}],[\"sort\",{\"0\":{\"88\":1},\"1\":{\"88\":2,\"134\":1}}],[\"source\",{\"1\":{\"74\":2}}],[\"son\",{\"1\":{\"59\":8}}],[\"some\",{\"1\":{\"47\":1}}],[\"s\",{\"1\":{\"40\":4,\"46\":1,\"75\":1,\"83\":1,\"88\":6,\"108\":12,\"115\":12,\"213\":18}}],[\"step++\",{\"1\":{\"211\":1,\"213\":3}}],[\"step\",{\"1\":{\"211\":3,\"213\":6}}],[\"student\",{\"1\":{\"99\":9}}],[\"students\",{\"1\":{\"99\":8}}],[\"straightforward\",{\"1\":{\"225\":1}}],[\"str\",{\"1\":{\"76\":2}}],[\"stringoptional2\",{\"1\":{\"38\":2,\"39\":2,\"40\":2}}],[\"stringoptional1\",{\"1\":{\"38\":2,\"39\":2,\"40\":2}}],[\"string>>\",{\"1\":{\"104\":1}}],[\"string>\",{\"1\":{\"38\":2,\"104\":2,\"108\":4}}],[\"string\",{\"1\":{\"30\":7,\"38\":2,\"40\":2,\"46\":2,\"47\":3,\"59\":4,\"76\":2,\"88\":7,\"99\":2,\"104\":1,\"213\":34}}],[\"start\",{\"1\":{\"211\":3}}],[\"starting\",{\"1\":{\"74\":2}}],[\"stanford\",{\"1\":{\"132\":1}}],[\"static<t>\",{\"1\":{\"33\":1}}],[\"static\",{\"1\":{\"31\":2,\"32\":1,\"34\":1,\"47\":1,\"59\":6,\"73\":3,\"74\":3,\"75\":3,\"88\":1,\"99\":2,\"104\":1}}],[\"plusone\",{\"1\":{\"213\":6}}],[\"poll\",{\"1\":{\"211\":1,\"212\":1,\"213\":2}}],[\"powx\",{\"1\":{\"142\":2}}],[\"pow\",{\"1\":{\"136\":2,\"142\":1}}],[\"positive\",{\"1\":{\"99\":1}}],[\"position\",{\"1\":{\"74\":2}}],[\"pq7xvp9bxdr\",{\"1\":{\"115\":1}}],[\"put\",{\"1\":{\"104\":4,\"108\":16,\"143\":2}}],[\"public>protected>default>private\",{\"1\":{\"59\":1}}],[\"public<u>\",{\"1\":{\"38\":1,\"39\":1}}],[\"public\",{\"1\":{\"30\":2,\"31\":3,\"32\":1,\"33\":1,\"34\":1,\"35\":2,\"36\":4,\"37\":4,\"38\":3,\"39\":3,\"40\":4,\"41\":1,\"42\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":1,\"47\":2,\"59\":8,\"73\":3,\"74\":3,\"75\":2,\"76\":10,\"77\":1,\"78\":1,\"79\":4,\"80\":1,\"81\":1,\"82\":1,\"83\":2,\"84\":1,\"85\":1,\"86\":1,\"87\":2,\"88\":9,\"99\":6,\"104\":2,\"108\":1,\"130\":1,\"131\":2,\"132\":1,\"133\":3,\"134\":6,\"136\":3,\"137\":6,\"140\":3,\"141\":4,\"142\":7,\"143\":2,\"213\":3}}],[\"part2\",{\"1\":{\"140\":2,\"141\":2}}],[\"part1\",{\"1\":{\"140\":2,\"141\":2}}],[\"parseint\",{\"1\":{\"108\":2}}],[\"param\",{\"1\":{\"74\":7}}],[\"pair\",{\"1\":{\"103\":1}}],[\"pdai\",{\"1\":{\"90\":1,\"109\":1}}],[\"p\",{\"1\":{\"75\":1,\"76\":1,\"90\":3,\"109\":2,\"131\":1,\"142\":1,\"203\":4}}],[\"person\",{\"1\":{\"59\":1}}],[\"problems\",{\"1\":{\"142\":1}}],[\"province==null\",{\"1\":{\"30\":1}}],[\"province\",{\"1\":{\"30\":6}}],[\"preimagesizefzf\",{\"1\":{\"137\":2}}],[\"preserve\",{\"1\":{\"79\":1}}],[\"present\",{\"1\":{\"43\":1,\"47\":4}}],[\"predicate\",{\"1\":{\"40\":3,\"88\":1}}],[\"predicate<string>\",{\"1\":{\"40\":2,\"88\":1}}],[\"predicate<\",{\"1\":{\"40\":1,\"88\":1}}],[\"priorityqueue\",{\"1\":{\"101\":1}}],[\"print\",{\"1\":{\"88\":1,\"99\":3,\"108\":4}}],[\"printstacktrace\",{\"1\":{\"37\":2}}],[\"println\",{\"1\":{\"30\":3,\"35\":2,\"36\":2,\"37\":2,\"38\":2,\"39\":2,\"40\":2,\"47\":14,\"59\":8,\"88\":4,\"99\":3,\"104\":3,\"108\":3,\"130\":5,\"131\":6,\"213\":1}}],[\"private\",{\"1\":{\"30\":6,\"31\":4,\"59\":4,\"72\":2,\"73\":3,\"75\":6,\"76\":1,\"79\":1,\"99\":2}}],[\"phonenumber\",{\"1\":{\"30\":1}}],[\"nim游戏\",{\"0\":{\"261\":1}}],[\"nloglogn\",{\"1\":{\"245\":1}}],[\"n^2\",{\"1\":{\"243\":1}}],[\"n叉树的层序遍历\",{\"1\":{\"212\":1}}],[\"n叉树的遍历又可以扩展到图的遍历\",{\"1\":{\"203\":1}}],[\"n叉树的遍历框架如下所示\",{\"1\":{\"203\":1}}],[\"n皇后问题\",{\"0\":{\"208\":1}}],[\"n=\",{\"1\":{\"142\":1}}],[\"n往右移一位\",{\"1\":{\"142\":2}}],[\"n++\",{\"1\":{\"137\":1}}],[\"n如果是int的最大值\",{\"1\":{\"136\":1}}],[\"n可以分解出多少个因子5\",{\"1\":{\"136\":1}}],[\"n\",{\"0\":{\"133\":2},\"1\":{\"100\":1,\"132\":7,\"133\":26,\"134\":13,\"136\":24,\"137\":28,\"141\":1,\"142\":30,\"143\":10,\"202\":4,\"212\":3,\"213\":1,\"242\":2,\"243\":6,\"244\":10,\"245\":9}}],[\"navigablemap是sortedmap的一种\",{\"1\":{\"108\":1}}],[\"native\",{\"1\":{\"74\":1,\"76\":1}}],[\"name\",{\"1\":{\"47\":12,\"59\":3}}],[\"num\",{\"1\":{\"134\":8,\"143\":5}}],[\"nums\",{\"1\":{\"134\":22,\"143\":13,\"221\":5,\"222\":4,\"223\":6,\"226\":4,\"227\":5}}],[\"num2\",{\"1\":{\"130\":4}}],[\"num1\",{\"1\":{\"130\":4}}],[\"nummoved\",{\"1\":{\"76\":3,\"79\":3}}],[\"numnew\",{\"1\":{\"76\":11}}],[\"number\",{\"1\":{\"74\":1}}],[\"number>\",{\"1\":{\"59\":1}}],[\"null值的区别\",{\"1\":{\"108\":1}}],[\"nullpointerexception\",{\"1\":{\"31\":1,\"47\":1}}],[\"null\",{\"1\":{\"30\":3,\"31\":2,\"34\":1,\"35\":2,\"36\":2,\"37\":4,\"38\":1,\"39\":1,\"41\":1,\"42\":1,\"43\":1,\"46\":1,\"47\":2,\"79\":4,\"83\":1,\"84\":1,\"87\":2,\"203\":1,\"212\":7,\"216\":3,\"217\":2,\"218\":2,\"219\":1}}],[\"node\",{\"1\":{\"211\":4}}],[\"noargsconstructor\",{\"1\":{\"99\":1}}],[\"not\",{\"1\":{\"75\":1,\"79\":1,\"211\":2,\"266\":1}}],[\"non\",{\"1\":{\"72\":1}}],[\"no\",{\"1\":{\"43\":1,\"47\":6,\"76\":1}}],[\"nosuchelementexception\",{\"1\":{\"43\":1,\"47\":1,\"76\":1}}],[\"negative\",{\"1\":{\"99\":1}}],[\"next和remove操作之前都会先调用checkforcomodification来检查expectedmodcount和modcount是否相等\",{\"1\":{\"76\":1}}],[\"next\",{\"1\":{\"76\":3,\"99\":4,\"104\":4,\"203\":3,\"216\":5,\"217\":6,\"218\":4,\"219\":3}}],[\"nested\",{\"1\":{\"47\":6,\"72\":1}}],[\"newcapacity\",{\"1\":{\"75\":7}}],[\"newinstance\",{\"1\":{\"74\":1}}],[\"newtype\",{\"1\":{\"74\":3}}],[\"newlength\",{\"1\":{\"74\":7}}],[\"new\",{\"1\":{\"31\":2,\"32\":1,\"35\":3,\"36\":5,\"37\":5,\"38\":3,\"39\":3,\"40\":2,\"43\":1,\"47\":2,\"59\":8,\"73\":2,\"74\":1,\"75\":1,\"76\":8,\"83\":1,\"85\":1,\"88\":5,\"99\":12,\"104\":1,\"108\":4,\"134\":2,\"143\":3,\"212\":1,\"213\":18,\"222\":2,\"245\":2}}],[\"net\",{\"1\":{\"19\":1,\"59\":1,\"90\":1,\"99\":2}}],[\"netty高级\",{\"1\":{\"8\":1}}],[\"netty核心\",{\"1\":{\"8\":1}}],[\"netty\",{\"0\":{\"8\":1}}],[\"npe问题就是在开发中经常碰到的nullpointerexception\",{\"1\":{\"30\":1}}],[\"引入了分段锁\",{\"1\":{\"107\":1}}],[\"引入泛型\",{\"1\":{\"59\":1}}],[\"引入\",{\"0\":{\"30\":1},\"1\":{\"142\":1}}],[\"系统设计\",{\"2\":{\"20\":1,\"21\":1}}],[\"官网\",{\"1\":{\"19\":1}}],[\"专业软件免费下载\",{\"1\":{\"19\":1}}],[\"专业软件\",{\"0\":{\"19\":1}}],[\"在一个有序数组中查找一个数\",{\"1\":{\"227\":1}}],[\"在一个类中\",{\"1\":{\"59\":1}}],[\"在nums中找到两个数使得它们相加之和等于target\",{\"1\":{\"222\":1}}],[\"在此给出最简单的二分查找算法\",{\"1\":{\"221\":1}}],[\"在双向bfs算法中\",{\"1\":{\"213\":1}}],[\"在转1000的时候还会转到0000\",{\"1\":{\"213\":1}}],[\"在最坏情况下顶多就是树的高度\",{\"1\":{\"212\":1}}],[\"在这⾥增加步数\",{\"1\":{\"213\":4}}],[\"在这里更新步数\",{\"1\":{\"211\":1}}],[\"在这种情况下\",{\"1\":{\"100\":1}}],[\"在详细一点就是\",{\"1\":{\"203\":1}}],[\"在bst中删除一个数\",{\"0\":{\"164\":1}}],[\"在bst中插入一个数\",{\"0\":{\"163\":1}}],[\"在bst中查找一个数是否存在\",{\"0\":{\"162\":1}}],[\"在无限序列中随机抽取元素\",{\"0\":{\"144\":1}}],[\"在区间\",{\"1\":{\"137\":1}}],[\"在数字没有溢出的前提下\",{\"1\":{\"131\":1}}],[\"在插入的时候就使其按照我们自定义排序的方式存储\",{\"1\":{\"99\":1}}],[\"在插入之前也需要进行空间检查\",{\"1\":{\"76\":1}}],[\"在面对并发的修改时\",{\"1\":{\"89\":1}}],[\"在调用list\",{\"1\":{\"76\":1}}],[\"在使用迭代器遍历集合的时候同时修改集合元素\",{\"1\":{\"76\":1}}],[\"在arraylist中有个成员变量modcount\",{\"1\":{\"76\":1}}],[\"在add元素的时候会修正默认容量\",{\"1\":{\"73\":1}}],[\"在指定元素赋值\",{\"1\":{\"76\":1}}],[\"在指定index位置一次性添加多个元素\",{\"1\":{\"76\":1}}],[\"在列表末尾一次性添加多个元素\",{\"1\":{\"76\":1}}],[\"在实际问题中\",{\"1\":{\"142\":1}}],[\"在实际添加大量元素前\",{\"1\":{\"75\":1}}],[\"在实际开发中\",{\"1\":{\"30\":1}}],[\"在java8中提高对象的null值安全性\",{\"1\":{\"47\":1}}],[\"在optional实例上调用get\",{\"1\":{\"47\":1}}],[\"在线技术文档\",{\"0\":{\"12\":1}}],[\"在项目目录页面建立一个readme\",{\"1\":{\"1\":1}}],[\"企业级框架\",{\"0\":{\"7\":1}}],[\"笔记目录页\",{\"0\":{\"4\":1}}],[\"导航\",{\"2\":{\"2\":1,\"3\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"26\":1,\"27\":1,\"113\":1,\"114\":1,\"122\":1,\"123\":1}}],[\"目录\",{\"2\":{\"2\":1,\"3\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"26\":1,\"27\":1,\"113\":1,\"114\":1,\"122\":1,\"123\":1}}],[\"目录1\",{\"0\":{\"267\":1},\"1\":{\"1\":4}}],[\"项目目录页\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
